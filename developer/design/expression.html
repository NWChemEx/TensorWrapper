<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Designing the Expression Component &mdash; TensorWrapper 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=8d563738"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Designing the OpGraph" href="op_graph.html" />
    <link rel="prev" title="Designing TensorWrapper Class" href="tensor_wrapper.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo_candybar.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../background/index.html">TensorWrapper Background</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Developer Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Design of TensorWrapper</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="motivation.html">Motivating TensorWrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="overview.html">Overview of TensorWrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="shape.html">Tensor Shape Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="symmetry.html">Designing the Symmetry Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="sparsity.html">Tensor Sparsity Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="layout.html">Designing the Layout Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="allocator.html">Designing the Allocator</a></li>
<li class="toctree-l3"><a class="reference internal" href="buffer.html">Designing the Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="tensor_wrapper.html">Designing <code class="docutils literal notranslate"><span class="pre">TensorWrapper</span></code> Class</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Designing the Expression Component</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-is-the-expression-component">What is the expression component?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#why-do-we-need-an-expression-component">Why do we need an expression component?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expression-component-considerations">Expression Component Considerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expression-component-design">Expression Component Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-api">User API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-api">Example API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#understanding-the-linked-state">Understanding the Linked State</a></li>
<li class="toctree-l4"><a class="reference internal" href="#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-notes">Other Notes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="op_graph.html">Designing the OpGraph</a></li>
<li class="toctree-l3"><a class="reference internal" href="sparse_maps.html">Designing the Sparse Map Component</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../sparse_maps/index.html">Sparse Maps Sublibrary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography/bibliography.html">References</a></li>
<li class="toctree-l1"><a class="reference external" href="https://nwchemex.github.io/TensorWrapper/tensorwrapper_cxx_api/index.html">C++ API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TensorWrapper</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Developer Documentation</a></li>
          <li class="breadcrumb-item"><a href="index.html">Design of TensorWrapper</a></li>
      <li class="breadcrumb-item active">Designing the Expression Component</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/NWChemEx/TensorWrapper/edit/master/docs/source/developer/design/expression.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="designing-the-expression-component">
<span id="id1"></span><h1>Designing the Expression Component<a class="headerlink" href="#designing-the-expression-component" title="Link to this heading"></a></h1>
<p>This page documents the process of designing the expression component of
TensorWrapper.</p>
<section id="what-is-the-expression-component">
<h2>What is the expression component?<a class="headerlink" href="#what-is-the-expression-component" title="Link to this heading"></a></h2>
<p>Users of a tensor library have two main needs: to create tensors and to solve
tensor expressions involving those tensors. The expression component contains
the pieces of the <a class="reference internal" href="../../background/terminology.html#term-dsl"><span class="std std-ref">domain specific language (DSL)</span></a> required to write succinct tensor expressions.</p>
</section>
<section id="why-do-we-need-an-expression-component">
<h2>Why do we need an expression component?<a class="headerlink" href="#why-do-we-need-an-expression-component" title="Link to this heading"></a></h2>
<p>Most libraries tend to be eagerly evaluated, meaning code is evaluated as it is
encountered. For simple, easily optimized code such a strategy is fine.
Unfortunately, tensor expressions tend to be significantly harder to optimize,
plus the optimal evaluation tends to be highly runtime dependent. A potential
solution to this problem is to evaluate the code lazily, instead of eagerly.
Lazily evaluated code is “recorded” until it is needed. Once it is needed it
is played back.</p>
<p>Most tensor operations are steps in a bigger algorithm. By lazily
evaluating tensor computations we can register the user’s intention and
optimize our evaluation strategy accordingly. The point of the expression layer
is to provide a user-friendly DSL for lazy evaluation of tensors.</p>
</section>
<section id="expression-component-considerations">
<span id="ec-considerations"></span><h2>Expression Component Considerations<a class="headerlink" href="#expression-component-considerations" title="Link to this heading"></a></h2>
<dl class="simple" id="ec-compose-multiple-objects">
<dt>compose multiple objects</dt><dd><p>While our goal is to ultimately be able to compose <code class="docutils literal notranslate"><span class="pre">TensorWrapper</span></code> objects,
we can decompose the work needed to do so by ensuring we can compose the
pieces of the <code class="docutils literal notranslate"><span class="pre">TensorWrapper</span></code> object. In particular we want to be able to
compose objects from the shape, symmetry, sparsity, and allocator components.</p>
</dd>
</dl>
<dl class="simple" id="ec-generalized-einstein-notation">
<dt>generalized Einstein notation</dt><dd><p>Many of the most common tensor operations are succinctly specified using
generalized Einstein notation (indices appearing on the right side of
an equation, but not the left are summed over).</p>
<ul class="simple">
<li><p>There are some gotchas (see <a class="reference internal" href="../../background/einstein_summation_convention.html#einstein-summation-convention"><span class="std std-ref">Einstein Summation Convention</span></a>).</p></li>
<li><p>Math operations include: addition, subtraction, scaling, multiplication,
and division. The latter is missing from a number of existing tensor
libraries.</p></li>
<li><p>Note that multiplication actually covers a number of operations including:
element-wise product, matrix multiplication, contraction, trace, and direct
product.</p></li>
<li><p>Could actually enable an alternative syntax with explicit summations.</p></li>
</ul>
</dd>
</dl>
<dl class="simple" id="ec-non-einstein-math">
<dt>non-Einstein math</dt><dd><p>There are a number of tensor operations which are not easily expressed using
generalized Einstein notation, but are still important for tensor algebra.
In particular:</p>
<ul class="simple">
<li><p>Eigen system and linear equation solvers.</p></li>
<li><p>Factorizations/decompositions: Cholesky, QR, SVD.</p></li>
<li><p>Slicing/chipping</p></li>
<li><p>Matrix powers</p></li>
</ul>
</dd>
</dl>
<dl class="simple" id="ec-template-meta-programming-cost">
<dt>template meta-programming cost</dt><dd><p>In C++ lazy evaluation is typically implemented by using the template meta-
programming technique known as expression templates. Ultimately expression
templates map different expressions to different types. The type of an
expression is usually a heavily nested instantiation of a template class,
which can lead to significant compiler overhead (as well as nearly
undecipherable compiler errors, though C++20 concepts helps a lot in this
regard).</p>
</dd>
</dl>
<dl class="simple" id="ec-reusable-intermediates">
<dt>reusable intermediates</dt><dd><p>In most tensor libraries the expression layer goes from a series of sources
to a single sink. Along the way a series of temporary, unnamed intermediates
is created. If any of these intermediates is common to more than one
expression we want to make sure those intermediates are only formed once.</p>
<ul class="simple">
<li><p><em>N.b.</em> while an expression like <code class="docutils literal notranslate"><span class="pre">A(&quot;i,j,k&quot;)</span> <span class="pre">+</span> <span class="pre">B(&quot;i,j,k&quot;)</span></code> is clearly an
intermediate, so is <code class="docutils literal notranslate"><span class="pre">A(&quot;i,j,k&quot;)</span></code>. This is because <code class="docutils literal notranslate"><span class="pre">A(&quot;i,j,k&quot;)</span></code>
corresponds to tensor access of the “i,j,k”-th element and may be
non-trivial (also note that behind the scenes, for performance,
TensorWrapper may map the element access to “slice access followed by
element access”).</p></li>
</ul>
</dd>
</dl>
<dl class="simple" id="ec-sparse-maps">
<dt>sparse maps</dt><dd><p>The sparsity component <a class="reference internal" href="sparsity.html#sparsity-design"><span class="std std-ref">Tensor Sparsity Design</span></a> realized that sparse maps are
a mechanism for creating sparsity objects and thus should live above the
sparsity component. Sparse maps are most naturally expressed as
relationships among dummy indices, that is given an expression like
<code class="docutils literal notranslate"><span class="pre">C(&quot;i,j&quot;)</span> <span class="pre">=</span> <span class="pre">A(&quot;i,j,a,b&quot;)</span> <span class="pre">*</span> <span class="pre">B(&quot;i,j,b,a&quot;);</span></code> we would define a sparse map, say
which maps a given <code class="docutils literal notranslate"><span class="pre">i,j</span></code> pair to a set of corresponding, non-zero <code class="docutils literal notranslate"><span class="pre">a,b</span></code>
pairs. From that sparse map we can work out the sparsity of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>,
and <code class="docutils literal notranslate"><span class="pre">C</span></code>. The trick is we need to know how the sparse map’s modes map to
the modes of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, and <code class="docutils literal notranslate"><span class="pre">C</span></code>. This information is
available in the expression layer.</p>
<ul class="simple">
<li><p>The design of the sparse map objects is punted to the sparse map component
of TensorWrapper (see <a class="reference internal" href="sparse_maps.html#tw-designing-the-sparse-map-component"><span class="std std-ref">Designing the Sparse Map Component</span></a>).</p></li>
<li><p>The API needs to work for sparse maps which map from one or more modes to
one or more modes, <em>i.e.</em>, we should not assume that we are always mapping
a single mode to a single mode.</p></li>
</ul>
</dd>
</dl>
<dl class="simple" id="ec-linked">
<dt>linked</dt><dd><p>Ultimately all expressions which are to be treated together will need to be
linked so they can share information. Linked in this context means that they
share common state.</p>
<ul class="simple">
<li><p>The lifetime of the common state will likely need to be managed by a shared
pointer.</p></li>
</ul>
</dd>
</dl>
<section id="out-of-scope">
<h3>Out of Scope<a class="headerlink" href="#out-of-scope" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>expression optimization</dt><dd><p>The goal of the expression layer is simply to capture the information needed
to perform the calculation, not to optimize the calculation, or to perform
it. Optimizing the calculation can be done using the OpGraph component (see
<a class="reference internal" href="op_graph.html#tw-designing-the-opgraph"><span class="std std-ref">Designing the OpGraph</span></a>). Running the calculation is done by the
backend of the Buffer component, given an OpGraph object (see
<a class="reference internal" href="buffer.html#tw-designing-the-buffer"><span class="std std-ref">Designing the Buffer</span></a>).</p>
</dd>
<dt>finding common intermediates</dt><dd><p>While consideration <a class="reference internal" href="#ec-reusable-intermediates"><span class="std std-ref">reusable intermediates</span></a> concerns the expression
layer being able to annotate common intermediates, actually finding said
common intermediates is much harder. For now it is the user’s job to identify
common intermediates.</p>
</dd>
<dt>filling in the sparse maps</dt><dd><p>Sparse maps are an alternative means of specifying sparsity. As with the
objects in the sparsity component (see <a class="reference internal" href="sparsity.html#sparsity-design"><span class="std std-ref">Tensor Sparsity Design</span></a>) filling in
the sparse map is left to the user.</p>
</dd>
</dl>
</section>
</section>
<section id="expression-component-design">
<h2>Expression Component Design<a class="headerlink" href="#expression-component-design" title="Link to this heading"></a></h2>
<figure class="align-center" id="id4">
<span id="fig-expression-component"></span><img alt="../../_images/expressions.png" src="../../_images/expressions.png" />
<figcaption>
<p><span class="caption-number">Fig. 14 </span><span class="caption-text">Overall inheritance diagram for the classes comprising the expression
component of TensorWrapper.</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-expression-component"><span class="std std-numref">Fig. 14</span></a> shows the classes involved in TensorWrapper’s
expression component and how they are related. The following subsections
describe the main highlights of the hierarchy in more detail.</p>
<section id="expression">
<h3>Expression<a class="headerlink" href="#expression" title="Link to this heading"></a></h3>
<p>The base of the class hierarchy
is <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> which is templated on the type of object being composed.
For example viable options for <code class="docutils literal notranslate"><span class="pre">T</span></code> are <code class="docutils literal notranslate"><span class="pre">Shape</span></code> and <code class="docutils literal notranslate"><span class="pre">TensorWrapper</span></code>.
Templating on the object being composed addresses
<a class="reference internal" href="#ec-compose-multiple-objects"><span class="std std-ref">compose multiple objects</span></a>. The <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> object will also
contain a pointer to the linked state (see consideration <a class="reference internal" href="#ec-linked"><span class="std std-ref">linked</span></a>).</p>
<p>The main motivation for this class is to define the API all derived classes
must obey and then to interact with those classes through the base class. In
particular this approach relies on dynamic polymorphism, not the static
polymorphism usually leveraged in expression templates. This paves the way for
addressing <a class="reference internal" href="#ec-template-meta-programming-cost"><span class="std std-ref">template meta-programming cost</span></a>.</p>
<p>As a note, since the API for composing expression objects will involve
taking objects by their base class and returning them wrapped in a derived
class, to avoid loops in the hierarchy where the base class depends on the
derived class, most operations will need to be defined as free functions. For
example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Addition</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Expression</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Expression</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">);</span>
<span class="n">CholeskyVectors</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cholesky</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Expression</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A</span><span class="p">);</span>
</pre></div>
</div>
<p>The definitions will
One of the key properties of any <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> object is that when assigned
to an object of type <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> it can produce an object of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because assigning to <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> has to be treated specially care needs
to be taken in defining copy/move assignment operators.</p>
</div>
</section>
<section id="nary">
<h3>Nary<a class="headerlink" href="#nary" title="Link to this heading"></a></h3>
<p>Deriving from <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> is the <code class="docutils literal notranslate"><span class="pre">Nary&lt;N,T&gt;</span></code> class (n-ary being the
generalization of unary, binary, trinary, etc. to n objects). This class serves
as code-factorization for objects which must hold pointers/references to <code class="docutils literal notranslate"><span class="pre">N</span></code>
objects of type <code class="docutils literal notranslate"><span class="pre">T</span></code>. We have opted to specify <code class="docutils literal notranslate"><span class="pre">N</span></code> statically since it is
almost always known ahead of time. While <code class="docutils literal notranslate"><span class="pre">N==1</span></code> and <code class="docutils literal notranslate"><span class="pre">N==2</span></code> scenarios are
most common, we can envision optimizations which may be enabled by having
higher values of <code class="docutils literal notranslate"><span class="pre">N</span></code> (for example triple products).</p>
</section>
<section id="unary">
<h3>Unary<a class="headerlink" href="#unary" title="Link to this heading"></a></h3>
<p>Most of the tensor algebra falling under the <a class="reference internal" href="#ec-non-einstein-math"><span class="std std-ref">non-Einstein math</span></a>
consideration involves operations on a single object.</p>
<ul class="simple">
<li><p>For taking slices/chips of the object we respectively have the <code class="docutils literal notranslate"><span class="pre">Slice&lt;T&gt;</span></code>/
<code class="docutils literal notranslate"><span class="pre">Chip&lt;T&gt;</span></code> classes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Permuation&lt;T&gt;</span></code> represents permutations of the modes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EigenVectors&lt;T&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">EigenValues&lt;T&gt;</span></code> respectively represent the
eigenvectors and eigenvalues resulting from an eigen decomposition.</p></li>
<li><p>Similarly, <code class="docutils literal notranslate"><span class="pre">CholeskyVectors&lt;T&gt;</span></code> represents the Cholesky vectors resulting
from a Cholesky decomposition.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Scale&lt;T&gt;</span></code> scales an <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> by a constant.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pow&lt;T&gt;</span></code> represents taking a matrix power (could template on the power too
since I think it’s usually known at compile time also).</p></li>
</ul>
<p>The last unary class is <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> which is a bit of a special class. Given
a series of objects of type <code class="docutils literal notranslate"><span class="pre">T</span></code>, the objects are promoted to the
expression layer by annotating the modes (providing string labels). The object
which results from annotating the modes is an instance of <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code>. The
reason this class is special is that the only way to get back to objects of type
<code class="docutils literal notranslate"><span class="pre">T</span></code>, <em>i.e.</em>, to leave the expression layer is by assigning an
<code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> object to an <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> object.</p>
</section>
<section id="binary">
<h3>Binary<a class="headerlink" href="#binary" title="Link to this heading"></a></h3>
<p>Members of the binary series of classes involve combining two objects. Most
tensor algebra which can be expressed using generalized Einstein summation
convention (consideration <a class="reference internal" href="#ec-generalized-einstein-notation"><span class="std std-ref">generalized Einstein notation</span></a>) falls under
this category.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Addition&lt;T&gt;</span></code> results from adding two <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> objects together.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Subtraction&lt;T&gt;</span></code> results from subtracting two <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> objects.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Multiplication&lt;T&gt;</span></code> results from multiplying two <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Division&lt;T&gt;</span></code> results from dividing two <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AssignTo&lt;T&gt;</span></code> results from assigning an <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> to an
<code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> object. These objects are only ever created for generating
nodes of the <a class="reference internal" href="../../background/terminology.html#term-ast"><span class="std std-ref">abstract syntax tree (AST)</span></a>.</p></li>
</ul>
</section>
</section>
<section id="user-api">
<span id="expression-user-api"></span><h2>User API<a class="headerlink" href="#user-api" title="Link to this heading"></a></h2>
<p>This section focuses on what the user actually writes. The next section looks
at how the DSL works in more detail, by filling in the blanks regarding the
many unnamed temporary objects these code snippets hide.</p>
<section id="construction">
<h3>Construction<a class="headerlink" href="#construction" title="Link to this heading"></a></h3>
<p>Most tensor operations will look like tensor math written using the generalized
Einstein summation convention. Some examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fill_in_a_and_b</span><span class="p">();</span>
<span class="n">T</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w"> </span><span class="c1">// No &quot;f&quot; to make connection to the example API section</span>

<span class="n">c</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="n">d</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="n">e</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="n">g</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Since these lines all involve unnamed temporary intermediates, each line must
be treated as a separate expression, <em>i.e.</em>, there is no way to preserve the
lifetime of the intermediates from one line to another. Hence, in order to
satisfy <a class="reference internal" href="#ec-reusable-intermediates"><span class="std std-ref">reusable intermediates</span></a>, we require that the user assigns at
least one of the common intermediates (recall an intermediate is as simple as
<code class="docutils literal notranslate"><span class="pre">a(&quot;i,j,k&quot;)</span></code>) to a named variable, <em>e.g.</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">aijk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">c</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">aijk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">d</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">aijk</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In practice the way this will work is that the <code class="docutils literal notranslate"><span class="pre">Buffer</span></code> objects actually
assigned to <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> are <code class="docutils literal notranslate"><span class="pre">FutureBuffer</span></code> objects (see
<a class="reference internal" href="buffer.html#tw-designing-the-buffer"><span class="std std-ref">Designing the Buffer</span></a>). The <code class="docutils literal notranslate"><span class="pre">FutureBuffer</span></code> objects will be tied to
the lifetime of the expression layer which generated them. When all expression-
layer objects involved in creating the <code class="docutils literal notranslate"><span class="pre">FutureBuffer</span></code> objects go out of scope
evaluation begins. So if we want to ensure that the above two equations are
treated as a set of equations, and not two individual equations, we need to make
sure at least one of the expression-layer objects is present in each equation
(the <code class="docutils literal notranslate"><span class="pre">{}</span></code> are needed to establish a scope for <code class="docutils literal notranslate"><span class="pre">aijk</span></code>, ensuring it goes out
scope after the second equation).</p>
<p>While it is theoretically possible for TensorWrapper to correctly identify the
two temporary objects in the previous code block that result from <code class="docutils literal notranslate"><span class="pre">b(&quot;i,j,k&quot;)</span></code>
as identical, it is unlikely that TensorWrapper will contain such optimizations
in the near future. Hence best practice will be to assign each common
intermediate to a named variable, <em>i.e.</em>, the above code block should really be
written as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">aijk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">bijk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">c</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">aijk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bijk</span><span class="p">;</span>
<span class="w">   </span><span class="n">d</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">aijk</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bijk</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>so that the expression layer will identify <code class="docutils literal notranslate"><span class="pre">b(&quot;i,j,k&quot;)</span></code> as evaluating to the
same intermediate.</p>
</section>
<section id="non-einstein-algebra">
<h3>Non-Einstein Algebra<a class="headerlink" href="#non-einstein-algebra" title="Link to this heading"></a></h3>
<p>In order to perform operations which involve tensor algebra that can not be
expressed using generalized Einstein summation convention, we still require
the user to annotate the modes of the tensor (this is so we can generate and
track an CST). Proposed user APIs are:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Lt</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">λ</span><span class="p">,</span><span class="w"> </span><span class="n">a10_10</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">;</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">Aij</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="s">&quot;i,j&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// disclaimer, I&#39;m not 100% sure the cholesky/eigen_solve APIs will work</span>
<span class="w">    </span><span class="c1">// as shown, but it should be possible to get something close.</span>

<span class="w">    </span><span class="c1">// A = LLt</span>
<span class="w">    </span><span class="n">L</span><span class="p">(</span><span class="s">&quot;i,j&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cholesky</span><span class="p">(</span><span class="n">Aij</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Av = λBv (no argument needed if B is 1)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="s">&quot;i,j&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">λ</span><span class="p">(</span><span class="s">&quot;j&quot;</span><span class="p">)]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">eigen_solve</span><span class="p">(</span><span class="n">Aij</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="s">&quot;i,j&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// Get the  slice of A starting a 0,0 and extending to 10,10 exclusive.</span>
<span class="w">    </span><span class="n">a10_10</span><span class="p">(</span><span class="s">&quot;i,j&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">(</span><span class="n">Aij</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">});</span>

<span class="w">    </span><span class="c1">// Raise A to the power 2</span>
<span class="w">    </span><span class="n">a2</span><span class="p">(</span><span class="s">&quot;i,j&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">Aij</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code actually would create one set of expressions since <code class="docutils literal notranslate"><span class="pre">Aij</span></code> is
used in all of the expressions.</p>
</section>
<section id="sparse-maps">
<h3>Sparse Maps<a class="headerlink" href="#sparse-maps" title="Link to this heading"></a></h3>
<p>Each element of a particular set of expressions will necessarily have access to
the same graph. The user should thus be able to set the sparse maps through
any element of the expression layer, <em>e.g.</em>,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">{</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">Lij</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_sparse_map_from_mode_i_to_mode_j</span><span class="p">();</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">Lik</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">get_sparse_map_from_mode_i_to_mode_k</span><span class="p">();</span>

<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">aijk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">bijk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="n">c</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">aijk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bijk</span><span class="p">;</span>
<span class="w">   </span><span class="n">d</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">aijk</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bijk</span><span class="p">;</span>
<span class="w">   </span><span class="n">aijk</span><span class="p">.</span><span class="n">set_sparse_map</span><span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;j&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Lij</span><span class="p">);</span>
<span class="w">   </span><span class="n">aijk</span><span class="p">.</span><span class="n">set_sparse_map</span><span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;k&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Lik</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above registers two sparse maps: one which for a given offset along modes
labeled with <code class="docutils literal notranslate"><span class="pre">&quot;i&quot;</span></code> gives non-zero offsets along modes labeled with <code class="docutils literal notranslate"><span class="pre">j&quot;</span></code> and
a similar sparse map for modes labeled with <code class="docutils literal notranslate"><span class="pre">&quot;i&quot;</span></code> to modes labeled with
<code class="docutils literal notranslate"><span class="pre">&quot;k&quot;</span></code>. Note that for this API to work the user MUST use indices consistently,
which is to say <code class="docutils literal notranslate"><span class="pre">i&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;j&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&quot;k&quot;</span></code> must be indexing the same modes
each time they appear.</p>
</section>
</section>
<section id="example-api">
<h2>Example API<a class="headerlink" href="#example-api" title="Link to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The examples in this section purposely use the real types from the expression
layer. This is NOT what we expect a user to do. What a user sees is shown
later (see <a class="reference internal" href="#expression-user-api"><span class="std std-ref">User API</span></a>).</p>
</div>
<p>The expression layer works basically the same for every composable object of
type <code class="docutils literal notranslate"><span class="pre">T</span></code> (<code class="docutils literal notranslate"><span class="pre">T</span></code> being things like <code class="docutils literal notranslate"><span class="pre">Shape</span></code>, <code class="docutils literal notranslate"><span class="pre">Symmetry</span></code>, <code class="docutils literal notranslate"><span class="pre">TensorWrapper</span></code>)
so we avoid specifying the value of <code class="docutils literal notranslate"><span class="pre">T</span></code>. The APIs shown in this section are
more to flesh out how the unnamed temporaries actually interact.</p>
<section id="expression-construction">
<span id="id2"></span><h3>Construction<a class="headerlink" href="#expression-construction" title="Link to this heading"></a></h3>
<p>Following from the <a class="reference internal" href="#ec-generalized-einstein-notation"><span class="std std-ref">generalized Einstein notation</span></a> consideration we
expect that most users will enter into the expression layer by adding dummy
indices to an object. This looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume we have some T objects</span>
<span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w"> </span><span class="c1">// No f b/c variable would be &quot;if&quot;</span>

<span class="n">Indexed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ia</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="n">Indexed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="n">Indexed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="n">Indexed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="n">Indexed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
<span class="n">Indexed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="s">&quot;i,j,k&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> objects will then be composed pair-wise to form
<code class="docutils literal notranslate"><span class="pre">BinaryExpression&lt;T&gt;</span></code> objects.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// continues from last code block</span>
<span class="n">Addition</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iapib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ia</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ib</span><span class="p">;</span>
<span class="n">Multiplication</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iatib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ia</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ib</span><span class="p">;</span>
<span class="n">Subtraction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iasib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ia</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ib</span><span class="p">;</span>
<span class="n">Division</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iadib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ia</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">ib</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that unlike traditional expression templates which would end up with
types like <code class="docutils literal notranslate"><span class="pre">Addition&lt;Indexed&lt;T&gt;,</span> <span class="pre">Indexed&lt;T&gt;&gt;</span></code> we rely on the fact
the all of the pieces derive from <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code>, which helps us address
consideration <a class="reference internal" href="#ec-template-meta-programming-cost"><span class="std std-ref">template meta-programming cost</span></a>.</p>
<p>Once we have built up terms they get assigned to an <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> object like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// continues from last two code blocks</span>

<span class="n">ic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iapib</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assigns results of addition to C</span>
<span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iatib</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assigns results of multiplication to C</span>
<span class="n">ie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iasib</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assigns results of subtraction to C</span>
<span class="n">ig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadib</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assigns results of division to C</span>
</pre></div>
</div>
<p>It is worth noting, that it is somewhat trivial to satisfy consideration
<a class="reference internal" href="#ec-reusable-intermediates"><span class="std std-ref">reusable intermediates</span></a> when interacting with the expression layer
directly. This is because each expression object is actually a node in the
<a class="reference internal" href="../../background/terminology.html#term-cst"><span class="std std-ref">concrete syntax tree (CST)</span></a>, so by reusing the literal nodes we reuse the intermediates.</p>
<p>From this we can see that <code class="docutils literal notranslate"><span class="pre">c(&quot;i,j&quot;)</span> <span class="pre">=</span> <span class="pre">a(&quot;i,j&quot;)</span> <span class="pre">+</span> <span class="pre">b(&quot;i,j&quot;);</span></code> actually works
by:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a(&quot;i,j,k&quot;)</span></code> creates an unnamed temporary <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> object,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b(&quot;i,j,k&quot;)</span></code> creates  another unnamed temporary <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> object,</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;::operator+</span></code> method is then called on the previous two
temporary objects resulting in a third temporary of type <code class="docutils literal notranslate"><span class="pre">Addition&lt;T&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c(&quot;i,j,k&quot;)</span></code> creates yet another temporary <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;</span></code> object.</p></li>
<li><p>Finally <code class="docutils literal notranslate"><span class="pre">Indexed&lt;T&gt;::operator=</span></code> is called assigning the <code class="docutils literal notranslate"><span class="pre">Addition&lt;T&gt;</span></code>
object to the the temporary resulting from <code class="docutils literal notranslate"><span class="pre">c(&quot;i,j,k&quot;)</span></code>.</p></li>
</ul>
</section>
<section id="id3">
<h3>Non-Einstein Algebra<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>The previous section showed how to write tensor algebra for operations which can
be expressed using generalized Einstein summation convention. Consideration
<a class="reference internal" href="#ec-non-einstein-math"><span class="std std-ref">non-Einstein math</span></a> means that the expression layer must be able to
support other tensor algebra operations as well. In terms of expression-layer
objects:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_filled_matrices</span><span class="p">();</span>
<span class="n">T</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Lt</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">λ</span><span class="p">,</span><span class="w"> </span><span class="n">a10_10</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">;</span>

<span class="c1">// A = LLt</span>
<span class="n">CholeskyVectors</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cholesky</span><span class="p">(</span><span class="n">Aij</span><span class="p">);</span>

<span class="c1">// Av = λBv (argument only needed for generalized eigen_solves)</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">EigenVectors</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">EigenValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">vλ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Aij</span><span class="p">.</span><span class="n">eigen_solve</span><span class="p">(</span><span class="n">Bij</span><span class="p">);</span>

<span class="c1">// Get the  slice of A starting a 0,0 and extending to 10,10 exclusive.</span>
<span class="n">Slice</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a10_10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">(</span><span class="n">Aij</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">});</span>

<span class="c1">// Raise A to the power 2</span>
<span class="n">Pow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">Aij</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>The trick to satisfying <a class="reference internal" href="#ec-non-einstein-math"><span class="std std-ref">non-Einstein math</span></a> consideration is that we
require the various operations to involve tensors which are already wrapped in
expression-layer constructs. While this is a bit more verbose, it also allows
us to, in some cases (like the <code class="docutils literal notranslate"><span class="pre">slice</span></code> operation), support transposing the
result.</p>
</section>
<section id="obtaining-an-opgraph">
<h3>Obtaining an OpGraph<a class="headerlink" href="#obtaining-an-opgraph" title="Link to this heading"></a></h3>
<p>The trick to avoid the nasty nested expression templates is to obtain the final
<code class="docutils literal notranslate"><span class="pre">OpGraph</span></code> object via the base class’s <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> API. This can be
done via the visitor pattern and looks something like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// In practice e would be a pointer b/c Expression is an abstract base class</span>
<span class="n">Expression</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_expression</span><span class="p">();</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">add_to_graph</span><span class="p">(</span><span class="n">OpGraph</span><span class="p">{});</span>
</pre></div>
</div>
<p>Then internally the <code class="docutils literal notranslate"><span class="pre">add_to_graph</span></code> method of the most derived class,
<code class="docutils literal notranslate"><span class="pre">Derived&lt;T&gt;</span></code>, is implemented something like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">OpGraph</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Derived</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">add_to_graph</span><span class="p">(</span><span class="n">OpGraph</span><span class="w"> </span><span class="n">g</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// Assume Derived&lt;T&gt; inherits from Base&lt;T&gt;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">subgraph</span><span class="p">,</span><span class="w"> </span><span class="n">parent_node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">add_to_graph</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Create node corresponding to Derived&lt;T&gt; add to parent_node</span>

<span class="w">    </span><span class="c1">// Return new graph and new node</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works because <code class="docutils literal notranslate"><span class="pre">Expression&lt;T&gt;</span></code> defines a virtual function
<code class="docutils literal notranslate"><span class="pre">std::pair&lt;OpGraph,</span> <span class="pre">Node&gt;</span> <span class="pre">add_to_graph(OpGraph</span> <span class="pre">g)</span></code> which is overridden by each
of the derived classes. Each derived class calls the base class’s
<code class="docutils literal notranslate"><span class="pre">add_to_graph</span></code> method, which in turn returns the graph and the node just
added. Exactly what the nodes look like, and what information they contain is
punted to the OpGraph component (see <a class="reference internal" href="op_graph.html#tw-designing-the-opgraph"><span class="std std-ref">Designing the OpGraph</span></a>).</p>
</section>
</section>
<section id="understanding-the-linked-state">
<span id="ec-understanding-the-linked-state"></span><h2>Understanding the Linked State<a class="headerlink" href="#understanding-the-linked-state" title="Link to this heading"></a></h2>
<p>Pursuant to the <a class="reference internal" href="#ec-linked"><span class="std std-ref">linked</span></a> consideration, expression component objects
belong to the same set of expressions must share a common state. The purpose of
this section will be to work out the lifetime semantics and shared behavior of
this state.</p>
<p>TODO: We can punt on this until we’re ready to implement it.</p>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Link to this heading"></a></h2>
<p>The above design satisfies the considerations raised in <a class="reference internal" href="#ec-considerations"><span class="std std-ref">Expression Component Considerations</span></a>
by:</p>
<dl class="simple">
<dt><a class="reference internal" href="#ec-compose-multiple-objects"><span class="std std-ref">compose multiple objects</span></a></dt><dd><p>The entire expression layer is templated on the type of the object being
composed. This allows the expression layer to be reused with various pieces
of the <code class="docutils literal notranslate"><span class="pre">TensorWrapper</span></code> class (<em>e.g.</em>, the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> class) in addition to
the <code class="docutils literal notranslate"><span class="pre">TensorWrapper</span></code> class itself.</p>
</dd>
<dt><a class="reference internal" href="#ec-generalized-einstein-notation"><span class="std std-ref">generalized Einstein notation</span></a></dt><dd><p>The entry pont to the expression layer is, for most operations, is assigning
indices to a tensor’s modes. The resulting objects can then be composed using
generalized Einstein notation.</p>
</dd>
<dt><a class="reference internal" href="#ec-non-einstein-math"><span class="std std-ref">non-Einstein math</span></a></dt><dd><p>Tensor operations which can not be expressed using generalized Einstein
summation convention are supported, but in order to ensure they interact
with the expression layer we still require the tensors to have their modes
annotated.</p>
</dd>
<dt><a class="reference internal" href="#ec-template-meta-programming-cost"><span class="std std-ref">template meta-programming cost</span></a></dt><dd><p>Instead of templating the various pieces of the expression layer on the
types of the sub-expressions, as is usually done, we only template the
expression layer pieces on the types of the object being composed, <em>e.g.</em>,
the template type parameter would be something like <code class="docutils literal notranslate"><span class="pre">Shape</span></code> or
<code class="docutils literal notranslate"><span class="pre">TensorWrapper</span></code> instead of say a type like
<code class="docutils literal notranslate"><span class="pre">Addition&lt;Indexed&lt;Shape&gt;,</span> <span class="pre">Indexed&lt;Shape&gt;&gt;</span></code>.</p>
</dd>
<dt><a class="reference internal" href="#ec-reusable-intermediates"><span class="std std-ref">reusable intermediates</span></a></dt><dd><p>Each object in the expression layer is a node of a CST. Reusing the same
object in multiple places reuses the same node of the CST.</p>
</dd>
<dt><a class="reference internal" href="#ec-sparse-maps"><span class="std std-ref">sparse maps</span></a></dt><dd><p>The objects associated with a particular set of expressions are linked.
Using any of these objects the user can set one or more sparse maps which
will then work out the sparsity for the set of equations.</p>
</dd>
<dt><a class="reference internal" href="#ec-linked"><span class="std std-ref">linked</span></a></dt><dd><p>The linked state of the expression component is described in the
<a class="reference internal" href="#ec-understanding-the-linked-state"><span class="std std-ref">Understanding the Linked State</span></a> section.</p>
</dd>
</dl>
</section>
<section id="other-notes">
<h2>Other Notes<a class="headerlink" href="#other-notes" title="Link to this heading"></a></h2>
<p>At some point we’ll probably need a way of applying arbitrary functions to
slices of one or more tensor. Such an operation could conceivably be built into
the <code class="docutils literal notranslate"><span class="pre">Nary&lt;N,T&gt;</span></code> class and the classes which derive from it</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tensor_wrapper.html" class="btn btn-neutral float-left" title="Designing TensorWrapper Class" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="op_graph.html" class="btn btn-neutral float-right" title="Designing the OpGraph" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, NWChemEx Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>