<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::detail_ Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tensorwrapper<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetensorwrapper.html">tensorwrapper</a></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1detail__.html">detail_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">tensorwrapper::detail_ Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Inline utilities and functions needed to implement the TensorWrapper library, but not considered part of the public API.  
<a href="namespacetensorwrapper_1_1detail__.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html">DSLBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code factorization for objects that are composable via the DSL.  <a href="classtensorwrapper_1_1detail___1_1DSLBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1detail___1_1IsTuple.html">IsTuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1detail___1_1IsTuple_3_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">IsTuple&lt; std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html">PolymorphicBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the API polymorphic utility methods should use.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html">TensorFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object which helps create tensor objects.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html">TensorInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type capable of holding all valid inputs to a <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a>'s ctor.  <a href="structtensorwrapper_1_1detail___1_1TensorInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorPIMPL.html">TensorPIMPL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually implements a <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> object.  <a href="classtensorwrapper_1_1detail___1_1TensorPIMPL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa6e3229f29de6317f20081b187503a29" id="r_aa6e3229f29de6317f20081b187503a29"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">FromType</a> , <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">ToType</a> &gt; </td></tr>
<tr class="memitem:aa6e3229f29de6317f20081b187503a29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#aa6e3229f29de6317f20081b187503a29">enable_if_mutable_to_immutable_cast_t</a> = std::enable_if_t&lt; <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6a23574a75f8ab1de5e8f854c7263e03">is_mutable_to_immutable_cast_v</a>&lt; <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">FromType</a>, <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">ToType</a> &gt; &gt;</td></tr>
<tr class="memdesc:aa6e3229f29de6317f20081b187503a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables a templated function except when <code>is_mutable_to_immutable_cast_v&lt;FromType, ToType&gt;</code> evaluates to true.  <br /></td></tr>
<tr class="separator:aa6e3229f29de6317f20081b187503a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33414c915fc33f0eabe804641f40abc7" id="r_a33414c915fc33f0eabe804641f40abc7"><td class="memItemLeft" align="right" valign="top"><a id="a33414c915fc33f0eabe804641f40abc7" name="a33414c915fc33f0eabe804641f40abc7"></a>
<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pimpl_type</b> = <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a5106718edcce3b88a13ccbecf247aae6">TensorFactory::pimpl_type</a></td></tr>
<tr class="separator:a33414c915fc33f0eabe804641f40abc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec464ec277def0e4c088df8224e6bf3" id="r_adec464ec277def0e4c088df8224e6bf3"><td class="memItemLeft" align="right" valign="top"><a id="adec464ec277def0e4c088df8224e6bf3" name="adec464ec277def0e4c088df8224e6bf3"></a>
<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pimpl_pointer</b> = <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">TensorFactory::pimpl_pointer</a></td></tr>
<tr class="separator:adec464ec277def0e4c088df8224e6bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f468d45674d20e816081a4cbd624e3" id="r_a10f468d45674d20e816081a4cbd624e3"><td class="memItemLeft" align="right" valign="top"><a id="a10f468d45674d20e816081a4cbd624e3" name="a10f468d45674d20e816081a4cbd624e3"></a>
<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>symmetry_pointer</b> = <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> TensorFactory::symmetry_pointer</td></tr>
<tr class="separator:a10f468d45674d20e816081a4cbd624e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d4a5bde8bf6e84f48bbb54a1a2f56c" id="r_a34d4a5bde8bf6e84f48bbb54a1a2f56c"><td class="memItemLeft" align="right" valign="top"><a id="a34d4a5bde8bf6e84f48bbb54a1a2f56c" name="a34d4a5bde8bf6e84f48bbb54a1a2f56c"></a>
<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparsity_pointer</b> = <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> TensorFactory::sparsity_pointer</td></tr>
<tr class="separator:a34d4a5bde8bf6e84f48bbb54a1a2f56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17ab7b781ab9bbf0f3a64dd9b80dbe" id="r_a5e17ab7b781ab9bbf0f3a64dd9b80dbe"><td class="memItemLeft" align="right" valign="top"><a id="a5e17ab7b781ab9bbf0f3a64dd9b80dbe" name="a5e17ab7b781ab9bbf0f3a64dd9b80dbe"></a>
<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>logical_layout_pointer</b> = <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> TensorFactory::logical_layout_pointer</td></tr>
<tr class="separator:a5e17ab7b781ab9bbf0f3a64dd9b80dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411a64b911136b3fd47796df365ff9a2" id="r_a411a64b911136b3fd47796df365ff9a2"><td class="memItemLeft" align="right" valign="top"><a id="a411a64b911136b3fd47796df365ff9a2" name="a411a64b911136b3fd47796df365ff9a2"></a>
<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>physical_layout_pointer</b> = <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> TensorFactory::physical_layout_pointer</td></tr>
<tr class="separator:a411a64b911136b3fd47796df365ff9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160183b50c0d90bdb785d3b455aca4fb" id="r_a160183b50c0d90bdb785d3b455aca4fb"><td class="memItemLeft" align="right" valign="top"><a id="a160183b50c0d90bdb785d3b455aca4fb" name="a160183b50c0d90bdb785d3b455aca4fb"></a>
<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_pointer</b> = <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> TensorFactory::allocator_pointer</td></tr>
<tr class="separator:a160183b50c0d90bdb785d3b455aca4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0b835f5008baee1507a46a50f30dba" id="r_aaf0b835f5008baee1507a46a50f30dba"><td class="memItemLeft" align="right" valign="top"><a id="aaf0b835f5008baee1507a46a50f30dba" name="aaf0b835f5008baee1507a46a50f30dba"></a>
<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_pointer</b> = <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> pimpl_type::buffer_pointer</td></tr>
<tr class="separator:aaf0b835f5008baee1507a46a50f30dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac855ff18febb3b935cbec3e5f8a03956" id="r_ac855ff18febb3b935cbec3e5f8a03956"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; </td></tr>
<tr class="memitem:ac855ff18febb3b935cbec3e5f8a03956"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#ac855ff18febb3b935cbec3e5f8a03956">to_size_t</a> (<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">i</a>)</td></tr>
<tr class="memdesc:ac855ff18febb3b935cbec3e5f8a03956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely converts objects to std::size_t.  <br /></td></tr>
<tr class="separator:ac855ff18febb3b935cbec3e5f8a03956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bbd1db3b673870005d71c46e10e83f" id="r_af1bbd1db3b673870005d71c46e10e83f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; </td></tr>
<tr class="memitem:af1bbd1db3b673870005d71c46e10e83f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">long</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#af1bbd1db3b673870005d71c46e10e83f">to_long</a> (<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">i</a>)</td></tr>
<tr class="memdesc:af1bbd1db3b673870005d71c46e10e83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely converts integral objects to long.  <br /></td></tr>
<tr class="separator:af1bbd1db3b673870005d71c46e10e83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac5af5ae4ff7ab422c315c1ec222354" id="r_a5ac5af5ae4ff7ab422c315c1ec222354"><td class="memTemplParams" colspan="2"><a id="a5ac5af5ae4ff7ab422c315c1ec222354" name="a5ac5af5ae4ff7ab422c315c1ec222354"></a>
template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; </td></tr>
<tr class="memitem:a5ac5af5ae4ff7ab422c315c1ec222354"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">os</a>, <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">const</a> <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html">PolymorphicBase</a>&lt; <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; &amp;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">b</a>)</td></tr>
<tr class="memdesc:a5ac5af5ae4ff7ab422c315c1ec222354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements printing via ostream for objects deriving from <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html" title="Defines the API polymorphic utility methods should use.">PolymorphicBase</a>. <br /></td></tr>
<tr class="separator:a5ac5af5ae4ff7ab422c315c1ec222354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6623145bb04759b7e2da710ad443b0bc" id="r_a6623145bb04759b7e2da710ad443b0bc"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a6623145bb04759b7e2da710ad443b0bc"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">static_pointer_cast</a> (std::unique_ptr&lt; T &gt; &amp;pbase)</td></tr>
<tr class="memdesc:a6623145bb04759b7e2da710ad443b0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a static cast of a unique_ptr.  <br /></td></tr>
<tr class="separator:a6623145bb04759b7e2da710ad443b0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120a95c8bf70bf23f77649aeda2b7bfa" id="r_a120a95c8bf70bf23f77649aeda2b7bfa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">U</a> , <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; </td></tr>
<tr class="memitem:a120a95c8bf70bf23f77649aeda2b7bfa"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">U</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a120a95c8bf70bf23f77649aeda2b7bfa">dynamic_pointer_cast</a> (std::unique_ptr&lt; <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; &amp;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">pbase</a>)</td></tr>
<tr class="memdesc:a120a95c8bf70bf23f77649aeda2b7bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a dynamic cast of a unique_ptr.  <br /></td></tr>
<tr class="separator:a120a95c8bf70bf23f77649aeda2b7bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6a23574a75f8ab1de5e8f854c7263e03" id="r_a6a23574a75f8ab1de5e8f854c7263e03"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">FromType</a> , <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">ToType</a> &gt; </td></tr>
<tr class="memitem:a6a23574a75f8ab1de5e8f854c7263e03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">constexpr</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6a23574a75f8ab1de5e8f854c7263e03">is_mutable_to_immutable_cast_v</a></td></tr>
<tr class="memdesc:a6a23574a75f8ab1de5e8f854c7263e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the cast from <code>FromType</code> to <code>ToType</code> just adding const?  <br /></td></tr>
<tr class="separator:a6a23574a75f8ab1de5e8f854c7263e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Inline utilities and functions needed to implement the TensorWrapper library, but not considered part of the public API. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aa6e3229f29de6317f20081b187503a29" name="aa6e3229f29de6317f20081b187503a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e3229f29de6317f20081b187503a29">&#9670;&#160;</a></span>enable_if_mutable_to_immutable_cast_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">FromType</a> , <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">ToType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">using</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#aa6e3229f29de6317f20081b187503a29">tensorwrapper::detail_::enable_if_mutable_to_immutable_cast_t</a> = <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typedef</a> std::enable_if_t&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6a23574a75f8ab1de5e8f854c7263e03">is_mutable_to_immutable_cast_v</a>&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">FromType</a>, <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">ToType</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables a templated function except when <code>is_mutable_to_immutable_cast_v&lt;FromType, ToType&gt;</code> evaluates to true. </p>
<p>If <code>View</code> is a template class with template parameter type <code>T</code>, we want the implicit conversion from <code>View&lt;T&gt;</code> to <code>View&lt;const T&gt;</code> to exist. In practice, this leaves us with two options: partial specialization of <code>View</code> for const-qualified types or use of SFINAE to disable the conversion. We prefer the latter as the former requires us to duplicate the entirety of the class. This template type will disable the accompanying function via SFINAE if <code>ToType</code> is not <code>const FromType</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FromType</td><td>The type we are converting from. Expected to be the template type parameter of the view we are casting from. </td></tr>
    <tr><td class="paramname">ToType</td><td>The type we are converting to. Expected to be the template type parameter of the view we are casting to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a120a95c8bf70bf23f77649aeda2b7bfa" name="a120a95c8bf70bf23f77649aeda2b7bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120a95c8bf70bf23f77649aeda2b7bfa">&#9670;&#160;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">U</a> , <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">U</a> &gt; tensorwrapper::detail_::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pbase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a dynamic cast of a unique_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The object type to cast from. </td></tr>
    <tr><td class="paramname">U</td><td>The object type to cast to.</td></tr>
  </table>
  </dd>
</dl>
<p>The C++ standard library does not implement dynamic cast for unique pointers (because there is no way to do this without two variables thinking they own the memory). This function implements dynamic cast by essentially swapping the raw pointers in two unique pointers (one of which is a nullptr) when the object pointed to by <code>pbase</code> can be dynamically casted to <code>U</code>. This minimizes the time when the single owner violation occurs (and encapsulates it to this function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbase</td><td>The pointer we are dynamic casting. If the cast succeeds <code>pbase</code> will be set to the nullptr. If the cast fails <code>pbase</code> will be unchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the cast succeeds a new <code>std::unique_ptr&lt;U&gt;</code> object which owns the dynamic casted memory originally owned by <code>pbase</code>. Otherwise a nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6623145bb04759b7e2da710ad443b0bc" name="a6623145bb04759b7e2da710ad443b0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6623145bb04759b7e2da710ad443b0bc">&#9670;&#160;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; U &gt; tensorwrapper::detail_::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pbase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a static cast of a unique_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The object type to cast from. </td></tr>
    <tr><td class="paramname">U</td><td>The object type to cast to.</td></tr>
  </table>
  </dd>
</dl>
<p>The C++ standard library does not implement static cast for unique pointers (because there is no way to do this without two variables thinking they own the memory). This function implements static cast by essentially swapping the raw pointers in two unique pointers (one of which is a nullptr). This minimizes the time when the single owner violation occurs (and encapsulates it to this function).</p>
<dl class="section note"><dt>Note</dt><dd>This method will fail to compile if T can not be converted to U.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbase</td><td>The pointer we are static casting from. After this call <code>pbase</code> will set to the nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <code>std::unique_ptr&lt;U&gt;</code> object which owns the memory originally owned by <code>pbase</code>, but now viewed as being a <code>U</code> object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1bbd1db3b673870005d71c46e10e83f" name="af1bbd1db3b673870005d71c46e10e83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bbd1db3b673870005d71c46e10e83f">&#9670;&#160;</a></span>to_long()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">long</a> tensorwrapper::detail_::to_long </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely converts integral objects to long. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type of <code>i</code>. Must be an integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The integer we are converting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See the note on to_size_t for details on bounds checking.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>i</code> cast to a <code>long</code>. </dd></dl>

</div>
</div>
<a id="ac855ff18febb3b935cbec3e5f8a03956" name="ac855ff18febb3b935cbec3e5f8a03956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac855ff18febb3b935cbec3e5f8a03956">&#9670;&#160;</a></span>to_size_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tensorwrapper::detail_::to_size_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">T</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely converts objects to std::size_t. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>integral type of the input.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will ensure at compile time that </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is an integral type and will assert that it is greater than equal to 0 at runtime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>assert is used, instead of throw, so that the overhead for the checks can be disabled in Release mode. Given that this function is used in the getting/setting of tensor elements by offsets, its overhead could conceivably add up.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The integer to convert to <code>std::size_t</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>i</code> cast to a <code>std::size_t</code> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6a23574a75f8ab1de5e8f854c7263e03" name="a6a23574a75f8ab1de5e8f854c7263e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a23574a75f8ab1de5e8f854c7263e03">&#9670;&#160;</a></span>is_mutable_to_immutable_cast_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">FromType</a> , <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">typename</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">ToType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">constexpr</a> <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6623145bb04759b7e2da710ad443b0bc">bool</a> tensorwrapper::detail_::is_mutable_to_immutable_cast_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  !std::is_const_v&lt;FromType&gt; &amp;&amp;           </div>
<div class="line">  std::is_const_v&lt;ToType&gt; &amp;&amp;              </div>
<div class="line">  std::is_same_v&lt;const FromType, ToType&gt;</div>
</div><!-- fragment -->
<p>Is the cast from <code>FromType</code> to <code>ToType</code> just adding const? </p>
<p>A common TMP pattern in implementing views is needing to convert mutable views to read-only views. This trait can be used to compare the template type parameters of two views (assuming the views are templated on what object they are acting like) in order to determine if they represent a conversion from <code>FromType</code> to <code>ToType</code> such that <code>ToType</code> is <code>const FromType</code>. If <code>ToType</code> is <code>const FromType</code> this template variable will be set to true, otherwise it will be set to false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FromType</td><td>The type we are converting from. </td></tr>
    <tr><td class="paramname">ToType</td><td>The type we are converting to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
