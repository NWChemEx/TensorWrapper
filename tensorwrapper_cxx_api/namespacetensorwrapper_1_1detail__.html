<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::detail_ Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">0.0.42</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetensorwrapper.html">tensorwrapper</a></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1detail__.html">detail_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::detail_ Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inline utilities and functions needed to implement the TensorWrapper library, but not considered part of the public API.  
<a href="namespacetensorwrapper_1_1detail__.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html">DSLBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code factorization for objects that are composable via the DSL.  <a href="classtensorwrapper_1_1detail___1_1DSLBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html">PolymorphicBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the API polymorphic utility methods should use.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html">TensorInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type capable of holding all valid inputs to a <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a>'s ctor.  <a href="structtensorwrapper_1_1detail___1_1TensorInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1detail___1_1IsTuple.html">IsTuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1detail___1_1IsTuple_3_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">IsTuple&lt; std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html">TensorFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object which helps create tensor objects.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorPIMPL.html">TensorPIMPL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually implements a <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> object.  <a href="classtensorwrapper_1_1detail___1_1TensorPIMPL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa6e3229f29de6317f20081b187503a29"><td class="memTemplParams" colspan="2">template&lt;typename FromType , typename ToType &gt; </td></tr>
<tr class="memitem:aa6e3229f29de6317f20081b187503a29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#aa6e3229f29de6317f20081b187503a29">enable_if_mutable_to_immutable_cast_t</a> = std::enable_if_t&lt; <a class="el" href="namespacetensorwrapper_1_1detail__.html#a6a23574a75f8ab1de5e8f854c7263e03">is_mutable_to_immutable_cast_v</a>&lt; FromType, ToType &gt; &gt;</td></tr>
<tr class="memdesc:aa6e3229f29de6317f20081b187503a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables a templated function except when <code>is_mutable_to_immutable_cast_v&lt;FromType, ToType&gt;</code> evaluates to true.  <a href="namespacetensorwrapper_1_1detail__.html#aa6e3229f29de6317f20081b187503a29">More...</a><br /></td></tr>
<tr class="separator:aa6e3229f29de6317f20081b187503a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33414c915fc33f0eabe804641f40abc7"><td class="memItemLeft" align="right" valign="top"><a id="a33414c915fc33f0eabe804641f40abc7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pimpl_type</b> = typename <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a5106718edcce3b88a13ccbecf247aae6">TensorFactory::pimpl_type</a></td></tr>
<tr class="separator:a33414c915fc33f0eabe804641f40abc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec464ec277def0e4c088df8224e6bf3"><td class="memItemLeft" align="right" valign="top"><a id="adec464ec277def0e4c088df8224e6bf3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pimpl_pointer</b> = typename <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">TensorFactory::pimpl_pointer</a></td></tr>
<tr class="separator:adec464ec277def0e4c088df8224e6bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f468d45674d20e816081a4cbd624e3"><td class="memItemLeft" align="right" valign="top"><a id="a10f468d45674d20e816081a4cbd624e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>symmetry_pointer</b> = typename TensorFactory::symmetry_pointer</td></tr>
<tr class="separator:a10f468d45674d20e816081a4cbd624e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d4a5bde8bf6e84f48bbb54a1a2f56c"><td class="memItemLeft" align="right" valign="top"><a id="a34d4a5bde8bf6e84f48bbb54a1a2f56c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>sparsity_pointer</b> = typename TensorFactory::sparsity_pointer</td></tr>
<tr class="separator:a34d4a5bde8bf6e84f48bbb54a1a2f56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17ab7b781ab9bbf0f3a64dd9b80dbe"><td class="memItemLeft" align="right" valign="top"><a id="a5e17ab7b781ab9bbf0f3a64dd9b80dbe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>logical_layout_pointer</b> = typename TensorFactory::logical_layout_pointer</td></tr>
<tr class="separator:a5e17ab7b781ab9bbf0f3a64dd9b80dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411a64b911136b3fd47796df365ff9a2"><td class="memItemLeft" align="right" valign="top"><a id="a411a64b911136b3fd47796df365ff9a2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>physical_layout_pointer</b> = typename TensorFactory::physical_layout_pointer</td></tr>
<tr class="separator:a411a64b911136b3fd47796df365ff9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160183b50c0d90bdb785d3b455aca4fb"><td class="memItemLeft" align="right" valign="top"><a id="a160183b50c0d90bdb785d3b455aca4fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_pointer</b> = typename TensorFactory::allocator_pointer</td></tr>
<tr class="separator:a160183b50c0d90bdb785d3b455aca4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0b835f5008baee1507a46a50f30dba"><td class="memItemLeft" align="right" valign="top"><a id="aaf0b835f5008baee1507a46a50f30dba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_pointer</b> = typename pimpl_type::buffer_pointer</td></tr>
<tr class="separator:aaf0b835f5008baee1507a46a50f30dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6a52ed52f9381cb54bd6a1d4f9f3548c"><td class="memTemplParams" colspan="2"><a id="a6a52ed52f9381cb54bd6a1d4f9f3548c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a52ed52f9381cb54bd6a1d4f9f3548c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6a52ed52f9381cb54bd6a1d4f9f3548c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html">PolymorphicBase</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a6a52ed52f9381cb54bd6a1d4f9f3548c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements printing via ostream for objects deriving from <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html" title="Defines the API polymorphic utility methods should use.">PolymorphicBase</a>. <br /></td></tr>
<tr class="separator:a6a52ed52f9381cb54bd6a1d4f9f3548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010ea06c04faf4954a04395948b172d3"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a010ea06c04faf4954a04395948b172d3"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a010ea06c04faf4954a04395948b172d3">static_pointer_cast</a> (std::unique_ptr&lt; T &gt; &amp;pbase)</td></tr>
<tr class="memdesc:a010ea06c04faf4954a04395948b172d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a static cast of a unique_ptr.  <a href="namespacetensorwrapper_1_1detail__.html#a010ea06c04faf4954a04395948b172d3">More...</a><br /></td></tr>
<tr class="separator:a010ea06c04faf4954a04395948b172d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410419e18d9fa2a49ad7c7ed4509b317"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a410419e18d9fa2a49ad7c7ed4509b317"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a410419e18d9fa2a49ad7c7ed4509b317">dynamic_pointer_cast</a> (std::unique_ptr&lt; T &gt; &amp;pbase)</td></tr>
<tr class="memdesc:a410419e18d9fa2a49ad7c7ed4509b317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a dynamic cast of a unique_ptr.  <a href="namespacetensorwrapper_1_1detail__.html#a410419e18d9fa2a49ad7c7ed4509b317">More...</a><br /></td></tr>
<tr class="separator:a410419e18d9fa2a49ad7c7ed4509b317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6a23574a75f8ab1de5e8f854c7263e03"><td class="memTemplParams" colspan="2">template&lt;typename FromType , typename ToType &gt; </td></tr>
<tr class="memitem:a6a23574a75f8ab1de5e8f854c7263e03"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a6a23574a75f8ab1de5e8f854c7263e03">is_mutable_to_immutable_cast_v</a></td></tr>
<tr class="memdesc:a6a23574a75f8ab1de5e8f854c7263e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the cast from <code>FromType</code> to <code>ToType</code> just adding const?  <a href="namespacetensorwrapper_1_1detail__.html#a6a23574a75f8ab1de5e8f854c7263e03">More...</a><br /></td></tr>
<tr class="separator:a6a23574a75f8ab1de5e8f854c7263e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Inline utilities and functions needed to implement the TensorWrapper library, but not considered part of the public API. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aa6e3229f29de6317f20081b187503a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e3229f29de6317f20081b187503a29">&#9670;&nbsp;</a></span>enable_if_mutable_to_immutable_cast_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromType , typename ToType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1detail__.html#aa6e3229f29de6317f20081b187503a29">tensorwrapper::detail_::enable_if_mutable_to_immutable_cast_t</a> = typedef std::enable_if_t&lt;<a class="el" href="namespacetensorwrapper_1_1detail__.html#a6a23574a75f8ab1de5e8f854c7263e03">is_mutable_to_immutable_cast_v</a>&lt;FromType, ToType&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables a templated function except when <code>is_mutable_to_immutable_cast_v&lt;FromType, ToType&gt;</code> evaluates to true. </p>
<p>If <code>View</code> is a template class with template parameter type <code>T</code>, we want the implicit conversion from <code>View&lt;T&gt;</code> to <code>View&lt;const T&gt;</code> to exist. In practice, this leaves us with two options: partial specialization of <code>View</code> for const-qualified types or use of SFINAE to disable the conversion. We prefer the latter as the former requires us to duplicate the entirety of the class. This template type will disable the accompanying function via SFINAE if <code>ToType</code> is not <code>const FromType</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FromType</td><td>The type we are converting from. Expected to be the template type parameter of the view we are casting from. </td></tr>
    <tr><td class="paramname">ToType</td><td>The type we are converting to. Expected to be the template type parameter of the view we are casting to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a410419e18d9fa2a49ad7c7ed4509b317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410419e18d9fa2a49ad7c7ed4509b317">&#9670;&nbsp;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;U&gt; tensorwrapper::detail_::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pbase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a dynamic cast of a unique_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The object type to cast from. </td></tr>
    <tr><td class="paramname">U</td><td>The object type to cast to.</td></tr>
  </table>
  </dd>
</dl>
<p>The C++ standard library does not implement dynamic cast for unique pointers (because there is no way to do this without two variables thinking they own the memory). This function implements dynamic cast by essentially swapping the raw pointers in two unique pointers (one of which is a nullptr) when the object pointed to by <code>pbase</code> can be dynamically casted to <code>U</code>. This minimizes the time when the single owner violation occurs (and encapsulates it to this function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbase</td><td>The pointer we are dynamic casting. If the cast succeeds <code>pbase</code> will be set to the nullptr. If the cast fails <code>pbase</code> will be unchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the cast succeeds a new <code>std::unique_ptr&lt;U&gt;</code> object which owns the dynamic casted memory originally owned by <code>pbase</code>. Otherwise a nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a010ea06c04faf4954a04395948b172d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010ea06c04faf4954a04395948b172d3">&#9670;&nbsp;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;U&gt; tensorwrapper::detail_::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pbase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a static cast of a unique_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The object type to cast from. </td></tr>
    <tr><td class="paramname">U</td><td>The object type to cast to.</td></tr>
  </table>
  </dd>
</dl>
<p>The C++ standard library does not implement static cast for unique pointers (because there is no way to do this without two variables thinking they own the memory). This function implements static cast by essentially swapping the raw pointers in two unique pointers (one of which is a nullptr). This minimizes the time when the single owner violation occurs (and encapsulates it to this function).</p>
<dl class="section note"><dt>Note</dt><dd>This method will fail to compile if T can not be converted to U.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbase</td><td>The pointer we are static casting from. After this call <code>pbase</code> will set to the nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <code>std::unique_ptr&lt;U&gt;</code> object which owns the memory originally owned by <code>pbase</code>, but now viewed as being a <code>U</code> object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6a23574a75f8ab1de5e8f854c7263e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a23574a75f8ab1de5e8f854c7263e03">&#9670;&nbsp;</a></span>is_mutable_to_immutable_cast_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromType , typename ToType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tensorwrapper::detail_::is_mutable_to_immutable_cast_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">  !std::is_const_v&lt;FromType&gt; &amp;&amp;           </div>
<div class="line">  std::is_const_v&lt;ToType&gt; &amp;&amp;              </div>
<div class="line">  std::is_same_v&lt;const FromType, ToType&gt;</div>
</div><!-- fragment -->
<p>Is the cast from <code>FromType</code> to <code>ToType</code> just adding const? </p>
<p>A common TMP pattern in implementing views is needing to convert mutable views to read-only views. This trait can be used to compare the template type parameters of two views (assuming the views are templated on what object they are acting like) in order to determine if they represent a conversion from <code>FromType</code> to <code>ToType</code> such that <code>ToType</code> is <code>const FromType</code>. If <code>ToType</code> is <code>const FromType</code> this template variable will be set to true, otherwise it will be set to false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FromType</td><td>The type we are converting from. </td></tr>
    <tr><td class="paramname">ToType</td><td>The type we are converting to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
