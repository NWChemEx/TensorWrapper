<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::detail_ Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">0.0.33</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetensorwrapper.html">tensorwrapper</a></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1detail__.html">detail_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::detail_ Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inline utilities and functions needed to implement the TensorWrapper library, but not considered part of the public API.  
<a href="namespacetensorwrapper_1_1detail__.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html">PolymorphicBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the API polymorphic utility methods should use.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html">TensorInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type capable of holding all valid inputs to a <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a>'s ctor.  <a href="structtensorwrapper_1_1detail___1_1TensorInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html">TensorFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object which helps create tensor objects.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorPIMPL.html">TensorPIMPL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually implements a <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> object.  <a href="classtensorwrapper_1_1detail___1_1TensorPIMPL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a33414c915fc33f0eabe804641f40abc7"><td class="memItemLeft" align="right" valign="top"><a id="a33414c915fc33f0eabe804641f40abc7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pimpl_type</b> = typename <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a5106718edcce3b88a13ccbecf247aae6">TensorFactory::pimpl_type</a></td></tr>
<tr class="separator:a33414c915fc33f0eabe804641f40abc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec464ec277def0e4c088df8224e6bf3"><td class="memItemLeft" align="right" valign="top"><a id="adec464ec277def0e4c088df8224e6bf3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pimpl_pointer</b> = typename <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">TensorFactory::pimpl_pointer</a></td></tr>
<tr class="separator:adec464ec277def0e4c088df8224e6bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f468d45674d20e816081a4cbd624e3"><td class="memItemLeft" align="right" valign="top"><a id="a10f468d45674d20e816081a4cbd624e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>symmetry_pointer</b> = typename TensorFactory::symmetry_pointer</td></tr>
<tr class="separator:a10f468d45674d20e816081a4cbd624e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d4a5bde8bf6e84f48bbb54a1a2f56c"><td class="memItemLeft" align="right" valign="top"><a id="a34d4a5bde8bf6e84f48bbb54a1a2f56c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>sparsity_pointer</b> = typename TensorFactory::sparsity_pointer</td></tr>
<tr class="separator:a34d4a5bde8bf6e84f48bbb54a1a2f56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17ab7b781ab9bbf0f3a64dd9b80dbe"><td class="memItemLeft" align="right" valign="top"><a id="a5e17ab7b781ab9bbf0f3a64dd9b80dbe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>logical_layout_pointer</b> = typename TensorFactory::logical_layout_pointer</td></tr>
<tr class="separator:a5e17ab7b781ab9bbf0f3a64dd9b80dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411a64b911136b3fd47796df365ff9a2"><td class="memItemLeft" align="right" valign="top"><a id="a411a64b911136b3fd47796df365ff9a2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>physical_layout_pointer</b> = typename TensorFactory::physical_layout_pointer</td></tr>
<tr class="separator:a411a64b911136b3fd47796df365ff9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160183b50c0d90bdb785d3b455aca4fb"><td class="memItemLeft" align="right" valign="top"><a id="a160183b50c0d90bdb785d3b455aca4fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_pointer</b> = typename TensorFactory::allocator_pointer</td></tr>
<tr class="separator:a160183b50c0d90bdb785d3b455aca4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0b835f5008baee1507a46a50f30dba"><td class="memItemLeft" align="right" valign="top"><a id="aaf0b835f5008baee1507a46a50f30dba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_pointer</b> = typename pimpl_type::buffer_pointer</td></tr>
<tr class="separator:aaf0b835f5008baee1507a46a50f30dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a010ea06c04faf4954a04395948b172d3"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a010ea06c04faf4954a04395948b172d3"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a010ea06c04faf4954a04395948b172d3">static_pointer_cast</a> (std::unique_ptr&lt; T &gt; &amp;pbase)</td></tr>
<tr class="memdesc:a010ea06c04faf4954a04395948b172d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a static cast of a unique_ptr.  <a href="namespacetensorwrapper_1_1detail__.html#a010ea06c04faf4954a04395948b172d3">More...</a><br /></td></tr>
<tr class="separator:a010ea06c04faf4954a04395948b172d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410419e18d9fa2a49ad7c7ed4509b317"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a410419e18d9fa2a49ad7c7ed4509b317"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1detail__.html#a410419e18d9fa2a49ad7c7ed4509b317">dynamic_pointer_cast</a> (std::unique_ptr&lt; T &gt; &amp;pbase)</td></tr>
<tr class="memdesc:a410419e18d9fa2a49ad7c7ed4509b317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a dynamic cast of a unique_ptr.  <a href="namespacetensorwrapper_1_1detail__.html#a410419e18d9fa2a49ad7c7ed4509b317">More...</a><br /></td></tr>
<tr class="separator:a410419e18d9fa2a49ad7c7ed4509b317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Inline utilities and functions needed to implement the TensorWrapper library, but not considered part of the public API. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a410419e18d9fa2a49ad7c7ed4509b317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410419e18d9fa2a49ad7c7ed4509b317">&#9670;&nbsp;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;U&gt; tensorwrapper::detail_::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pbase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a dynamic cast of a unique_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The object type to cast from. </td></tr>
    <tr><td class="paramname">U</td><td>The object type to cast to.</td></tr>
  </table>
  </dd>
</dl>
<p>The C++ standard library does not implement dynamic cast for unique pointers (because there is no way to do this without two variables thinking they own the memory). This function implements dynamic cast by essentially swapping the raw pointers in two unique pointers (one of which is a nullptr) when the object pointed to by <code>pbase</code> can be dynamically casted to <code>U</code>. This minimizes the time when the single owner violation occurs (and encapsulates it to this function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbase</td><td>The pointer we are dynamic casting. If the cast succeeds <code>pbase</code> will be set to the nullptr. If the cast fails <code>pbase</code> will be unchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the cast succeeds a new <code>std::unique_ptr&lt;U&gt;</code> object which owns the dynamic casted memory originally owned by <code>pbase</code>. Otherwise a nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a010ea06c04faf4954a04395948b172d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010ea06c04faf4954a04395948b172d3">&#9670;&nbsp;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;U&gt; tensorwrapper::detail_::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pbase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a static cast of a unique_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The object type to cast from. </td></tr>
    <tr><td class="paramname">U</td><td>The object type to cast to.</td></tr>
  </table>
  </dd>
</dl>
<p>The C++ standard library does not implement static cast for unique pointers (because there is no way to do this without two variables thinking they own the memory). This function implements static cast by essentially swapping the raw pointers in two unique pointers (one of which is a nullptr). This minimizes the time when the single owner violation occurs (and encapsulates it to this function).</p>
<dl class="section note"><dt>Note</dt><dd>This method will fail to compile if T can not be converted to U.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pbase</td><td>The pointer we are static casting from. After this call <code>pbase</code> will set to the nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <code>std::unique_ptr&lt;U&gt;</code> object which owns the memory originally owned by <code>pbase</code>, but now viewed as being a <code>U</code> object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
