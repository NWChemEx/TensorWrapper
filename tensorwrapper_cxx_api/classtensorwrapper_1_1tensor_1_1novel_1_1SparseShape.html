<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::tensor::novel::SparseShape&lt; FieldType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorwrapper</b></li><li class="navelem"><b>tensor</b></li><li class="navelem"><b>novel</b></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::tensor::novel::SparseShape&lt; FieldType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Describes a tensor's shape when there's sparsity.  
 <a href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="novel_2shapes_2sparse__shape_8hpp_source.html">sparse_shape.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tensorwrapper::tensor::novel::SparseShape&lt; FieldType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.png" usemap="#tensorwrapper::tensor::novel::SparseShape_3C_20FieldType_20_3E_map" alt=""/>
  <map id="tensorwrapper::tensor::novel::SparseShape_3C_20FieldType_20_3E_map" name="tensorwrapper::tensor::novel::SparseShape_3C_20FieldType_20_3E_map">
<area href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout." alt="tensorwrapper::tensor::novel::Shape&lt; FieldType &gt;" shape="rect" coords="0,0,334,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6fa224e82e786087ea9b20c801dcb774"><td class="memItemLeft" align="right" valign="top"><a id="a6fa224e82e786087ea9b20c801dcb774"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6fa224e82e786087ea9b20c801dcb774">sparse_map_type</a> = <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">sparse_map::SparseMap</a></td></tr>
<tr class="memdesc:a6fa224e82e786087ea9b20c801dcb774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the sparse map taken as input. <br /></td></tr>
<tr class="separator:a6fa224e82e786087ea9b20c801dcb774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e61ba85d34b28b9dd2e11fa9980e90"><td class="memItemLeft" align="right" valign="top"><a id="a32e61ba85d34b28b9dd2e11fa9980e90"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a32e61ba85d34b28b9dd2e11fa9980e90">const_sparse_map_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6fa224e82e786087ea9b20c801dcb774">sparse_map_type</a> &amp;</td></tr>
<tr class="memdesc:a32e61ba85d34b28b9dd2e11fa9980e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the sparse map the shape is using. <br /></td></tr>
<tr class="separator:a32e61ba85d34b28b9dd2e11fa9980e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba499a33a9419ee7991e1cdda36bf204"><td class="memItemLeft" align="right" valign="top"><a id="aba499a33a9419ee7991e1cdda36bf204"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#aba499a33a9419ee7991e1cdda36bf204">idx2mode_type</a> = std::vector&lt; std::size_t &gt;</td></tr>
<tr class="memdesc:aba499a33a9419ee7991e1cdda36bf204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the input mapping sparse map indices to tensor modes. <br /></td></tr>
<tr class="separator:aba499a33a9419ee7991e1cdda36bf204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f05dc03c086079830771faad227a0be"><td class="memItemLeft" align="right" valign="top"><a id="a9f05dc03c086079830771faad227a0be"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a9f05dc03c086079830771faad227a0be">const_idx2mode_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#aba499a33a9419ee7991e1cdda36bf204">idx2mode_type</a> &amp;</td></tr>
<tr class="memdesc:a9f05dc03c086079830771faad227a0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the sparse map to tensor mode map. <br /></td></tr>
<tr class="separator:a9f05dc03c086079830771faad227a0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d70a4dc42d03f659af1b971691af057"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a> = std::vector&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa000f48eaab77d616fc7ac0a7214f0fe">size_type</a> &gt;</td></tr>
<tr class="separator:a8d70a4dc42d03f659af1b971691af057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52455e16b49447c471834cc77b5d61af"><td class="memItemLeft" align="right" valign="top"><a id="a52455e16b49447c471834cc77b5d61af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a52455e16b49447c471834cc77b5d61af">inner_extents_type</a> = std::conditional_t&lt; field::is_scalar_field_v&lt; FieldType &gt;, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa000f48eaab77d616fc7ac0a7214f0fe">size_type</a>, std::vector&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa000f48eaab77d616fc7ac0a7214f0fe">size_type</a> &gt; &gt;</td></tr>
<tr class="memdesc:a52455e16b49447c471834cc77b5d61af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to treat inner-extents. <br /></td></tr>
<tr class="separator:a52455e16b49447c471834cc77b5d61af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a8d2f888ab6cd1d7ca821cc5feb324"><td class="memItemLeft" align="right" valign="top"><a id="a88a8d2f888ab6cd1d7ca821cc5feb324"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a88a8d2f888ab6cd1d7ca821cc5feb324">index_type</a> = <a class="el" href="structtensorwrapper_1_1sparse__map_1_1Index.html">sparse_map::Index</a></td></tr>
<tr class="memdesc:a88a8d2f888ab6cd1d7ca821cc5feb324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for initializer_lists of sizes. <br /></td></tr>
<tr class="separator:a88a8d2f888ab6cd1d7ca821cc5feb324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3fa9eca759d12dce7885bbf1327e2e"><td class="memItemLeft" align="right" valign="top"><a id="aef3fa9eca759d12dce7885bbf1327e2e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#aef3fa9eca759d12dce7885bbf1327e2e">pointer_type</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">my_type</a> &gt;</td></tr>
<tr class="memdesc:aef3fa9eca759d12dce7885bbf1327e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to this class. <br /></td></tr>
<tr class="separator:aef3fa9eca759d12dce7885bbf1327e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">tensorwrapper::tensor::novel::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:aab26baee4630faf4922d32aa2b59b4b9 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="aab26baee4630faf4922d32aa2b59b4b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aab26baee4630faf4922d32aa2b59b4b9">pimpl_pointer</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1detail___1_1ShapePIMPL.html">pimpl_type</a> &gt;</td></tr>
<tr class="memdesc:aab26baee4630faf4922d32aa2b59b4b9 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to a PIMPL instance. <br /></td></tr>
<tr class="separator:aab26baee4630faf4922d32aa2b59b4b9 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fb627691cbed6476cbe87aa7386233 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a25fb627691cbed6476cbe87aa7386233"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a25fb627691cbed6476cbe87aa7386233">field_type</a> = FieldType</td></tr>
<tr class="memdesc:a25fb627691cbed6476cbe87aa7386233 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the field the associated tensor is over. <br /></td></tr>
<tr class="separator:a25fb627691cbed6476cbe87aa7386233 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa000f48eaab77d616fc7ac0a7214f0fe inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="aa000f48eaab77d616fc7ac0a7214f0fe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa000f48eaab77d616fc7ac0a7214f0fe">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:aa000f48eaab77d616fc7ac0a7214f0fe inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing and offsets. <br /></td></tr>
<tr class="separator:aa000f48eaab77d616fc7ac0a7214f0fe inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d70a4dc42d03f659af1b971691af057 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a> = std::vector&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa000f48eaab77d616fc7ac0a7214f0fe">size_type</a> &gt;</td></tr>
<tr class="separator:a8d70a4dc42d03f659af1b971691af057 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dda03b50da06532851e0ad089eb9c2c inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a8dda03b50da06532851e0ad089eb9c2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8dda03b50da06532851e0ad089eb9c2c">const_extents_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a> &amp;</td></tr>
<tr class="memdesc:a8dda03b50da06532851e0ad089eb9c2c inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the (outer) extents. <br /></td></tr>
<tr class="separator:a8dda03b50da06532851e0ad089eb9c2c inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52455e16b49447c471834cc77b5d61af inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a52455e16b49447c471834cc77b5d61af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a52455e16b49447c471834cc77b5d61af">inner_extents_type</a> = std::conditional_t&lt; field::is_scalar_field_v&lt; FieldType &gt;, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa000f48eaab77d616fc7ac0a7214f0fe">size_type</a>, std::vector&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa000f48eaab77d616fc7ac0a7214f0fe">size_type</a> &gt; &gt;</td></tr>
<tr class="memdesc:a52455e16b49447c471834cc77b5d61af inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to treat inner-extents. <br /></td></tr>
<tr class="separator:a52455e16b49447c471834cc77b5d61af inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad076a5c21ac0dc91503dcc1b239fb6 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="acad076a5c21ac0dc91503dcc1b239fb6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#acad076a5c21ac0dc91503dcc1b239fb6">const_inner_extents_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a52455e16b49447c471834cc77b5d61af">inner_extents_type</a> &amp;</td></tr>
<tr class="memdesc:acad076a5c21ac0dc91503dcc1b239fb6 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the inner. <br /></td></tr>
<tr class="separator:acad076a5c21ac0dc91503dcc1b239fb6 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3fa9eca759d12dce7885bbf1327e2e inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="aef3fa9eca759d12dce7885bbf1327e2e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aef3fa9eca759d12dce7885bbf1327e2e">pointer_type</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">my_type</a> &gt;</td></tr>
<tr class="memdesc:aef3fa9eca759d12dce7885bbf1327e2e inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to this class. <br /></td></tr>
<tr class="separator:aef3fa9eca759d12dce7885bbf1327e2e inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a8d2f888ab6cd1d7ca821cc5feb324 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a88a8d2f888ab6cd1d7ca821cc5feb324"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a88a8d2f888ab6cd1d7ca821cc5feb324">index_type</a> = <a class="el" href="structtensorwrapper_1_1sparse__map_1_1Index.html">sparse_map::Index</a></td></tr>
<tr class="memdesc:a88a8d2f888ab6cd1d7ca821cc5feb324 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for initializer_lists of sizes. <br /></td></tr>
<tr class="separator:a88a8d2f888ab6cd1d7ca821cc5feb324 inherit pub_types_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab4307cb3ae4b2d838ac34afb6abf36b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#ab4307cb3ae4b2d838ac34afb6abf36b1">SparseShape</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a961bcfefb2bd8a16101927e1ad87ea08">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6fa224e82e786087ea9b20c801dcb774">sparse_map_type</a> sm)</td></tr>
<tr class="memdesc:ab4307cb3ae4b2d838ac34afb6abf36b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents and a SparseMap.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#ab4307cb3ae4b2d838ac34afb6abf36b1">More...</a><br /></td></tr>
<tr class="separator:ab4307cb3ae4b2d838ac34afb6abf36b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31374dd29afec88169aeffd255e804a3"><td class="memItemLeft" align="right" valign="top"><a id="a31374dd29afec88169aeffd255e804a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SparseShape</b> (<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a961bcfefb2bd8a16101927e1ad87ea08">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a52455e16b49447c471834cc77b5d61af">inner_extents_type</a> inner_extents, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6fa224e82e786087ea9b20c801dcb774">sparse_map_type</a> sm)</td></tr>
<tr class="separator:a31374dd29afec88169aeffd255e804a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6288e397394440825106aced3964f704"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6288e397394440825106aced3964f704">SparseShape</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a961bcfefb2bd8a16101927e1ad87ea08">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6fa224e82e786087ea9b20c801dcb774">sparse_map_type</a> sm, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#aba499a33a9419ee7991e1cdda36bf204">idx2mode_type</a> i2m)</td></tr>
<tr class="memdesc:a6288e397394440825106aced3964f704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents, a SparseMap, and a mapping from SparseMap indices to tensor modes.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6288e397394440825106aced3964f704">More...</a><br /></td></tr>
<tr class="separator:a6288e397394440825106aced3964f704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bb4d39096bd2431a1832377e660d92"><td class="memItemLeft" align="right" valign="top"><a id="a51bb4d39096bd2431a1832377e660d92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SparseShape</b> (<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a961bcfefb2bd8a16101927e1ad87ea08">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a52455e16b49447c471834cc77b5d61af">inner_extents_type</a> inner_extents, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6fa224e82e786087ea9b20c801dcb774">sparse_map_type</a> sm, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#aba499a33a9419ee7991e1cdda36bf204">idx2mode_type</a> i2m)</td></tr>
<tr class="separator:a51bb4d39096bd2431a1832377e660d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dbaf093ef91cb404185078a34b432f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#ad0dbaf093ef91cb404185078a34b432f">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ad0dbaf093ef91cb404185078a34b432f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-polymorphic comparison of two <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#ad0dbaf093ef91cb404185078a34b432f">More...</a><br /></td></tr>
<tr class="separator:ad0dbaf093ef91cb404185078a34b432f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9921526514aff53c6d54f33dd6c42ea0"><td class="memTemplParams" colspan="2">template&lt;typename RHSField , typename  = disable_if_same_field_t&lt;RHSField&gt;&gt; </td></tr>
<tr class="memitem:a9921526514aff53c6d54f33dd6c42ea0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a9921526514aff53c6d54f33dd6c42ea0">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;) const noexcept</td></tr>
<tr class="memdesc:a9921526514aff53c6d54f33dd6c42ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements operator== for different fields.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a9921526514aff53c6d54f33dd6c42ea0">More...</a><br /></td></tr>
<tr class="separator:a9921526514aff53c6d54f33dd6c42ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53982cb87e604be6624d0a46ed3aa5ce"><td class="memItemLeft" align="right" valign="top"><a id="a53982cb87e604be6624d0a46ed3aa5ce"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a32e61ba85d34b28b9dd2e11fa9980e90">const_sparse_map_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_map</b> () const</td></tr>
<tr class="separator:a53982cb87e604be6624d0a46ed3aa5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7974d020b16e37b20626d212b4bbcb"><td class="memItemLeft" align="right" valign="top"><a id="a5d7974d020b16e37b20626d212b4bbcb"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a9f05dc03c086079830771faad227a0be">const_idx2mode_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>idx2mode_map</b> () const</td></tr>
<tr class="separator:a5d7974d020b16e37b20626d212b4bbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">tensorwrapper::tensor::novel::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:ac5fb076d6cbf5053f31c496e7437cf79 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#ac5fb076d6cbf5053f31c496e7437cf79">Shape</a> () noexcept</td></tr>
<tr class="memdesc:ac5fb076d6cbf5053f31c496e7437cf79 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape with no extents.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#ac5fb076d6cbf5053f31c496e7437cf79">More...</a><br /></td></tr>
<tr class="separator:ac5fb076d6cbf5053f31c496e7437cf79 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae925e66aecd640707f9eaca6a4e4600e inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#ae925e66aecd640707f9eaca6a4e4600e">Shape</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a961bcfefb2bd8a16101927e1ad87ea08">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a52455e16b49447c471834cc77b5d61af">inner_extents_type</a> inner_extents={})</td></tr>
<tr class="memdesc:ae925e66aecd640707f9eaca6a4e4600e inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape with the provided extents.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#ae925e66aecd640707f9eaca6a4e4600e">More...</a><br /></td></tr>
<tr class="separator:ae925e66aecd640707f9eaca6a4e4600e inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a97486e78fac08c7468231f77c7a8b6 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a1a97486e78fac08c7468231f77c7a8b6"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a1a97486e78fac08c7468231f77c7a8b6">~Shape</a> () noexcept</td></tr>
<tr class="memdesc:a1a97486e78fac08c7468231f77c7a8b6 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted dtor. <br /></td></tr>
<tr class="separator:a1a97486e78fac08c7468231f77c7a8b6 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad291ed342ff632cf318f32d6c7146a46 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aef3fa9eca759d12dce7885bbf1327e2e">pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#ad291ed342ff632cf318f32d6c7146a46">clone</a> () const</td></tr>
<tr class="memdesc:ad291ed342ff632cf318f32d6c7146a46 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic deep-copy.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#ad291ed342ff632cf318f32d6c7146a46">More...</a><br /></td></tr>
<tr class="separator:ad291ed342ff632cf318f32d6c7146a46 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961bcfefb2bd8a16101927e1ad87ea08 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8dda03b50da06532851e0ad089eb9c2c">const_extents_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a961bcfefb2bd8a16101927e1ad87ea08">extents</a> () const</td></tr>
<tr class="memdesc:a961bcfefb2bd8a16101927e1ad87ea08 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extents of the tensor described by this <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a>.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a961bcfefb2bd8a16101927e1ad87ea08">More...</a><br /></td></tr>
<tr class="separator:a961bcfefb2bd8a16101927e1ad87ea08 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dbd8518b9204374ad47b7b31c3f510 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a27dbd8518b9204374ad47b7b31c3f510"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#acad076a5c21ac0dc91503dcc1b239fb6">const_inner_extents_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inner_extents</b> () const</td></tr>
<tr class="separator:a27dbd8518b9204374ad47b7b31c3f510 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2495754673eb9986315bf80f8a046f62 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a2495754673eb9986315bf80f8a046f62"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa000f48eaab77d616fc7ac0a7214f0fe">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>field_rank</b> () const</td></tr>
<tr class="separator:a2495754673eb9986315bf80f8a046f62 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de4ecc47b97c3190fa0e68305ee7aca inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a3de4ecc47b97c3190fa0e68305ee7aca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_hard_zero</b> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a88a8d2f888ab6cd1d7ca821cc5feb324">index_type</a> &amp;i) const</td></tr>
<tr class="separator:a3de4ecc47b97c3190fa0e68305ee7aca inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43d47609017a32cf076bc781ac3e2c6 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="ab43d47609017a32cf076bc781ac3e2c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_hard_zero</b> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a88a8d2f888ab6cd1d7ca821cc5feb324">index_type</a> &amp;lo, const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a88a8d2f888ab6cd1d7ca821cc5feb324">index_type</a> &amp;hi) const</td></tr>
<tr class="separator:ab43d47609017a32cf076bc781ac3e2c6 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae50c96c8406e8234e7a7ad996804cc inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a4ae50c96c8406e8234e7a7ad996804cc">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a4ae50c96c8406e8234e7a7ad996804cc inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-polymorphic equality comparison for shapes with the same field.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a4ae50c96c8406e8234e7a7ad996804cc">More...</a><br /></td></tr>
<tr class="separator:a4ae50c96c8406e8234e7a7ad996804cc inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52bc5ce71e519dfcb50bdc346f3fa37 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memTemplParams" colspan="2">template&lt;typename RHSType , typename  = enable_if_not_my_field_t&lt;RHSType&gt;&gt; </td></tr>
<tr class="memitem:af52bc5ce71e519dfcb50bdc346f3fa37 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#af52bc5ce71e519dfcb50bdc346f3fa37">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a>&lt; RHSType &gt; &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:af52bc5ce71e519dfcb50bdc346f3fa37 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-polymorphic equality comparison for Shapes with different fields.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#af52bc5ce71e519dfcb50bdc346f3fa37">More...</a><br /></td></tr>
<tr class="separator:af52bc5ce71e519dfcb50bdc346f3fa37 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b226a5a7dec62e2ca76bbf8acbeb18 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a88b226a5a7dec62e2ca76bbf8acbeb18">is_equal</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a88b226a5a7dec62e2ca76bbf8acbeb18 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic equality comparison.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a88b226a5a7dec62e2ca76bbf8acbeb18">More...</a><br /></td></tr>
<tr class="separator:a88b226a5a7dec62e2ca76bbf8acbeb18 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dee11573cb34b0518e3845a89958f0 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa9dee11573cb34b0518e3845a89958f0">hash</a> (tensorwrapper::detail_::Hasher &amp;h) const</td></tr>
<tr class="memdesc:aa9dee11573cb34b0518e3845a89958f0 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic hash function.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa9dee11573cb34b0518e3845a89958f0">More...</a><br /></td></tr>
<tr class="separator:aa9dee11573cb34b0518e3845a89958f0 inherit pub_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3793272a0a5cea918260563715ffcb8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a3793272a0a5cea918260563715ffcb8a">SparseShape</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a> &amp;other)</td></tr>
<tr class="memdesc:a3793272a0a5cea918260563715ffcb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a non-polymorphic copy of this instance.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a3793272a0a5cea918260563715ffcb8a">More...</a><br /></td></tr>
<tr class="separator:a3793272a0a5cea918260563715ffcb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">tensorwrapper::tensor::novel::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:a395be1ec8cdc6456be7b459a100fcdc9 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a395be1ec8cdc6456be7b459a100fcdc9">Shape</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aab26baee4630faf4922d32aa2b59b4b9">pimpl_pointer</a> pimpl) noexcept</td></tr>
<tr class="memdesc:a395be1ec8cdc6456be7b459a100fcdc9 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> with the specified PIMPL.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a395be1ec8cdc6456be7b459a100fcdc9">More...</a><br /></td></tr>
<tr class="separator:a395be1ec8cdc6456be7b459a100fcdc9 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18c803c118f90e16f5f8cf0965d2788 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1detail___1_1ShapePIMPL.html">pimpl_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#af18c803c118f90e16f5f8cf0965d2788">pimpl_</a> () const</td></tr>
<tr class="memdesc:af18c803c118f90e16f5f8cf0965d2788 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PIMPL in a read-only state.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#af18c803c118f90e16f5f8cf0965d2788">More...</a><br /></td></tr>
<tr class="separator:af18c803c118f90e16f5f8cf0965d2788 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd0ab93abe12e7879707c74a05f6f30 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a3cd0ab93abe12e7879707c74a05f6f30">assert_pimpl_</a> () const</td></tr>
<tr class="memdesc:a3cd0ab93abe12e7879707c74a05f6f30 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises an exception if the <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> instance does not contain a PIMPL.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a3cd0ab93abe12e7879707c74a05f6f30">More...</a><br /></td></tr>
<tr class="separator:a3cd0ab93abe12e7879707c74a05f6f30 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefa9c6f5eb9e48ee9c604f18e72a33e inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#adefa9c6f5eb9e48ee9c604f18e72a33e">has_pimpl_</a> () const noexcept</td></tr>
<tr class="memdesc:adefa9c6f5eb9e48ee9c604f18e72a33e inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the instance has a PIMPL or not.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#adefa9c6f5eb9e48ee9c604f18e72a33e">More...</a><br /></td></tr>
<tr class="separator:adefa9c6f5eb9e48ee9c604f18e72a33e inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d326b23bd73ccb0187a97e96f146e0 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a04d326b23bd73ccb0187a97e96f146e0">Shape</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a> &amp;other)=delete</td></tr>
<tr class="separator:a04d326b23bd73ccb0187a97e96f146e0 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9134b15f83302f5376c0c009f0b15a inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="afa9134b15f83302f5376c0c009f0b15a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Shape</b> (<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a> &amp;&amp;other) noexcept=delete</td></tr>
<tr class="separator:afa9134b15f83302f5376c0c009f0b15a inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2206f3f1547d693175391abef3ca2adb inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a2206f3f1547d693175391abef3ca2adb"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a> &amp;rhs)=delete</td></tr>
<tr class="separator:a2206f3f1547d693175391abef3ca2adb inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6242af61e68490dcf72c59054764b195 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a6242af61e68490dcf72c59054764b195"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a> &amp;&amp;rhs) noexcept=delete</td></tr>
<tr class="separator:a6242af61e68490dcf72c59054764b195 inherit pro_methods_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad74fa4db4f86c86b8826d964a0704751"><td class="memTemplParams" colspan="2">template&lt;typename LHSField , typename RHSField &gt; </td></tr>
<tr class="memitem:ad74fa4db4f86c86b8826d964a0704751"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#ad74fa4db4f86c86b8826d964a0704751">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a>&lt; LHSField &gt; &amp;lhs, const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad74fa4db4f86c86b8826d964a0704751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances are different, non-polymorphically.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#ad74fa4db4f86c86b8826d964a0704751">More...</a><br /></td></tr>
<tr class="separator:ad74fa4db4f86c86b8826d964a0704751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('related_classtensorwrapper_1_1tensor_1_1novel_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">tensorwrapper::tensor::novel::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memTemplParams" colspan="2">template&lt;typename LHSType , typename RHSType &gt; </td></tr>
<tr class="memitem:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aeaf2b480cf78a28a492aa683cd05a0dd">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a>&lt; LHSType &gt; &amp;lhs, const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">Shape</a>&lt; RHSType &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> instances are different.  <a href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aeaf2b480cf78a28a492aa683cd05a0dd">More...</a><br /></td></tr>
<tr class="separator:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classtensorwrapper_1_1tensor_1_1novel_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename FieldType&gt;<br />
class tensorwrapper::tensor::novel::SparseShape&lt; FieldType &gt;</h3>

<p>Describes a tensor's shape when there's sparsity. </p>
<p>This class uses a SparseMap and an allocator to properly determine which tiles are 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldType</td><td>Type of the elements in the field associated with the tensor. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8d70a4dc42d03f659af1b971691af057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d70a4dc42d03f659af1b971691af057">&#9670;&nbsp;</a></span>extents_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html">tensorwrapper::tensor::novel::Shape</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a> =  std::vector&lt;<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#aa000f48eaab77d616fc7ac0a7214f0fe">size_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type used to provide/return extents (outer extents for FieldType == Tensor) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab4307cb3ae4b2d838ac34afb6abf36b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4307cb3ae4b2d838ac34afb6abf36b1">&#9670;&nbsp;</a></span>SparseShape() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">tensorwrapper::tensor::novel::SparseShape</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a>&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6fa224e82e786087ea9b20c801dcb774">sparse_map_type</a>&#160;</td>
          <td class="paramname"><em>sm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents and a SparseMap. </p>
<p>This ctor delegates to the primary constructor. It assumes that the mapping from an independent and dependent index to a tensor index is simply concatenation, <em>e.g.</em>, given independent index (1, 2) and dependent index (3, 4) this function assumes that the corresponding tensor index is (1, 2; 3, 4) (semi-colon separating outer and inner tensor indices). This constructor is primarily of use when the shape is describing a ToT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The length of each mode.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The SparseMap specifying which dependent indices must be considered for a given independent index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the overall rank <code>sm</code> is inconsistent with the length of <code>extents</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6288e397394440825106aced3964f704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6288e397394440825106aced3964f704">&#9670;&nbsp;</a></span>SparseShape() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">tensorwrapper::tensor::novel::SparseShape</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html#a8d70a4dc42d03f659af1b971691af057">extents_type</a>&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#a6fa224e82e786087ea9b20c801dcb774">sparse_map_type</a>&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#aba499a33a9419ee7991e1cdda36bf204">idx2mode_type</a>&#160;</td>
          <td class="paramname"><em>i2m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents, a SparseMap, and a mapping from SparseMap indices to tensor modes. </p>
<p>This is the primary constructor for creating a <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The length of each mode.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The SparseMap containing a map from independent indices to non-zero dependent indices.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx2mode</td><td>Assuming <code>sm</code> contains independent indices of rank <img class="formulaInl" alt="$i$" src="form_9.png"/>, and dependent indices of rank <img class="formulaInl" alt="$d$" src="form_21.png"/>, <code>idx2mode</code> is an <img class="formulaInl" alt="$i + d$" src="form_22.png"/> element vector such that for <img class="formulaInl" alt="$j&lt;i$" src="form_23.png"/> <code>idx2mode[j]</code> is the mode of the shape that the <img class="formulaInl" alt="$j$" src="form_10.png"/>-th independent mode maps to. For <img class="formulaInl" alt="$i &lt;= j &lt; i + d$" src="form_24.png"/> <code>idx2mode[j]</code> is the mode of the shape that the <img class="formulaInl" alt="$j-i$" src="form_25.png"/>-th dependent mode maps to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the overall rank of <code>sm</code> is inconsistent with the length of <code>idx2mode</code>. Strong throw gurantee. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>If any element of <code>idx2mode</code> is larger than the rank of the shape. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3793272a0a5cea918260563715ffcb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3793272a0a5cea918260563715ffcb8a">&#9670;&nbsp;</a></span>SparseShape() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">tensorwrapper::tensor::novel::SparseShape</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a non-polymorphic copy of this instance. </p>
<p>This copy operation will deep-copy all state in the <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> part of the object (including the <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> base class). This function is primarily used to implement Clone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance we are copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating memory. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad0dbaf093ef91cb404185078a34b432f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dbaf093ef91cb404185078a34b432f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">tensorwrapper::tensor::novel::SparseShape</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-polymorphic comparison of two <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances. </p>
<p>Two <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances are equivalent if there base classes compare equal, they both have the same sparse map, and the sparse map indices are mapped to the tensor modes the same way. If a class derives from <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a>, any state in the derived class is not considered by this comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this instance compares equivalent to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9921526514aff53c6d54f33dd6c42ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9921526514aff53c6d54f33dd6c42ea0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<div class="memtemplate">
template&lt;typename RHSField , typename  = disable_if_same_field_t&lt;RHSField&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">tensorwrapper::tensor::novel::SparseShape</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements operator== for different fields. </p>
<p>If two <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances have different fields they are not equal. This function is chosen when the two <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances have different fields and will return false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RHSField</td><td>The type of field <code>rhs</code> is defined over. Assumed to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>. </td></tr>
    <tr><td class="paramname">&lt;anonymous&gt;</td><td>Used to enable this function, via SFINAE, when <code>RHSField</code> is different from FieldType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False. This function is only used when the fields are different, in which case the shapes are also different.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad74fa4db4f86c86b8826d964a0704751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74fa4db4f86c86b8826d964a0704751">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSField , typename RHSField &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a>&lt; LHSField &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances are different, non-polymorphically. </p>
<p>This function simply negates <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#ad0dbaf093ef91cb404185078a34b432f" title="Non-polymorphic comparison of two SparseShape instances.">SparseShape::operator==</a>. See documentation for <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html#ad0dbaf093ef91cb404185078a34b432f" title="Non-polymorphic comparison of two SparseShape instances.">SparseShape::operator==</a> for what constitutes equivalency for <a class="el" href="classtensorwrapper_1_1tensor_1_1novel_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSField</td><td>The type of the field associated with <code>lhs</code>. Assumed to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>. </td></tr>
    <tr><td class="paramname">RHSField</td><td>The type of the field associated with <code>rhs</code>. Assumed to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The shape instance on the left side of the comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The shape instance on the right side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <code>lhs</code> and <code>rhs</code> compare equal and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tensorwrapper/tensor/novel/shapes/<a class="el" href="novel_2shapes_2sparse__shape_8hpp_source.html">sparse_shape.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
