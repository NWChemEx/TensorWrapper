<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::dsl::DummyIndices&lt; StringType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">0.0.40</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetensorwrapper.html">tensorwrapper</a></li><li class="navelem"><b>dsl</b></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classtensorwrapper_1_1dsl_1_1DummyIndices-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::dsl::DummyIndices&lt; StringType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to help deal with string-based dummy indices.  
 <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dummy__indices_8hpp_source.html">dummy_indices.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tensorwrapper::dsl::DummyIndices&lt; StringType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtensorwrapper_1_1dsl_1_1DummyIndices__inherit__graph.png" border="0" usemap="#atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_inherit__map" id="atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_inherit__map">
<area shape="rect" title="Class to help deal with string&#45;based dummy indices." alt="" coords="32,95,259,136"/>
<area shape="rect" title=" " alt="" coords="5,5,285,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for tensorwrapper::dsl::DummyIndices&lt; StringType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtensorwrapper_1_1dsl_1_1DummyIndices__coll__graph.png" border="0" usemap="#atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_coll__map" id="atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_coll__map">
<area shape="rect" title="Class to help deal with string&#45;based dummy indices." alt="" coords="32,95,259,136"/>
<area shape="rect" title=" " alt="" coords="5,5,285,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8b9e9303ed7ed39fa56bdb800af92f2f"><td class="memItemLeft" align="right" valign="top"><a id="a8b9e9303ed7ed39fa56bdb800af92f2f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a8b9e9303ed7ed39fa56bdb800af92f2f">value_type</a> = StringType</td></tr>
<tr class="memdesc:a8b9e9303ed7ed39fa56bdb800af92f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to hold the string representation of the dummy indices. <br /></td></tr>
<tr class="separator:a8b9e9303ed7ed39fa56bdb800af92f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb330cc0c92127a9c885c9b60e667b6"><td class="memItemLeft" align="right" valign="top"><a id="afcb330cc0c92127a9c885c9b60e667b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#afcb330cc0c92127a9c885c9b60e667b6">reference</a> = <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a8b9e9303ed7ed39fa56bdb800af92f2f">value_type</a> &amp;</td></tr>
<tr class="memdesc:afcb330cc0c92127a9c885c9b60e667b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a mutable reference to a value_type. <br /></td></tr>
<tr class="separator:afcb330cc0c92127a9c885c9b60e667b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac450f900ed5b1686a5b48e3bb03d564c"><td class="memItemLeft" align="right" valign="top"><a id="ac450f900ed5b1686a5b48e3bb03d564c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a> = const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a8b9e9303ed7ed39fa56bdb800af92f2f">value_type</a> &amp;</td></tr>
<tr class="memdesc:ac450f900ed5b1686a5b48e3bb03d564c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to a value_type object. <br /></td></tr>
<tr class="separator:ac450f900ed5b1686a5b48e3bb03d564c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499aeed44afc4cb5d466d8a74711a5f4"><td class="memItemLeft" align="right" valign="top"><a id="a499aeed44afc4cb5d466d8a74711a5f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a499aeed44afc4cb5d466d8a74711a5f4">split_string_type</a> = std::vector&lt; <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a8b9e9303ed7ed39fa56bdb800af92f2f">value_type</a> &gt;</td></tr>
<tr class="memdesc:a499aeed44afc4cb5d466d8a74711a5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the string representation after splitting on commas. <br /></td></tr>
<tr class="separator:a499aeed44afc4cb5d466d8a74711a5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ee0818e5b85c1e291d965fa5b58a25"><td class="memItemLeft" align="right" valign="top"><a id="a57ee0818e5b85c1e291d965fa5b58a25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> = typename split_string_type::size_type</td></tr>
<tr class="memdesc:a57ee0818e5b85c1e291d965fa5b58a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for offsets. <br /></td></tr>
<tr class="separator:a57ee0818e5b85c1e291d965fa5b58a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6025b21b588ec419842de250959259e3"><td class="memItemLeft" align="right" valign="top"><a id="a6025b21b588ec419842de250959259e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a> = std::vector&lt; <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> &gt;</td></tr>
<tr class="memdesc:a6025b21b588ec419842de250959259e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for returning ordered sets of size_type objects. <br /></td></tr>
<tr class="separator:a6025b21b588ec419842de250959259e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9fe08c3dd63065b6be315c618244d1d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a9fe08c3dd63065b6be315c618244d1d9">DummyIndices</a> ()=default</td></tr>
<tr class="memdesc:a9fe08c3dd63065b6be315c618244d1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object with no dummy indices.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a9fe08c3dd63065b6be315c618244d1d9">More...</a><br /></td></tr>
<tr class="separator:a9fe08c3dd63065b6be315c618244d1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e50697d1d7ac2b59e9383494eaff3c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a1e50697d1d7ac2b59e9383494eaff3c3">DummyIndices</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a> dummy_indices)</td></tr>
<tr class="memdesc:a1e50697d1d7ac2b59e9383494eaff3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object by parsing a string.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a1e50697d1d7ac2b59e9383494eaff3c3">More...</a><br /></td></tr>
<tr class="separator:a1e50697d1d7ac2b59e9383494eaff3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc5d9056ed0d7c8b37dfdbf6d7c19c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a5cc5d9056ed0d7c8b37dfdbf6d7c19c6">unique_index_size</a> () const</td></tr>
<tr class="memdesc:a5cc5d9056ed0d7c8b37dfdbf6d7c19c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of unique indices in *this.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a5cc5d9056ed0d7c8b37dfdbf6d7c19c6">More...</a><br /></td></tr>
<tr class="separator:a5cc5d9056ed0d7c8b37dfdbf6d7c19c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1967c3a0f0ecb5a34fe3ea913d40d09a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a1967c3a0f0ecb5a34fe3ea913d40d09a">has_repeated_indices</a> () const</td></tr>
<tr class="memdesc:a1967c3a0f0ecb5a34fe3ea913d40d09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does *this have repeated indices?  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a1967c3a0f0ecb5a34fe3ea913d40d09a">More...</a><br /></td></tr>
<tr class="separator:a1967c3a0f0ecb5a34fe3ea913d40d09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb44ea53136f98e0a7825159a78d634e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#abb44ea53136f98e0a7825159a78d634e">is_permutation</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:abb44ea53136f98e0a7825159a78d634e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is a permutation of <code>other</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#abb44ea53136f98e0a7825159a78d634e">More...</a><br /></td></tr>
<tr class="separator:abb44ea53136f98e0a7825159a78d634e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e600707ce2058dfe52f114183c355e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a2e600707ce2058dfe52f114183c355e3">is_hadamard_product</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;lhs, const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a2e600707ce2058dfe52f114183c355e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a thruple of <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> consistent with a pure element-wise product?  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a2e600707ce2058dfe52f114183c355e3">More...</a><br /></td></tr>
<tr class="separator:a2e600707ce2058dfe52f114183c355e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464236bbc7c46269ed955e93d48f65e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a464236bbc7c46269ed955e93d48f65e1">is_contraction</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;lhs, const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a464236bbc7c46269ed955e93d48f65e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a thruple of <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> indicate a product is a pure contraction?  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a464236bbc7c46269ed955e93d48f65e1">More...</a><br /></td></tr>
<tr class="separator:a464236bbc7c46269ed955e93d48f65e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05338cd83a3d73acefdc630f3a7052ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a05338cd83a3d73acefdc630f3a7052ad">permutation</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;other) const</td></tr>
<tr class="memdesc:a05338cd83a3d73acefdc630f3a7052ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the permutation needed to convert *this into <code>other</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a05338cd83a3d73acefdc630f3a7052ad">More...</a><br /></td></tr>
<tr class="separator:a05338cd83a3d73acefdc630f3a7052ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d4b14865bd4f880b261777ea5dd7fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#aa2d4b14865bd4f880b261777ea5dd7fd">find</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a> index_to_find) const</td></tr>
<tr class="memdesc:aa2d4b14865bd4f880b261777ea5dd7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the offset of <code>index_to_find</code> in *this.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#aa2d4b14865bd4f880b261777ea5dd7fd">More...</a><br /></td></tr>
<tr class="separator:aa2d4b14865bd4f880b261777ea5dd7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefe6f2d8639c3132c73f60922ec02f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#aeefe6f2d8639c3132c73f60922ec02f2">count</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a> index_to_find) const noexcept</td></tr>
<tr class="memdesc:aeefe6f2d8639c3132c73f60922ec02f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines how many times <code>index_to_find</code> occurs in *this.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#aeefe6f2d8639c3132c73f60922ec02f2">More...</a><br /></td></tr>
<tr class="separator:aeefe6f2d8639c3132c73f60922ec02f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9828b8ad4ef046cc7b340289b88590b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a9828b8ad4ef046cc7b340289b88590b5">operator==</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a9828b8ad4ef046cc7b340289b88590b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is value equal to <code>rhs</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a9828b8ad4ef046cc7b340289b88590b5">More...</a><br /></td></tr>
<tr class="separator:a9828b8ad4ef046cc7b340289b88590b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409bbb9d96b8b489282d3ad86cff86a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a409bbb9d96b8b489282d3ad86cff86a2">operator==</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a> s) const</td></tr>
<tr class="memdesc:a409bbb9d96b8b489282d3ad86cff86a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is value equal to <code>s</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a409bbb9d96b8b489282d3ad86cff86a2">More...</a><br /></td></tr>
<tr class="separator:a409bbb9d96b8b489282d3ad86cff86a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94695b94c3a3988445e380e507125bef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a94695b94c3a3988445e380e507125bef">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a94695b94c3a3988445e380e507125bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is different from <code>rhs</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a94695b94c3a3988445e380e507125bef">More...</a><br /></td></tr>
<tr class="separator:a94695b94c3a3988445e380e507125bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890c43e34bdeb510f829c21eab6dd6fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a890c43e34bdeb510f829c21eab6dd6fa">operator!=</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a> s) const</td></tr>
<tr class="memdesc:a890c43e34bdeb510f829c21eab6dd6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is different than <code>s</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a890c43e34bdeb510f829c21eab6dd6fa">More...</a><br /></td></tr>
<tr class="separator:a890c43e34bdeb510f829c21eab6dd6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4440bda43c5e60d31262e548213519"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a7c4440bda43c5e60d31262e548213519">concatenation</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;other) const</td></tr>
<tr class="memdesc:a7c4440bda43c5e60d31262e548213519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object formed by concatenating *this with <code>other</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a7c4440bda43c5e60d31262e548213519">More...</a><br /></td></tr>
<tr class="separator:a7c4440bda43c5e60d31262e548213519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c518ef880ad96a7745d3b78cd1c6b99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a4c518ef880ad96a7745d3b78cd1c6b99">intersection</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;other) const</td></tr>
<tr class="memdesc:a4c518ef880ad96a7745d3b78cd1c6b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique indices of *this which appear in <code>other</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a4c518ef880ad96a7745d3b78cd1c6b99">More...</a><br /></td></tr>
<tr class="separator:a4c518ef880ad96a7745d3b78cd1c6b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b737f42421b1110ac81d28fcb7617d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ae7b737f42421b1110ac81d28fcb7617d">difference</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;other) const</td></tr>
<tr class="memdesc:ae7b737f42421b1110ac81d28fcb7617d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set difference of *this and <code>other</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ae7b737f42421b1110ac81d28fcb7617d">More...</a><br /></td></tr>
<tr class="separator:ae7b737f42421b1110ac81d28fcb7617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad88bf821540a38c854b0bf6c901c8903"><td class="memItemLeft" align="right" valign="top"><a id="ad88bf821540a38c854b0bf6c901c8903"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ad88bf821540a38c854b0bf6c901c8903">DummyIndices</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a499aeed44afc4cb5d466d8a74711a5f4">split_string_type</a> split_dummy_indices)</td></tr>
<tr class="memdesc:ad88bf821540a38c854b0bf6c901c8903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main ctor for setting the value, throws if any index is empty. <br /></td></tr>
<tr class="separator:ad88bf821540a38c854b0bf6c901c8903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2abb9719cca0bc1d48c8793d5dde00"><td class="memItemLeft" align="right" valign="top"><a id="a3e2abb9719cca0bc1d48c8793d5dde00"></a>
<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#afcb330cc0c92127a9c885c9b60e667b6">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a3e2abb9719cca0bc1d48c8793d5dde00">at_</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> i)</td></tr>
<tr class="memdesc:a3e2abb9719cca0bc1d48c8793d5dde00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements mutable element retrieval by forwarding to m_dummy indices_. <br /></td></tr>
<tr class="separator:a3e2abb9719cca0bc1d48c8793d5dde00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b525e9a1b90415fd7d7d98a179cd104"><td class="memItemLeft" align="right" valign="top"><a id="a5b525e9a1b90415fd7d7d98a179cd104"></a>
<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a5b525e9a1b90415fd7d7d98a179cd104">at_</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> i) const</td></tr>
<tr class="memdesc:a5b525e9a1b90415fd7d7d98a179cd104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements read-only element retrieval by forwarding to m_dummy indices_. <br /></td></tr>
<tr class="separator:a5b525e9a1b90415fd7d7d98a179cd104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e7f352f1873d8f1b6f19974baa1704"><td class="memItemLeft" align="right" valign="top"><a id="ac9e7f352f1873d8f1b6f19974baa1704"></a>
<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac9e7f352f1873d8f1b6f19974baa1704">size_</a> () const noexcept</td></tr>
<tr class="memdesc:ac9e7f352f1873d8f1b6f19974baa1704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements size by calling m_dummy indices_.size() <br /></td></tr>
<tr class="separator:ac9e7f352f1873d8f1b6f19974baa1704"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a42d5253d9f97cfbdb31dca92d456f64e"><td class="memItemLeft" align="right" valign="top"><a id="a42d5253d9f97cfbdb31dca92d456f64e"></a>
friend&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a42d5253d9f97cfbdb31dca92d456f64e">base_type</a></td></tr>
<tr class="memdesc:a42d5253d9f97cfbdb31dca92d456f64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets the base class get at these implementations. <br /></td></tr>
<tr class="separator:a42d5253d9f97cfbdb31dca92d456f64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename StringType&gt;<br />
class tensorwrapper::dsl::DummyIndices&lt; StringType &gt;</h3>

<p>Class to help deal with string-based dummy indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringType</td><td>The type used to hold the dummy indices.</td></tr>
  </table>
  </dd>
</dl>
<p>The DSL calls for the user to label each mode of a tensor (or shape, or buffer, or...) with a dummy index. This is usually done by providing a compile time literal like <code>"i,j,k"</code>, which would label the modes of a rank 3 tensor such that mode 0 is assigned dummy index <code>"i"</code>, mode 1 is assigned dummy index <code>"j"</code>, and mode 2 is assigned dummy index <code>"k"</code>. While strings are nice for the user, they're less nice for the developer. This class maps the string the user provided to an ordered sets of objects. The developer can then request common dummy index manipulations like set difference or permutation and let *this worry about the string manipulations.</p>
<p>This class defines the string to dummy index conventions used throughout the TensorWrapper library, namely:</p>
<ul>
<li>Dummy indices are separated by commas, i.e., <code>"i,jk,l"</code> defines three indices such that mode 0 is labeled by <code>"i"</code>, mode 1 by <code>"jk"</code>, and mode 2 by <code>"l"</code>.</li>
<li>Dummy indices can be multiple characters (see previous example)</li>
<li>Dummy indices are case-sensitive, i.e., <code>"i,J"</code> and <code>"i,j"</code> result in different dummy indices for mode 1.</li>
<li>Spaces are assumed to be for the user's clarity and are stripped prior to spliting i.e., <code>"i, j"</code> and <code>"i,j"</code> are the same set of indices. This also means <code>"my index,k"</code> will define a dummy index <code>"myindex"</code> for mode 0. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9fe08c3dd63065b6be315c618244d1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe08c3dd63065b6be315c618244d1d9">&#9670;&nbsp;</a></span>DummyIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object with no dummy indices. </p>
<p>Default constructed <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> objects behave like they contain the dummy indices for a scalar.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e50697d1d7ac2b59e9383494eaff3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e50697d1d7ac2b59e9383494eaff3c3">&#9670;&nbsp;</a></span>DummyIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a>&#160;</td>
          <td class="paramname"><em>dummy_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object by parsing a string. </p>
<p>We assume that <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> objects will be created directly from user input and that user input will be in a type implicitly convertible to <code>const_reference</code>. Under these assumptions, this ctor is the main user- facing ctor for the class. This ctor will first remove spaces in <code>dummy_indices</code> and then split the space-less string on commas. Finally, it will verify that the resulting vector of dummy indices has non-empty elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dummy_indices</td><td>The string used to initialize *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>dummy_indices</code> contains one or more commas and if after splitting on the commas one or more of the resulting dummy indices is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c4440bda43c5e60d31262e548213519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4440bda43c5e60d31262e548213519">&#9670;&nbsp;</a></span>concatenation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::concatenation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object formed by concatenating *this with <code>other</code>. </p>
<p>This method will create a new <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object which contains <code>this-&gt;size()</code> plus <code>other.size()</code> indices. The first <code>this-&gt;size()</code> indices will be the indices of *this and the next <code>other.size()</code> indices will be the indices of <code>other</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This is in general NOT the union of *this with <code>other</code>, in particular repeat indices may appear.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The indices to concatenate onto *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object formed by concatenating *this with <code>other</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating the return fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeefe6f2d8639c3132c73f60922ec02f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefe6f2d8639c3132c73f60922ec02f2">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a>&#160;</td>
          <td class="paramname"><em>index_to_find</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines how many times <code>index_to_find</code> occurs in *this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index_to_find</td><td>The dummy index to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of times dummy index occurs in *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7b737f42421b1110ac81d28fcb7617d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b737f42421b1110ac81d28fcb7617d">&#9670;&nbsp;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set difference of *this and <code>other</code>. </p>
<p>The set difference of *this with <code>other</code> is the set of indices which appear in *this, but not in <code>other</code>. This method will return the set (indices which appear more than once in *this will only appear once in the result) which results from the set difference of *this with <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The set to remove from *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set difference of *this and <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2d4b14865bd4f880b261777ea5dd7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d4b14865bd4f880b261777ea5dd7fd">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a>&#160;</td>
          <td class="paramname"><em>index_to_find</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the offset of <code>index_to_find</code> in *this. </p>
<p>This method can be used to determine which modes the dummy index <code>index_to_find</code> maps to. If <code>index_to_find</code> does not appear in *this the result is empty. If <code>index_to_find</code> appears more than once the result will contain the offset for each appearance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index_to_find</td><td>The dummy index to determine the offset of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container whose elements are the offsets of <code>index_to_find</code> in *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1967c3a0f0ecb5a34fe3ea913d40d09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1967c3a0f0ecb5a34fe3ea913d40d09a">&#9670;&nbsp;</a></span>has_repeated_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::has_repeated_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does *this have repeated indices? </p>
<p>This method is used to determine if *this contains any index that appears more than once.</p>
<dl class="section return"><dt>Returns</dt><dd>True if *this contains a repeated index and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the internal call to <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a5cc5d9056ed0d7c8b37dfdbf6d7c19c6" title="Determines the number of unique indices in *this.">unique_index_size()</a> throws. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c518ef880ad96a7745d3b78cd1c6b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c518ef880ad96a7745d3b78cd1c6b99">&#9670;&nbsp;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unique indices of *this which appear in <code>other</code>. </p>
<p>This method retruns a new <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object containing the set of indices in *this which also appear in <code>other</code>. The indices in the result are unique (i.e., if an index is repeated in *this it is only added to result once).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The object to compare *this to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object which contains the intersection of *this with <code>other</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocation of the return fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a464236bbc7c46269ed955e93d48f65e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464236bbc7c46269ed955e93d48f65e1">&#9670;&nbsp;</a></span>is_contraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::is_contraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does a thruple of <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> indicate a product is a pure contraction? </p>
<p>In generalized Einstein notation a pure contraction is an operation where indices common to <code>lhs</code> and <code>rhs</code> are summed over and do NOT appear in the result, i.e., *this. Additionally, we stipulate that there must be at least one index summed over (if no index is summed over the operation is a pure direct-product).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The dummy indices associated with the tensor to the left of the times operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The dummy indices associated with the tensor to the right of the times operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the indices associated with *this, <code>lhs</code>, and <code>rhs</code> are consistent with a contraction and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e600707ce2058dfe52f114183c355e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e600707ce2058dfe52f114183c355e3">&#9670;&nbsp;</a></span>is_hadamard_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::is_hadamard_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a thruple of <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> consistent with a pure element-wise product? </p>
<p>In generalized Einstein notation a pure element-wise (also commonly termed Hadamard) product is denoted by *this, <code>lhs</code>, and <code>rhs</code> having the same ordered set of dummy indices, up to permutation. Additionally, the dummy indices associated with any given tensor may not include a repeated index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The dummy indices associated with the tensor to the left of the times operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The dummy indices associated with the tensor to the right of the times operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True If the dummy indices given by *this, <code>lhs</code>, and <code>rhs</code> are consistent with a purely element-wise product of the tensors that <code>lhs</code> and <code>rhs</code> label.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb44ea53136f98e0a7825159a78d634e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb44ea53136f98e0a7825159a78d634e">&#9670;&nbsp;</a></span>is_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::is_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is a permutation of <code>other</code>. </p>
<p>*this is a permutation of <code>other</code> if both *this and <code>other</code> contain the same number of dummy indices and if each unique index in *this appears the same number of times in *this and <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The set of dummy indices to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this is a permutation of <code>other</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94695b94c3a3988445e380e507125bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94695b94c3a3988445e380e507125bef">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is different from <code>rhs</code>. </p>
<p>Two <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> objects are different if they are not value equal. See the description of operator==(const DummyIndices&amp;) for the definition of value equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if *this and <code>rhs</code> are value equal and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a890c43e34bdeb510f829c21eab6dd6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890c43e34bdeb510f829c21eab6dd6fa">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is different than <code>s</code>. </p>
<p>This method is useful for comparing an already parsed <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object to a string literal. It works by converting <code>s</code> into a <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object and then comparing the resulting <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object to *this. See operator!=(const DummyIndices&amp;) for more details on the comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to compare to *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if *this is value equal to <code>s</code> as a <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if parsing <code>s</code> encounters an allocation problem. Strong throw guara </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if parsing <code>s</code> throws. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9828b8ad4ef046cc7b340289b88590b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9828b8ad4ef046cc7b340289b88590b5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is value equal to <code>rhs</code>. </p>
<p>*this and <code>rhs</code> are value equal if they contain the same number of indices and if the i-th dummy index of *this is value equal to the i-th dummy index of <code>rhs</code> for all i in the range [0, size()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this is value equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409bbb9d96b8b489282d3ad86cff86a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409bbb9d96b8b489282d3ad86cff86a2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is value equal to <code>s</code>. </p>
<p>This method is useful for comparing an already parsed <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object to a string literal. This method works by converting <code>s</code> into a DummyIndex object and then comparing the resulting <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object to *this. See operator==(const DummyIndices&amp;) for more details on the comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string to compare to *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this is value equal to <code>s</code> as a <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if parsing <code>s</code> encounters an allocation problem. Strong throw guara </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if parsing <code>s</code> throws. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05338cd83a3d73acefdc630f3a7052ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05338cd83a3d73acefdc630f3a7052ad">&#9670;&nbsp;</a></span>permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the permutation needed to convert *this into <code>other</code>. </p>
<p>Each <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object is viewed as an ordered set of objects. If two <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> objects contain the same objects, but in a different order, we can convert either object into the other by permuting it. This method computes the permutation needed to change *this into <code>other</code>. More specifically the result of this method is a vector of length <code>size()</code> such that the <code>i</code>-th element is the offset of <code>(*this)[i]</code> in <code>other</code>, i.e., if <code>x</code> is the return then <code>other[x[i]] == (*this)[i]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The order we want to permute *this to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector such that the i-th element is the offset of <code>(*this)[i]</code> in <code>other</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this and <code>other</code> do not have the same size, or if either *this or <code>other</code> have repeated indices, or if an index in *this does not appear in <code>other</code>. Strong throw guarantee in each case. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cc5d9056ed0d7c8b37dfdbf6d7c19c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc5d9056ed0d7c8b37dfdbf6d7c19c6">&#9670;&nbsp;</a></span>unique_index_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::unique_index_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of unique indices in *this. </p>
<p>A dummy index can be repeated if it is going to be summed over. This method analyzes the indices in *this and determines how many of them are unique.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of indices which appear only once in *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the temporary container can not be allocated. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tensorwrapper/dsl/<a class="el" href="dummy__indices_8hpp_source.html">dummy_indices.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
