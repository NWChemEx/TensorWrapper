<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::dsl::DummyIndices&lt; StringType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">0.0.37</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetensorwrapper.html">tensorwrapper</a></li><li class="navelem"><b>dsl</b></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classtensorwrapper_1_1dsl_1_1DummyIndices-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::dsl::DummyIndices&lt; StringType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to help deal with string-based dummy indices.  
 <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dummy__indices_8hpp_source.html">dummy_indices.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tensorwrapper::dsl::DummyIndices&lt; StringType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtensorwrapper_1_1dsl_1_1DummyIndices__inherit__graph.png" border="0" usemap="#atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_inherit__map" id="atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_inherit__map">
<area shape="rect" title="Class to help deal with string&#45;based dummy indices." alt="" coords="32,95,259,136"/>
<area shape="rect" title=" " alt="" coords="5,5,285,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for tensorwrapper::dsl::DummyIndices&lt; StringType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtensorwrapper_1_1dsl_1_1DummyIndices__coll__graph.png" border="0" usemap="#atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_coll__map" id="atensorwrapper_1_1dsl_1_1DummyIndices_3_01StringType_01_4_coll__map">
<area shape="rect" title="Class to help deal with string&#45;based dummy indices." alt="" coords="32,95,259,136"/>
<area shape="rect" title=" " alt="" coords="5,5,285,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8b9e9303ed7ed39fa56bdb800af92f2f"><td class="memItemLeft" align="right" valign="top"><a id="a8b9e9303ed7ed39fa56bdb800af92f2f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a8b9e9303ed7ed39fa56bdb800af92f2f">value_type</a> = StringType</td></tr>
<tr class="memdesc:a8b9e9303ed7ed39fa56bdb800af92f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to hold the string representation of the dummy indices. <br /></td></tr>
<tr class="separator:a8b9e9303ed7ed39fa56bdb800af92f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb330cc0c92127a9c885c9b60e667b6"><td class="memItemLeft" align="right" valign="top"><a id="afcb330cc0c92127a9c885c9b60e667b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#afcb330cc0c92127a9c885c9b60e667b6">reference</a> = <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a8b9e9303ed7ed39fa56bdb800af92f2f">value_type</a> &amp;</td></tr>
<tr class="memdesc:afcb330cc0c92127a9c885c9b60e667b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a mutable reference to a value_type. <br /></td></tr>
<tr class="separator:afcb330cc0c92127a9c885c9b60e667b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac450f900ed5b1686a5b48e3bb03d564c"><td class="memItemLeft" align="right" valign="top"><a id="ac450f900ed5b1686a5b48e3bb03d564c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a> = const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a8b9e9303ed7ed39fa56bdb800af92f2f">value_type</a> &amp;</td></tr>
<tr class="memdesc:ac450f900ed5b1686a5b48e3bb03d564c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to a value_type object. <br /></td></tr>
<tr class="separator:ac450f900ed5b1686a5b48e3bb03d564c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499aeed44afc4cb5d466d8a74711a5f4"><td class="memItemLeft" align="right" valign="top"><a id="a499aeed44afc4cb5d466d8a74711a5f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a499aeed44afc4cb5d466d8a74711a5f4">split_string_type</a> = std::vector&lt; <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a8b9e9303ed7ed39fa56bdb800af92f2f">value_type</a> &gt;</td></tr>
<tr class="memdesc:a499aeed44afc4cb5d466d8a74711a5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the string representation after splitting on commas. <br /></td></tr>
<tr class="separator:a499aeed44afc4cb5d466d8a74711a5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ee0818e5b85c1e291d965fa5b58a25"><td class="memItemLeft" align="right" valign="top"><a id="a57ee0818e5b85c1e291d965fa5b58a25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> = typename split_string_type::size_type</td></tr>
<tr class="memdesc:a57ee0818e5b85c1e291d965fa5b58a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for offsets. <br /></td></tr>
<tr class="separator:a57ee0818e5b85c1e291d965fa5b58a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6025b21b588ec419842de250959259e3"><td class="memItemLeft" align="right" valign="top"><a id="a6025b21b588ec419842de250959259e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a> = std::vector&lt; <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> &gt;</td></tr>
<tr class="memdesc:a6025b21b588ec419842de250959259e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for returning ordered sets of size_type objects. <br /></td></tr>
<tr class="separator:a6025b21b588ec419842de250959259e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9fe08c3dd63065b6be315c618244d1d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a9fe08c3dd63065b6be315c618244d1d9">DummyIndices</a> ()=default</td></tr>
<tr class="memdesc:a9fe08c3dd63065b6be315c618244d1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object with no dummy indices.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a9fe08c3dd63065b6be315c618244d1d9">More...</a><br /></td></tr>
<tr class="separator:a9fe08c3dd63065b6be315c618244d1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e50697d1d7ac2b59e9383494eaff3c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a1e50697d1d7ac2b59e9383494eaff3c3">DummyIndices</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a> dummy_indices)</td></tr>
<tr class="memdesc:a1e50697d1d7ac2b59e9383494eaff3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object by parsing a string.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a1e50697d1d7ac2b59e9383494eaff3c3">More...</a><br /></td></tr>
<tr class="separator:a1e50697d1d7ac2b59e9383494eaff3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc5d9056ed0d7c8b37dfdbf6d7c19c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a5cc5d9056ed0d7c8b37dfdbf6d7c19c6">unique_index_size</a> () const</td></tr>
<tr class="memdesc:a5cc5d9056ed0d7c8b37dfdbf6d7c19c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of unique indices in *this.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a5cc5d9056ed0d7c8b37dfdbf6d7c19c6">More...</a><br /></td></tr>
<tr class="separator:a5cc5d9056ed0d7c8b37dfdbf6d7c19c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1967c3a0f0ecb5a34fe3ea913d40d09a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a1967c3a0f0ecb5a34fe3ea913d40d09a">has_repeated_indices</a> () const</td></tr>
<tr class="memdesc:a1967c3a0f0ecb5a34fe3ea913d40d09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does *this have repeated indices?  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a1967c3a0f0ecb5a34fe3ea913d40d09a">More...</a><br /></td></tr>
<tr class="separator:a1967c3a0f0ecb5a34fe3ea913d40d09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05338cd83a3d73acefdc630f3a7052ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a05338cd83a3d73acefdc630f3a7052ad">permutation</a> (const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> &amp;other) const</td></tr>
<tr class="memdesc:a05338cd83a3d73acefdc630f3a7052ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the permutation needed to convert *this into <code>other</code>.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a05338cd83a3d73acefdc630f3a7052ad">More...</a><br /></td></tr>
<tr class="separator:a05338cd83a3d73acefdc630f3a7052ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d4b14865bd4f880b261777ea5dd7fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#aa2d4b14865bd4f880b261777ea5dd7fd">find</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a> index_to_find) const</td></tr>
<tr class="memdesc:aa2d4b14865bd4f880b261777ea5dd7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the offset of <code>index_to_find</code> in *this.  <a href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#aa2d4b14865bd4f880b261777ea5dd7fd">More...</a><br /></td></tr>
<tr class="separator:aa2d4b14865bd4f880b261777ea5dd7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad88bf821540a38c854b0bf6c901c8903"><td class="memItemLeft" align="right" valign="top"><a id="ad88bf821540a38c854b0bf6c901c8903"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ad88bf821540a38c854b0bf6c901c8903">DummyIndices</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a499aeed44afc4cb5d466d8a74711a5f4">split_string_type</a> split_dummy_indices)</td></tr>
<tr class="memdesc:ad88bf821540a38c854b0bf6c901c8903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main ctor for setting the value, throws if any index is empty. <br /></td></tr>
<tr class="separator:ad88bf821540a38c854b0bf6c901c8903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2abb9719cca0bc1d48c8793d5dde00"><td class="memItemLeft" align="right" valign="top"><a id="a3e2abb9719cca0bc1d48c8793d5dde00"></a>
<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#afcb330cc0c92127a9c885c9b60e667b6">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a3e2abb9719cca0bc1d48c8793d5dde00">at_</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> i)</td></tr>
<tr class="memdesc:a3e2abb9719cca0bc1d48c8793d5dde00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements mutable element retrieval by forwarding to m_dummy indices_. <br /></td></tr>
<tr class="separator:a3e2abb9719cca0bc1d48c8793d5dde00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b525e9a1b90415fd7d7d98a179cd104"><td class="memItemLeft" align="right" valign="top"><a id="a5b525e9a1b90415fd7d7d98a179cd104"></a>
<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a5b525e9a1b90415fd7d7d98a179cd104">at_</a> (<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> i) const</td></tr>
<tr class="memdesc:a5b525e9a1b90415fd7d7d98a179cd104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements read-only element retrieval by forwarding to m_dummy indices_. <br /></td></tr>
<tr class="separator:a5b525e9a1b90415fd7d7d98a179cd104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e7f352f1873d8f1b6f19974baa1704"><td class="memItemLeft" align="right" valign="top"><a id="ac9e7f352f1873d8f1b6f19974baa1704"></a>
<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac9e7f352f1873d8f1b6f19974baa1704">size_</a> () const noexcept</td></tr>
<tr class="memdesc:ac9e7f352f1873d8f1b6f19974baa1704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements size by calling m_dummy indices_.size() <br /></td></tr>
<tr class="separator:ac9e7f352f1873d8f1b6f19974baa1704"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a42d5253d9f97cfbdb31dca92d456f64e"><td class="memItemLeft" align="right" valign="top"><a id="a42d5253d9f97cfbdb31dca92d456f64e"></a>
friend&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a42d5253d9f97cfbdb31dca92d456f64e">base_type</a></td></tr>
<tr class="memdesc:a42d5253d9f97cfbdb31dca92d456f64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets the base class get at these implementations. <br /></td></tr>
<tr class="separator:a42d5253d9f97cfbdb31dca92d456f64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename StringType&gt;<br />
class tensorwrapper::dsl::DummyIndices&lt; StringType &gt;</h3>

<p>Class to help deal with string-based dummy indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringType</td><td>The type used to hold the dummy indices.</td></tr>
  </table>
  </dd>
</dl>
<p>The DSL calls for the user to label each mode of a tensor (or shape, or buffer, or...) with a dummy index. This is usually done by providing a compile time literal like <code>"i,j,k"</code>, which would label the modes of a rank 3 tensor such that mode 0 is assigned dummy index <code>"i"</code>, mode 1 is assigned dummy index <code>"j"</code>, and mode 2 is assigned dummy index <code>"k"</code>. While strings are nice for the user, they're less nice for the developer. This class maps the string the user provided to an ordered sets of objects. The developer can then request common dummy index manipulations like set difference or permutation and let *this worry about the string manipulations.</p>
<p>This class defines the string to dummy index conventions used throughout the TensorWrapper library, namely:</p>
<ul>
<li>Dummy indices are separated by commas, i.e., <code>"i,jk,l"</code> defines three indices such that mode 0 is labeled by <code>"i"</code>, mode 1 by <code>"jk"</code>, and mode 2 by <code>"l"</code>.</li>
<li>Dummy indices can be multiple characters (see previous example)</li>
<li>Dummy indices are case-sensitive, i.e., <code>"i,J"</code> and <code>"i,j"</code> result in different dummy indices for mode 1.</li>
<li>Spaces are assumed to be for the user's clarity and are stripped prior to spliting i.e., <code>"i, j"</code> and <code>"i,j"</code> are the same set of indices. This also means <code>"my index,k"</code> will define a dummy index <code>"myindex"</code> for mode 0. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9fe08c3dd63065b6be315c618244d1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe08c3dd63065b6be315c618244d1d9">&#9670;&nbsp;</a></span>DummyIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object with no dummy indices. </p>
<p>Default constructed <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> objects behave like they contain the dummy indices for a scalar.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e50697d1d7ac2b59e9383494eaff3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e50697d1d7ac2b59e9383494eaff3c3">&#9670;&nbsp;</a></span>DummyIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::<a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a>&#160;</td>
          <td class="paramname"><em>dummy_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object by parsing a string. </p>
<p>We assume that <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> objects will be created directly from user input and that user input will be in a type implicitly convertible to <code>const_reference</code>. Under these assumptions, this ctor is the main user- facing ctor for the class. This ctor will first remove spaces in <code>dummy_indices</code> and then split the space-less string on commas. Finally, it will verify that the resulting vector of dummy indices has non-empty elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dummy_indices</td><td>The string used to initialize *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>dummy_indices</code> contains one or more commas and if after splitting on the commas one or more of the resulting dummy indices is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa2d4b14865bd4f880b261777ea5dd7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d4b14865bd4f880b261777ea5dd7fd">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#ac450f900ed5b1686a5b48e3bb03d564c">const_reference</a>&#160;</td>
          <td class="paramname"><em>index_to_find</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the offset of <code>index_to_find</code> in *this. </p>
<p>This method can be used to determine which modes the dummy index <code>index_to_find</code> maps to. If <code>index_to_find</code> does not appear in *this the result is empty. If <code>index_to_find</code> appears more than once the result will contain the offset for each appearance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index_to_find</td><td>The dummy index to determine the offset of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container whose elements are the offsets of <code>index_to_find</code> in *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1967c3a0f0ecb5a34fe3ea913d40d09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1967c3a0f0ecb5a34fe3ea913d40d09a">&#9670;&nbsp;</a></span>has_repeated_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::has_repeated_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does *this have repeated indices? </p>
<p>This method is used to determine if *this contains any index that appears more than once.</p>
<dl class="section return"><dt>Returns</dt><dd>True if *this contains a repeated index and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the internal call to <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a5cc5d9056ed0d7c8b37dfdbf6d7c19c6" title="Determines the number of unique indices in *this.">unique_index_size()</a> throws. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05338cd83a3d73acefdc630f3a7052ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05338cd83a3d73acefdc630f3a7052ad">&#9670;&nbsp;</a></span>permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a6025b21b588ec419842de250959259e3">offset_vector</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">DummyIndices</a>&lt; StringType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the permutation needed to convert *this into <code>other</code>. </p>
<p>Each <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> object is viewed as an ordered set of objects. If two <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html" title="Class to help deal with string-based dummy indices.">DummyIndices</a> objects contain the same objects, but in a different order, we can convert either object into the other by permuting it. This method computes the permutation needed to change *this into <code>other</code>. More specifically the result of this method is a vector of length <code>size()</code> such that the <code>i</code>-th element is the offset of <code>(*this)[i]</code> in <code>other</code>, i.e., if <code>x</code> is the return then <code>other[x[i]] == (*this)[i]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The order we want to permute *this to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector such that the i-th element is the offset of <code>(*this)[i]</code> in <code>other</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this and <code>other</code> do not have the same size, or if either *this or <code>other</code> have repeated indices, or if an index in *this does not appear in <code>other</code>. Strong throw guarantee in each case. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cc5d9056ed0d7c8b37dfdbf6d7c19c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc5d9056ed0d7c8b37dfdbf6d7c19c6">&#9670;&nbsp;</a></span>unique_index_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html#a57ee0818e5b85c1e291d965fa5b58a25">size_type</a> <a class="el" href="classtensorwrapper_1_1dsl_1_1DummyIndices.html">tensorwrapper::dsl::DummyIndices</a>&lt; StringType &gt;::unique_index_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of unique indices in *this. </p>
<p>A dummy index can be repeated if it is going to be summed over. This method analyzes the indices in *this and determines how many of them are unique.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of indices which appear only once in *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the temporary container can not be allocated. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tensorwrapper/dsl/<a class="el" href="dummy__indices_8hpp_source.html">dummy_indices.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
