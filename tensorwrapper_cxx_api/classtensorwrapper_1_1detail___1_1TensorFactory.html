<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::detail_::TensorFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">0.0.41</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetensorwrapper.html">tensorwrapper</a></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1detail__.html">detail_</a></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html">TensorFactory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classtensorwrapper_1_1detail___1_1TensorFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::detail_::TensorFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Object which helps create tensor objects.  
 <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tensor__factory_8hpp_source.html">tensor_factory.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abce3e31d7ddbdd503f9248fee94c3a7a"><td class="memItemLeft" align="right" valign="top"><a id="abce3e31d7ddbdd503f9248fee94c3a7a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#abce3e31d7ddbdd503f9248fee94c3a7a">tensor_type</a> = <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:abce3e31d7ddbdd503f9248fee94c3a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type this will create PIMPLs for. <br /></td></tr>
<tr class="separator:abce3e31d7ddbdd503f9248fee94c3a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e36a2a29d025e2dd56507cb4bc528d"><td class="memItemLeft" align="right" valign="top"><a id="ab3e36a2a29d025e2dd56507cb4bc528d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ab3e36a2a29d025e2dd56507cb4bc528d">input_type</a> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html">TensorInput</a></td></tr>
<tr class="memdesc:ab3e36a2a29d025e2dd56507cb4bc528d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to manage the myriad of possible inputs. <br /></td></tr>
<tr class="separator:ab3e36a2a29d025e2dd56507cb4bc528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5106718edcce3b88a13ccbecf247aae6"><td class="memItemLeft" align="right" valign="top"><a id="a5106718edcce3b88a13ccbecf247aae6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a5106718edcce3b88a13ccbecf247aae6">pimpl_type</a> = typename <a class="el" href="classtensorwrapper_1_1Tensor.html#a272fea9e213b7be56e8e4feab18b53da">tensor_type::pimpl_type</a></td></tr>
<tr class="memdesc:a5106718edcce3b88a13ccbecf247aae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type powering an object of type tensor_type. <br /></td></tr>
<tr class="separator:a5106718edcce3b88a13ccbecf247aae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e14d73deada521aed7ecfd7d18066f9"><td class="memItemLeft" align="right" valign="top"><a id="a8e14d73deada521aed7ecfd7d18066f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">pimpl_pointer</a> = typename <a class="el" href="classtensorwrapper_1_1Tensor.html#a761be2f8023866d6b4dbcffb69d419be">tensor_type::pimpl_pointer</a></td></tr>
<tr class="memdesc:a8e14d73deada521aed7ecfd7d18066f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to an object of type pimpl_type. <br /></td></tr>
<tr class="separator:a8e14d73deada521aed7ecfd7d18066f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf41273bcd62982129ea1fb5372c33e"><td class="memItemLeft" align="right" valign="top"><a id="a3bf41273bcd62982129ea1fb5372c33e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a3bf41273bcd62982129ea1fb5372c33e">scalar_il_type</a> = typename <a class="el" href="classtensorwrapper_1_1Tensor.html#a85929ca1bb93159d162dbc8ab8104d77">tensor_type::scalar_il_type</a></td></tr>
<tr class="memdesc:a3bf41273bcd62982129ea1fb5372c33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> is a scalar. <br /></td></tr>
<tr class="separator:a3bf41273bcd62982129ea1fb5372c33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb5a4c241ae0c9dab9bac63bdce12de"><td class="memItemLeft" align="right" valign="top"><a id="aadb5a4c241ae0c9dab9bac63bdce12de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aadb5a4c241ae0c9dab9bac63bdce12de">vector_il_type</a> = typename <a class="el" href="classtensorwrapper_1_1Tensor.html#a49549e657f4e223cfe7622f1b633e294">tensor_type::vector_il_type</a></td></tr>
<tr class="memdesc:aadb5a4c241ae0c9dab9bac63bdce12de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> is a vector. <br /></td></tr>
<tr class="separator:aadb5a4c241ae0c9dab9bac63bdce12de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c5e2b5afa0732aa8053375da487982"><td class="memItemLeft" align="right" valign="top"><a id="a71c5e2b5afa0732aa8053375da487982"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a71c5e2b5afa0732aa8053375da487982">matrix_il_type</a> = typename <a class="el" href="classtensorwrapper_1_1Tensor.html#acf0b6193c6ac4a8620bd0e477afc3c58">tensor_type::matrix_il_type</a></td></tr>
<tr class="memdesc:a71c5e2b5afa0732aa8053375da487982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> is a matrix. <br /></td></tr>
<tr class="separator:a71c5e2b5afa0732aa8053375da487982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dfc71f73f04982bdb78fac14b47311"><td class="memItemLeft" align="right" valign="top"><a id="a32dfc71f73f04982bdb78fac14b47311"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a32dfc71f73f04982bdb78fac14b47311">tensor3_il_type</a> = typename <a class="el" href="classtensorwrapper_1_1Tensor.html#a2ea66c7afb686eeab03b13f1791d4848">tensor_type::tensor3_il_type</a></td></tr>
<tr class="memdesc:a32dfc71f73f04982bdb78fac14b47311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> is a rank 3 tensor. <br /></td></tr>
<tr class="separator:a32dfc71f73f04982bdb78fac14b47311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded3f81ed032278b437d4e20b45d4199"><td class="memItemLeft" align="right" valign="top"><a id="aded3f81ed032278b437d4e20b45d4199"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aded3f81ed032278b437d4e20b45d4199">tensor4_il_type</a> = typename <a class="el" href="classtensorwrapper_1_1Tensor.html#aec53b217d9b03c0a4dafe6147dede129">tensor_type::tensor4_il_type</a></td></tr>
<tr class="memdesc:aded3f81ed032278b437d4e20b45d4199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> is a rank 4 tensor. <br /></td></tr>
<tr class="separator:aded3f81ed032278b437d4e20b45d4199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d586e77332fbb5898749efd40ee184"><td class="memItemLeft" align="right" valign="top"><a id="ae8d586e77332fbb5898749efd40ee184"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_shape_reference</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#af60941db8321bbbe81ab6e6164f91335">input_type::const_shape_reference</a></td></tr>
<tr class="separator:ae8d586e77332fbb5898749efd40ee184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92e31a67482913a0b7c70222f2b7314"><td class="memItemLeft" align="right" valign="top"><a id="aa92e31a67482913a0b7c70222f2b7314"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>shape_pointer</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a6bcaa5e84e14dd51497c3cf127db6695">input_type::shape_pointer</a></td></tr>
<tr class="separator:aa92e31a67482913a0b7c70222f2b7314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065344791db9cdee46aa31b34b4b6086"><td class="memItemLeft" align="right" valign="top"><a id="a065344791db9cdee46aa31b34b4b6086"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_symmetry_reference</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a37b18284f408e75e37c5baaee6b86a8f">input_type::const_symmetry_reference</a></td></tr>
<tr class="separator:a065344791db9cdee46aa31b34b4b6086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed50d837e6ba441287126a7310d16152"><td class="memItemLeft" align="right" valign="top"><a id="aed50d837e6ba441287126a7310d16152"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>symmetry_pointer</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#ab1050d85b5a333c68b5ebb9755bca72c">input_type::symmetry_pointer</a></td></tr>
<tr class="separator:aed50d837e6ba441287126a7310d16152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9696058adaa7c22a995a7dbed6854c0c"><td class="memItemLeft" align="right" valign="top"><a id="a9696058adaa7c22a995a7dbed6854c0c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_sparsity_reference</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#afd4a276abd7d81365fb3091e031661bb">input_type::const_sparsity_reference</a></td></tr>
<tr class="separator:a9696058adaa7c22a995a7dbed6854c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80b67dda10bdbdcb27f2056ee805e03"><td class="memItemLeft" align="right" valign="top"><a id="ae80b67dda10bdbdcb27f2056ee805e03"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>sparsity_pointer</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#aad366fd1de70429ace06c3d221a57415">input_type::sparsity_pointer</a></td></tr>
<tr class="separator:ae80b67dda10bdbdcb27f2056ee805e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bddf924e7274f917713f5ee8683a1f"><td class="memItemLeft" align="right" valign="top"><a id="af4bddf924e7274f917713f5ee8683a1f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_logical_reference</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a68c18d210e3f26d574fb76b477189945">input_type::const_logical_reference</a></td></tr>
<tr class="separator:af4bddf924e7274f917713f5ee8683a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c19d5966261b7b2ca5222d85d0cb6"><td class="memItemLeft" align="right" valign="top"><a id="aa99c19d5966261b7b2ca5222d85d0cb6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>logical_layout_pointer</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#aa7081ea44dacf0d8b5d59acc668bf82f">input_type::logical_layout_pointer</a></td></tr>
<tr class="separator:aa99c19d5966261b7b2ca5222d85d0cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c12b8528e798251f28cccbcbeede41b"><td class="memItemLeft" align="right" valign="top"><a id="a6c12b8528e798251f28cccbcbeede41b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_physical_reference</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a2939acd15d8580ae2d0d5b3dc73c2b40">input_type::const_physical_reference</a></td></tr>
<tr class="separator:a6c12b8528e798251f28cccbcbeede41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0f3804c3b09aa357020a346c4ffeb2"><td class="memItemLeft" align="right" valign="top"><a id="afd0f3804c3b09aa357020a346c4ffeb2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>physical_layout_pointer</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a15d4dada36b1c63440c9e56fdf0da8ef">input_type::physical_layout_pointer</a></td></tr>
<tr class="separator:afd0f3804c3b09aa357020a346c4ffeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d679c629a4ebe67f1233adf13bb697"><td class="memItemLeft" align="right" valign="top"><a id="a23d679c629a4ebe67f1233adf13bb697"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_pointer</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a3d1c2bdf9391585e8bba1362755b4762">input_type::allocator_pointer</a></td></tr>
<tr class="separator:a23d679c629a4ebe67f1233adf13bb697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4588eb7628a942faefccfb57b9375197"><td class="memItemLeft" align="right" valign="top"><a id="a4588eb7628a942faefccfb57b9375197"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>runtime_view_type</b> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a1bdb6fd8f064ef8e99948dae219e67dc">input_type::runtime_view_type</a></td></tr>
<tr class="separator:a4588eb7628a942faefccfb57b9375197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa44adf47c336864ae3bc56c05db76c5a"><td class="memItemLeft" align="right" valign="top">static symmetry_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aa44adf47c336864ae3bc56c05db76c5a">default_logical_symmetry</a> (const_shape_reference shape)</td></tr>
<tr class="memdesc:aa44adf47c336864ae3bc56c05db76c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines a default logical symmetry for <code>shape</code>.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aa44adf47c336864ae3bc56c05db76c5a">More...</a><br /></td></tr>
<tr class="separator:aa44adf47c336864ae3bc56c05db76c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dea343bc661b15fe959531467dbd271"><td class="memItemLeft" align="right" valign="top">static sparsity_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a6dea343bc661b15fe959531467dbd271">default_logical_sparsity</a> (const_shape_reference shape, const_symmetry_reference symmetry)</td></tr>
<tr class="memdesc:a6dea343bc661b15fe959531467dbd271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a default sparsity from the shape and symmetry.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a6dea343bc661b15fe959531467dbd271">More...</a><br /></td></tr>
<tr class="separator:a6dea343bc661b15fe959531467dbd271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad0148b7084815512bce51ebf89dd91"><td class="memItemLeft" align="right" valign="top">static logical_layout_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aaad0148b7084815512bce51ebf89dd91">default_logical_layout</a> (shape_pointer shape, symmetry_pointer symmetry, sparsity_pointer sparsity)</td></tr>
<tr class="memdesc:aaad0148b7084815512bce51ebf89dd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the tensor's default logical layout.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aaad0148b7084815512bce51ebf89dd91">More...</a><br /></td></tr>
<tr class="separator:aaad0148b7084815512bce51ebf89dd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1807b1096cd36c042bbf5e91c1eba79"><td class="memItemLeft" align="right" valign="top">static physical_layout_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ad1807b1096cd36c042bbf5e91c1eba79">default_physical_layout</a> (<a class="el" href="classtensorwrapper_1_1layout_1_1Logical.html">const_logical_reference</a> logical)</td></tr>
<tr class="memdesc:ad1807b1096cd36c042bbf5e91c1eba79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct's the tensor's default physical layout.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ad1807b1096cd36c042bbf5e91c1eba79">More...</a><br /></td></tr>
<tr class="separator:ad1807b1096cd36c042bbf5e91c1eba79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bb8e1248e3589e9350a6065f1e83fc"><td class="memItemLeft" align="right" valign="top">static allocator_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#af3bb8e1248e3589e9350a6065f1e83fc">default_allocator</a> (<a class="el" href="classtensorwrapper_1_1layout_1_1Physical.html">const_physical_reference</a> physical, runtime_view_type rv)</td></tr>
<tr class="memdesc:af3bb8e1248e3589e9350a6065f1e83fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an allocator consistent with the physical layout.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#af3bb8e1248e3589e9350a6065f1e83fc">More...</a><br /></td></tr>
<tr class="separator:af3bb8e1248e3589e9350a6065f1e83fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e58f1c0fa1724fb07ae084f141a441f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">pimpl_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e58f1c0fa1724fb07ae084f141a441f">construct</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ab3e36a2a29d025e2dd56507cb4bc528d">input_type</a> input)</td></tr>
<tr class="memdesc:a8e58f1c0fa1724fb07ae084f141a441f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually constructs the tensor's PIMPL.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e58f1c0fa1724fb07ae084f141a441f">More...</a><br /></td></tr>
<tr class="separator:a8e58f1c0fa1724fb07ae084f141a441f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad533e483fcf260b635d3c7dd25af9372"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ad533e483fcf260b635d3c7dd25af9372">can_make_logical_layout</a> (const <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ab3e36a2a29d025e2dd56507cb4bc528d">input_type</a> &amp;input) noexcept</td></tr>
<tr class="memdesc:ad533e483fcf260b635d3c7dd25af9372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <code>input</code> contain sufficient information in order for *this to make a logical layout?  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ad533e483fcf260b635d3c7dd25af9372">More...</a><br /></td></tr>
<tr class="separator:ad533e483fcf260b635d3c7dd25af9372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83a91c613e7d9b22d1682ef9098453d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#af83a91c613e7d9b22d1682ef9098453d">assert_valid</a> (const <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ab3e36a2a29d025e2dd56507cb4bc528d">input_type</a> &amp;input)</td></tr>
<tr class="memdesc:af83a91c613e7d9b22d1682ef9098453d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws if <code>input</code> has been constructed in an invalid state.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#af83a91c613e7d9b22d1682ef9098453d">More...</a><br /></td></tr>
<tr class="separator:af83a91c613e7d9b22d1682ef9098453d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa26a25de4fc66cc34f91f1851d2d7e66"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">pimpl_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aa26a25de4fc66cc34f91f1851d2d7e66">construct</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a3bf41273bcd62982129ea1fb5372c33e">scalar_il_type</a> il)</td></tr>
<tr class="memdesc:aa26a25de4fc66cc34f91f1851d2d7e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor from a (possibly) nested initializer list.  <a href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aa26a25de4fc66cc34f91f1851d2d7e66">More...</a><br /></td></tr>
<tr class="separator:aa26a25de4fc66cc34f91f1851d2d7e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892938513fd4d235f14a968c94424ff6"><td class="memItemLeft" align="right" valign="top"><a id="a892938513fd4d235f14a968c94424ff6"></a>
static <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">pimpl_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>construct</b> (<a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aadb5a4c241ae0c9dab9bac63bdce12de">vector_il_type</a> il)</td></tr>
<tr class="separator:a892938513fd4d235f14a968c94424ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8210410676c1d3a317d91bf4a8cfdab"><td class="memItemLeft" align="right" valign="top"><a id="ad8210410676c1d3a317d91bf4a8cfdab"></a>
static <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">pimpl_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>construct</b> (<a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a71c5e2b5afa0732aa8053375da487982">matrix_il_type</a> il)</td></tr>
<tr class="separator:ad8210410676c1d3a317d91bf4a8cfdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ed9374131d56f8bcb919dafca4b219"><td class="memItemLeft" align="right" valign="top"><a id="ad3ed9374131d56f8bcb919dafca4b219"></a>
static <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">pimpl_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>construct</b> (<a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a32dfc71f73f04982bdb78fac14b47311">tensor3_il_type</a> il)</td></tr>
<tr class="separator:ad3ed9374131d56f8bcb919dafca4b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8255f90dd12295e39da5af6a69a066"><td class="memItemLeft" align="right" valign="top"><a id="acf8255f90dd12295e39da5af6a69a066"></a>
static <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">pimpl_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>construct</b> (<a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#aded3f81ed032278b437d4e20b45d4199">tensor4_il_type</a> il)</td></tr>
<tr class="separator:acf8255f90dd12295e39da5af6a69a066"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Object which helps create tensor objects. </p>
<p>Ultimately there are going to be a lot of possible ways to create a tensor. In an effort to keep the <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a>'s ctors as simple as possible we have decoupled the set of all possible inputs into the <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html" title="Type capable of holding all valid inputs to a Tensor&#39;s ctor.">TensorInput</a> class and the set of all possible initialization methods into the <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html" title="Object which helps create tensor objects.">TensorFactory</a> class. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af83a91c613e7d9b22d1682ef9098453d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83a91c613e7d9b22d1682ef9098453d">&#9670;&nbsp;</a></span>assert_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tensorwrapper::detail_::TensorFactory::assert_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ab3e36a2a29d025e2dd56507cb4bc528d">input_type</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws if <code>input</code> has been constructed in an invalid state. </p>
<p>Assuming <code>input</code> manages <img class="formulaInl" alt="$N$" src="form_4.png"/> inputs there are <img class="formulaInl" alt="$2^N$" src="form_5.png"/> possible states for <code>input</code> just considering whether each pointer is null or not. While *this is capable of working out defaults for some inputs, this is not true for all inputs. For example, there is no way for *this to work out the logical shape of a tensor given only its logical symmetry. The goal of this method is to wrap the process of determining whether or not <code>construct</code> has a chance of succeeding before we start constructing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input we are error-checking.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>input</code> has been constructed in an invalid state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad533e483fcf260b635d3c7dd25af9372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad533e483fcf260b635d3c7dd25af9372">&#9670;&nbsp;</a></span>can_make_logical_layout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tensorwrapper::detail_::TensorFactory::can_make_logical_layout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ab3e36a2a29d025e2dd56507cb4bc528d">input_type</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does <code>input</code> contain sufficient information in order for *this to make a logical layout? </p>
<p>At present *this can make a logical layout given at least a shape. It also can trivially make a logical layout if it is given a logical layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The inputs we are inspecting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>input</code> contains sufficient information to create a logical layout and false otherwise. </dd></dl>

</div>
</div>
<a id="a8e58f1c0fa1724fb07ae084f141a441f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e58f1c0fa1724fb07ae084f141a441f">&#9670;&nbsp;</a></span>construct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">pimpl_pointer</a> tensorwrapper::detail_::TensorFactory::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#ab3e36a2a29d025e2dd56507cb4bc528d">input_type</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actually constructs the tensor's PIMPL. </p>
<p>This is the main entry point into this class (and is what callers should use). Since this class is not user-facing we have opted to have all methods be public (to assist with unit testing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The objects the user wants us to use to construct the tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>input</code> is not in a valid state. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa26a25de4fc66cc34f91f1851d2d7e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26a25de4fc66cc34f91f1851d2d7e66">&#9670;&nbsp;</a></span>construct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a8e14d73deada521aed7ecfd7d18066f9">pimpl_pointer</a> tensorwrapper::detail_::TensorFactory::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html#a3bf41273bcd62982129ea1fb5372c33e">scalar_il_type</a>&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor from a (possibly) nested initializer list. </p>
<p>These methods implement the corresponding methods on the <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> class. see the description there for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>A (possibly) nested initializer list containing the initial values for the tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pimpl containing a tensor consistent with <code>il</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3bb8e1248e3589e9350a6065f1e83fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bb8e1248e3589e9350a6065f1e83fc">&#9670;&nbsp;</a></span>default_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_pointer tensorwrapper::detail_::TensorFactory::default_allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1layout_1_1Physical.html">const_physical_reference</a>&#160;</td>
          <td class="paramname"><em>physical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">runtime_view_type&#160;</td>
          <td class="paramname"><em>rv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an allocator consistent with the physical layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physical</td><td>The physical layout of the tensor we want to allocate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rv</td><td>The runtime that tensors will be allocated in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An allocator capable of allocating a tensor with the layout <code>physical</code> using the resources in <code>rv</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaad0148b7084815512bce51ebf89dd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad0148b7084815512bce51ebf89dd91">&#9670;&nbsp;</a></span>default_logical_layout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">logical_layout_pointer tensorwrapper::detail_::TensorFactory::default_logical_layout </td>
          <td>(</td>
          <td class="paramtype">shape_pointer&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">symmetry_pointer&#160;</td>
          <td class="paramname"><em>symmetry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sparsity_pointer&#160;</td>
          <td class="paramname"><em>sparsity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the tensor's default logical layout. </p>
<p>Logical layouts are simply wrappers around the shape, symmetry, and sparsity. This method simply forwards the inputs to the new layout object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The tensor's logical shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmetry</td><td>The tensor's logical symmetry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sparsity</td><td>The tensor's logical sparsity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor's logical layout.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dea343bc661b15fe959531467dbd271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dea343bc661b15fe959531467dbd271">&#9670;&nbsp;</a></span>default_logical_sparsity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparsity_pointer tensorwrapper::detail_::TensorFactory::default_logical_sparsity </td>
          <td>(</td>
          <td class="paramtype">const_shape_reference&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_symmetry_reference&#160;</td>
          <td class="paramname"><em>symmetry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a default sparsity from the shape and symmetry. </p>
<p>At present sparsity is a stub class and this function simply returns a default constructed instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The tensor's logical shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symmetry</td><td>The tensor's logical symmetry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor's logical sparsity.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the new group. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa44adf47c336864ae3bc56c05db76c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44adf47c336864ae3bc56c05db76c5a">&#9670;&nbsp;</a></span>default_logical_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">symmetry_pointer tensorwrapper::detail_::TensorFactory::default_logical_symmetry </td>
          <td>(</td>
          <td class="paramtype">const_shape_reference&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines a default logical symmetry for <code>shape</code>. </p>
<p>Given <code>shape</code> this method is charged with determining a corresponding default symmetry. Without access to the elements there is no way *this can actually determine the full symmetry and thus this method always returns a default constructed symmetry group, i.e., the resulting tensor will have no symmetry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The shape to compute the symmetry of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetry group for a tensor with no symmetry.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the new group. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1807b1096cd36c042bbf5e91c1eba79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1807b1096cd36c042bbf5e91c1eba79">&#9670;&nbsp;</a></span>default_physical_layout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">physical_layout_pointer tensorwrapper::detail_::TensorFactory::default_physical_layout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1layout_1_1Logical.html">const_logical_reference</a>&#160;</td>
          <td class="paramname"><em>logical</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct's the tensor's default physical layout. </p>
<p>At present the default physical layout for a tensor is the same as its logical layout. Eventually this should take runtime conditions into account.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">logical</td><td>The logical layout of the tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The default physical layout for the tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/tensorwrapper/tensor/detail_/<a class="el" href="tensor__factory_8hpp_source.html">tensor_factory.hpp</a></li>
<li>src/tensorwrapper/tensor/detail_/tensor_factory.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
