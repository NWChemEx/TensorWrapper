<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::tensor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorwrapper</b></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1tensor.html">tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::tensor Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Forward declare the <a class="el" href="structtensorwrapper_1_1tensor_1_1Conversion.html" title="Dispatches to the correct conversion function based on the desired output type of the wrapped tensor.">Conversion</a> class.  
<a href="namespacetensorwrapper_1_1tensor.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Allocator.html">Allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstracts away the details of how the <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>'s internal tensor is formed.  <a href="classtensorwrapper_1_1tensor_1_1Allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1tensor_1_1Conversion.html">Conversion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches to the correct conversion function based on the desired output type of the wrapped tensor.  <a href="structtensorwrapper_1_1tensor_1_1Conversion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1tensor_1_1Conversion_3_01TA_1_1DistArray_3_01TileType_00_01TA_1_1SparsePolicy_01_4_01_4.html">Conversion&lt; TA::DistArray&lt; TileType, TA::SparsePolicy &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for DistArray conversion cases.  <a href="structtensorwrapper_1_1tensor_1_1Conversion_3_01TA_1_1DistArray_3_01TileType_00_01TA_1_1SparsePolicy_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1tensor_1_1NDInitializerListTraits.html">NDInitializerListTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for an <code>N</code> -dimensional initializer list of type <code>T</code>.  <a href="structtensorwrapper_1_1tensor_1_1NDInitializerListTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1tensor_1_1NDInitializerListTraits_3_01T_00_010ul_01_4.html">NDInitializerListTraits&lt; T, 0ul &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structtensorwrapper_1_1tensor_1_1NDInitializerListTraits.html" title="Traits class for an N -dimensional initializer list of type T.">NDInitializerListTraits</a> for a rank 0 tensor.  <a href="structtensorwrapper_1_1tensor_1_1NDInitializerListTraits_3_01T_00_010ul_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1OneBigTile.html">OneBigTile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtensorwrapper_1_1tensor_1_1Allocator.html" title="Abstracts away the details of how the TensorWrapper&#39;s internal tensor is formed.">Allocator</a> which puts all the elements in one big tile.  <a href="classtensorwrapper_1_1tensor_1_1OneBigTile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object describing a tensor's elemental layout.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SingleElementTiles.html">SingleElementTiles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator where every tile is a single element.  <a href="classtensorwrapper_1_1tensor_1_1SingleElementTiles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a tensor's shape when there's sparsity.  <a href="classtensorwrapper_1_1tensor_1_1SparseShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1tensor_1_1TensorTraits.html">TensorTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for determining the types associated with a tensor type.  <a href="structtensorwrapper_1_1tensor_1_1TensorTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1tensor_1_1TensorTraits_3_01const_01TA_1_1DistArray_3_01TileType_00_01PolicyType_01_4_01_4.html">TensorTraits&lt; const TA::DistArray&lt; TileType, PolicyType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <a class="el" href="structtensorwrapper_1_1tensor_1_1TensorTraits.html" title="Primary template for determining the types associated with a tensor type.">TensorTraits</a> for a TiledArray tensor.  <a href="structtensorwrapper_1_1tensor_1_1TensorTraits_3_01const_01TA_1_1DistArray_3_01TileType_00_01PolicyType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorwrapper_1_1tensor_1_1TensorTraits_3_01TA_1_1DistArray_3_01TileType_00_01PolicyType_01_4_01_4.html">TensorTraits&lt; TA::DistArray&lt; TileType, PolicyType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <a class="el" href="structtensorwrapper_1_1tensor_1_1TensorTraits.html" title="Primary template for determining the types associated with a tensor type.">TensorTraits</a> for a TiledArray tensor.  <a href="structtensorwrapper_1_1tensor_1_1TensorTraits_3_01TA_1_1DistArray_3_01TileType_00_01PolicyType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental type for wrapping tensors.  <a href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a10de54c1ebc0b59e56f70f600375f0d9"><td class="memItemLeft" align="right" valign="top"><a id="a10de54c1ebc0b59e56f70f600375f0d9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ta_tensor_type</b> = <a class="el" href="structtensorwrapper_1_1tensor_1_1backends_1_1TiledArrayTraits.html">backends::TiledArrayTraits</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt;::tensor_type&lt; double &gt;</td></tr>
<tr class="separator:a10de54c1ebc0b59e56f70f600375f0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c9d45a14c58ef5d93f6d03784f703"><td class="memItemLeft" align="right" valign="top"><a id="a3c5c9d45a14c58ef5d93f6d03784f703"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ta_tot_type</b> = <a class="el" href="structtensorwrapper_1_1tensor_1_1backends_1_1TiledArrayTraits.html">backends::TiledArrayTraits</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html">field::Tensor</a> &gt;::tensor_type&lt; double &gt;</td></tr>
<tr class="separator:a3c5c9d45a14c58ef5d93f6d03784f703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc0724f027b166d635687a169a115e8"><td class="memItemLeft" align="right" valign="top"><a id="aabc0724f027b166d635687a169a115e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> = <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a></td></tr>
<tr class="separator:aabc0724f027b166d635687a169a115e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefd997b2582509f675e571d8736e334"><td class="memItemLeft" align="right" valign="top"><a id="adefd997b2582509f675e571d8736e334"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TWrapper</b> = <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a></td></tr>
<tr class="separator:adefd997b2582509f675e571d8736e334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc0ec277e31c6f425fa0167ae784337"><td class="memTemplParams" colspan="2"><a id="aedc0ec277e31c6f425fa0167ae784337"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedc0ec277e31c6f425fa0167ae784337"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pimpl_type</b> = <a class="el" href="classtensorwrapper_1_1tensor_1_1detail___1_1SparseShapePIMPL.html">detail_::SparseShapePIMPL</a>&lt; T &gt;</td></tr>
<tr class="separator:aedc0ec277e31c6f425fa0167ae784337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0ce0a7735248f1ecafb9c60730d7d3"><td class="memItemLeft" align="right" valign="top"><a id="adb0ce0a7735248f1ecafb9c60730d7d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarTensorWrapper</b> = <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt;</td></tr>
<tr class="separator:adb0ce0a7735248f1ecafb9c60730d7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f5668918147fddb8192dc53486fca8"><td class="memItemLeft" align="right" valign="top"><a id="a59f5668918147fddb8192dc53486fca8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TensorOfTensorsWrapper</b> = <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html">field::Tensor</a> &gt;</td></tr>
<tr class="separator:a59f5668918147fddb8192dc53486fca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188d69e14ed295ed4c217277cf5e102f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = void&gt; </td></tr>
<tr class="memitem:a188d69e14ed295ed4c217277cf5e102f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a188d69e14ed295ed4c217277cf5e102f">enable_if_expression_t</a> = std::enable_if_t&lt; is_expression_v&lt; T &gt;, U &gt;</td></tr>
<tr class="memdesc:a188d69e14ed295ed4c217277cf5e102f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to enable a function via SFINAE when <code>T</code> is part of the expression layer.  <a href="namespacetensorwrapper_1_1tensor.html#a188d69e14ed295ed4c217277cf5e102f">More...</a><br /></td></tr>
<tr class="separator:a188d69e14ed295ed4c217277cf5e102f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba797881c277898dca86d419a0951a5b"><td class="memTemplParams" colspan="2">template&lt;typename TensorVariant &gt; </td></tr>
<tr class="memitem:aba797881c277898dca86d419a0951a5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#aba797881c277898dca86d419a0951a5b">labeled_variant_t</a> = typename <a class="el" href="structtensorwrapper_1_1tensor_1_1detail___1_1LabeledVariant.html">detail_::LabeledVariant</a>&lt; TensorVariant &gt;::type</td></tr>
<tr class="memdesc:aba797881c277898dca86d419a0951a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public API for getting a variant of labeled tensors.  <a href="namespacetensorwrapper_1_1tensor.html#aba797881c277898dca86d419a0951a5b">More...</a><br /></td></tr>
<tr class="separator:aba797881c277898dca86d419a0951a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50ac1f1c0854632ca823661c10c2e6b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ac50ac1f1c0854632ca823661c10c2e6b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#ac50ac1f1c0854632ca823661c10c2e6b">n_d_initializer_list_t</a> = typename <a class="el" href="structtensorwrapper_1_1tensor_1_1NDInitializerListTraits.html">NDInitializerListTraits</a>&lt; T, N &gt;::type</td></tr>
<tr class="memdesc:ac50ac1f1c0854632ca823661c10c2e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef of the initializer_list for a rank <code>N</code> tensor of scalars of type <code>T</code>.  <a href="namespacetensorwrapper_1_1tensor.html#ac50ac1f1c0854632ca823661c10c2e6b">More...</a><br /></td></tr>
<tr class="separator:ac50ac1f1c0854632ca823661c10c2e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082bf5bdce3f92c475065107fae62e4a"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:a082bf5bdce3f92c475065107fae62e4a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a082bf5bdce3f92c475065107fae62e4a">add_expr_t</a> = decltype(std::declval&lt; LType &gt;()+std::declval&lt; RType &gt;())</td></tr>
<tr class="memdesc:a082bf5bdce3f92c475065107fae62e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the type that results from adding two tensors together.  <a href="namespacetensorwrapper_1_1tensor.html#a082bf5bdce3f92c475065107fae62e4a">More...</a><br /></td></tr>
<tr class="separator:a082bf5bdce3f92c475065107fae62e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c7661c7365464aad167bcc57da35ae"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:ac6c7661c7365464aad167bcc57da35ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#ac6c7661c7365464aad167bcc57da35ae">subt_expr_t</a> = decltype(std::declval&lt; LType &gt;() - std::declval&lt; RType &gt;())</td></tr>
<tr class="memdesc:ac6c7661c7365464aad167bcc57da35ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the type that results from subtracting two tensors.  <a href="namespacetensorwrapper_1_1tensor.html#ac6c7661c7365464aad167bcc57da35ae">More...</a><br /></td></tr>
<tr class="separator:ac6c7661c7365464aad167bcc57da35ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa7d1d7864d1c8286f064c73fe522fd"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:abfa7d1d7864d1c8286f064c73fe522fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#abfa7d1d7864d1c8286f064c73fe522fd">mult_expr_t</a> = decltype(std::declval&lt; LType &gt;() *std::declval&lt; RType &gt;())</td></tr>
<tr class="memdesc:abfa7d1d7864d1c8286f064c73fe522fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the type that results from multiplying two tensors together.  <a href="namespacetensorwrapper_1_1tensor.html#abfa7d1d7864d1c8286f064c73fe522fd">More...</a><br /></td></tr>
<tr class="separator:abfa7d1d7864d1c8286f064c73fe522fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aad99a77f261567382e195b696d1315"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:a8aad99a77f261567382e195b696d1315"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a8aad99a77f261567382e195b696d1315">add_variant_t</a> = utilities::type_traits::variant::product_t&lt; <a class="el" href="namespacetensorwrapper_1_1tensor.html#a082bf5bdce3f92c475065107fae62e4a">add_expr_t</a>, LType, RType &gt;</td></tr>
<tr class="memdesc:a8aad99a77f261567382e195b696d1315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of a variant resulting from adding two variants together.  <a href="namespacetensorwrapper_1_1tensor.html#a8aad99a77f261567382e195b696d1315">More...</a><br /></td></tr>
<tr class="separator:a8aad99a77f261567382e195b696d1315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d82cad5a785c88c23c8de1f361e8d6"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:aa8d82cad5a785c88c23c8de1f361e8d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#aa8d82cad5a785c88c23c8de1f361e8d6">subt_variant_t</a> = utilities::type_traits::variant::product_t&lt; <a class="el" href="namespacetensorwrapper_1_1tensor.html#ac6c7661c7365464aad167bcc57da35ae">subt_expr_t</a>, LType, RType &gt;</td></tr>
<tr class="memdesc:aa8d82cad5a785c88c23c8de1f361e8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of a variant resulting from subtracting two variants.  <a href="namespacetensorwrapper_1_1tensor.html#aa8d82cad5a785c88c23c8de1f361e8d6">More...</a><br /></td></tr>
<tr class="separator:aa8d82cad5a785c88c23c8de1f361e8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf6847e15b44694cbbcf24ed2ef00c"><td class="memTemplParams" colspan="2">template&lt;typename LType , typename RType &gt; </td></tr>
<tr class="memitem:aacaf6847e15b44694cbbcf24ed2ef00c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#aacaf6847e15b44694cbbcf24ed2ef00c">mult_variant_t</a> = utilities::type_traits::variant::product_t&lt; <a class="el" href="namespacetensorwrapper_1_1tensor.html#abfa7d1d7864d1c8286f064c73fe522fd">mult_expr_t</a>, LType, RType &gt;</td></tr>
<tr class="memdesc:aacaf6847e15b44694cbbcf24ed2ef00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of a variant resulting from multiplying two variants together.  <a href="namespacetensorwrapper_1_1tensor.html#aacaf6847e15b44694cbbcf24ed2ef00c">More...</a><br /></td></tr>
<tr class="separator:aacaf6847e15b44694cbbcf24ed2ef00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af227ab63923553cb396011c0cc699cb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af227ab63923553cb396011c0cc699cb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#af227ab63923553cb396011c0cc699cb2">variant_type_t</a> = typename <a class="el" href="structtensorwrapper_1_1tensor_1_1detail___1_1VariantType.html">detail_::VariantType</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:af227ab63923553cb396011c0cc699cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public API for determining the variant type of a <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>.  <a href="namespacetensorwrapper_1_1tensor.html#af227ab63923553cb396011c0cc699cb2">More...</a><br /></td></tr>
<tr class="separator:af227ab63923553cb396011c0cc699cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a22d3e8a517f61fed6aa39633ecfbb5ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a22d3e8a517f61fed6aa39633ecfbb5ef">allclose</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;actual, const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;ref, double rtol=1.0E-5, double atol=1.0E-8)</td></tr>
<tr class="memdesc:a22d3e8a517f61fed6aa39633ecfbb5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instances for closeness.  <a href="namespacetensorwrapper_1_1tensor.html#a22d3e8a517f61fed6aa39633ecfbb5ef">More...</a><br /></td></tr>
<tr class="separator:a22d3e8a517f61fed6aa39633ecfbb5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea8bb0257e016416d3c643df10ff511"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a4ea8bb0257e016416d3c643df10ff511">abs_allclose</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;actual, const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;ref, double rtol=1.0E-5, double atol=1.0E-8)</td></tr>
<tr class="memdesc:a4ea8bb0257e016416d3c643df10ff511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as allclose, except comparisons are done with unsigned elements.  <a href="namespacetensorwrapper_1_1tensor.html#a4ea8bb0257e016416d3c643df10ff511">More...</a><br /></td></tr>
<tr class="separator:a4ea8bb0257e016416d3c643df10ff511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45e86f816a8abfef42521998b1f5731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#ae45e86f816a8abfef42521998b1f5731">apply_elementwise</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;input, const std::function&lt; double(double)&gt; &amp;fxn)</td></tr>
<tr class="memdesc:ae45e86f816a8abfef42521998b1f5731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new tensor by applying a function elementwise to an existing tensor.  <a href="namespacetensorwrapper_1_1tensor.html#ae45e86f816a8abfef42521998b1f5731">More...</a><br /></td></tr>
<tr class="separator:ae45e86f816a8abfef42521998b1f5731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0377ab77c6d6ba5ca40b44412aaa26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a8b0377ab77c6d6ba5ca40b44412aaa26">apply_elementwise_inplace</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;input, const std::function&lt; void(double &amp;)&gt; &amp;fxn)</td></tr>
<tr class="memdesc:a8b0377ab77c6d6ba5ca40b44412aaa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies an existing tensor by applying a function elementwise to its values.  <a href="namespacetensorwrapper_1_1tensor.html#a8b0377ab77c6d6ba5ca40b44412aaa26">More...</a><br /></td></tr>
<tr class="separator:a8b0377ab77c6d6ba5ca40b44412aaa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab383a298714a0ccc29890a9935a16c38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#ab383a298714a0ccc29890a9935a16c38">to_contiguous_buffer</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;t, double *buffer_begin, const double *buffer_end)</td></tr>
<tr class="memdesc:ab383a298714a0ccc29890a9935a16c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens a tensor out into a contiguous buffer.  <a href="namespacetensorwrapper_1_1tensor.html#ab383a298714a0ccc29890a9935a16c38">More...</a><br /></td></tr>
<tr class="separator:ab383a298714a0ccc29890a9935a16c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0fa50760ae41be159cae427ea12f81"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a0d0fa50760ae41be159cae427ea12f81">to_vector</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;t)</td></tr>
<tr class="memdesc:a0d0fa50760ae41be159cae427ea12f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens a tensor out into an std::vector.  <a href="namespacetensorwrapper_1_1tensor.html#a0d0fa50760ae41be159cae427ea12f81">More...</a><br /></td></tr>
<tr class="separator:a0d0fa50760ae41be159cae427ea12f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0181c79745c39845d6018404c5ff1166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a0181c79745c39845d6018404c5ff1166">wrap_std_vector</a> (std::vector&lt; double &gt; v)</td></tr>
<tr class="memdesc:a0181c79745c39845d6018404c5ff1166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a std::vector into a 1D ScalarTensorWrapper.  <a href="namespacetensorwrapper_1_1tensor.html#a0181c79745c39845d6018404c5ff1166">More...</a><br /></td></tr>
<tr class="separator:a0181c79745c39845d6018404c5ff1166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c277d8c6b1e7088e302dcba5469c2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#aa9c277d8c6b1e7088e302dcba5469c2e">concatenate</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;lhs, const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;rhs, std::size_t dim)</td></tr>
<tr class="memdesc:aa9c277d8c6b1e7088e302dcba5469c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatentaes two tensors together along the specified dimension.  <a href="namespacetensorwrapper_1_1tensor.html#aa9c277d8c6b1e7088e302dcba5469c2e">More...</a><br /></td></tr>
<tr class="separator:aa9c277d8c6b1e7088e302dcba5469c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad017e1a20eaf2b0f4c8514f01efeb9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#ad017e1a20eaf2b0f4c8514f01efeb9fb">grab_diagonal</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;t)</td></tr>
<tr class="memdesc:ad017e1a20eaf2b0f4c8514f01efeb9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the diagonal of a matrix and returns it as a vector.  <a href="namespacetensorwrapper_1_1tensor.html#ad017e1a20eaf2b0f4c8514f01efeb9fb">More...</a><br /></td></tr>
<tr class="separator:ad017e1a20eaf2b0f4c8514f01efeb9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57619cbf160f98bb1531bdfb627fd77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a57619cbf160f98bb1531bdfb627fd77a">diagonal_tensor_wrapper</a> (double val, const <a class="el" href="classtensorwrapper_1_1tensor_1_1Allocator.html">Allocator</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &amp;allocator, const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &amp;shape)</td></tr>
<tr class="memdesc:a57619cbf160f98bb1531bdfb627fd77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a new <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> with the given value along its diagonal.  <a href="namespacetensorwrapper_1_1tensor.html#a57619cbf160f98bb1531bdfb627fd77a">More...</a><br /></td></tr>
<tr class="separator:a57619cbf160f98bb1531bdfb627fd77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d2d9e0172f0a3e9c31828c2031ab53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#ab5d2d9e0172f0a3e9c31828c2031ab53">diagonal_tensor_wrapper</a> (std::vector&lt; double &gt; vals, const <a class="el" href="classtensorwrapper_1_1tensor_1_1Allocator.html">Allocator</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &amp;allocator, const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &amp;shape)</td></tr>
<tr class="memdesc:ab5d2d9e0172f0a3e9c31828c2031ab53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a new <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> with the given values along its diagonal.  <a href="namespacetensorwrapper_1_1tensor.html#ab5d2d9e0172f0a3e9c31828c2031ab53">More...</a><br /></td></tr>
<tr class="separator:ab5d2d9e0172f0a3e9c31828c2031ab53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913cacafad15e2d225d25d97d6f1a0b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a913cacafad15e2d225d25d97d6f1a0b2">stack_tensors</a> (std::vector&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &gt; tensors)</td></tr>
<tr class="memdesc:a913cacafad15e2d225d25d97d6f1a0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stacks a group of tensors along a new dimension.  <a href="namespacetensorwrapper_1_1tensor.html#a913cacafad15e2d225d25d97d6f1a0b2">More...</a><br /></td></tr>
<tr class="separator:a913cacafad15e2d225d25d97d6f1a0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef09edb808f91be2e8fa82884d38ecf"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a6ef09edb808f91be2e8fa82884d38ecf">tensor_wrapper_to_eigen</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;<a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">tensor</a>)</td></tr>
<tr class="memdesc:a6ef09edb808f91be2e8fa82884d38ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce an Eigen Matrix version of the wrapped tensor.  <a href="namespacetensorwrapper_1_1tensor.html#a6ef09edb808f91be2e8fa82884d38ecf">More...</a><br /></td></tr>
<tr class="separator:a6ef09edb808f91be2e8fa82884d38ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99dcbf9e453092382750b7811b3fdc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#ac99dcbf9e453092382750b7811b3fdc4">eigen_to_tensor_wrapper</a> (const Eigen::MatrixXd &amp;matrix)</td></tr>
<tr class="memdesc:ac99dcbf9e453092382750b7811b3fdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> from an Eigen Matrix.  <a href="namespacetensorwrapper_1_1tensor.html#ac99dcbf9e453092382750b7811b3fdc4">More...</a><br /></td></tr>
<tr class="separator:ac99dcbf9e453092382750b7811b3fdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3764d8a3628f5861d9ab155829c3c9da"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a3764d8a3628f5861d9ab155829c3c9da">eigen_solve</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;X)</td></tr>
<tr class="memdesc:a3764d8a3628f5861d9ab155829c3c9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a traditional eigen solve on a matrix <code>X</code>.  <a href="namespacetensorwrapper_1_1tensor.html#a3764d8a3628f5861d9ab155829c3c9da">More...</a><br /></td></tr>
<tr class="separator:a3764d8a3628f5861d9ab155829c3c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989873e763ebf2d9a440187fbe2dc6b6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a989873e763ebf2d9a440187fbe2dc6b6">eigen_solve</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;X, const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;S)</td></tr>
<tr class="memdesc:a989873e763ebf2d9a440187fbe2dc6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a generalized eigen solve.  <a href="namespacetensorwrapper_1_1tensor.html#a989873e763ebf2d9a440187fbe2dc6b6">More...</a><br /></td></tr>
<tr class="separator:a989873e763ebf2d9a440187fbe2dc6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5135287ac8b3aa62bc5df9b77ef2f024"><td class="memItemLeft" align="right" valign="top"><a id="a5135287ac8b3aa62bc5df9b77ef2f024"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cholesky_linv</b> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &amp;M)</td></tr>
<tr class="separator:a5135287ac8b3aa62bc5df9b77ef2f024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476a88ffbd4a608e39d003a0f910569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#ac476a88ffbd4a608e39d003a0f910569">hmatrix_pow</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;S, double pow)</td></tr>
<tr class="memdesc:ac476a88ffbd4a608e39d003a0f910569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises a Hermitian matrix to a power.  <a href="namespacetensorwrapper_1_1tensor.html#ac476a88ffbd4a608e39d003a0f910569">More...</a><br /></td></tr>
<tr class="separator:ac476a88ffbd4a608e39d003a0f910569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b932933a690998412caf3425e808b4"><td class="memTemplParams" colspan="2"><a id="a23b932933a690998412caf3425e808b4"></a>
template&lt;TA::SVD::Vectors Vecs&gt; </td></tr>
<tr class="memitem:a23b932933a690998412caf3425e808b4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SVD_</b> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &amp;M)</td></tr>
<tr class="separator:a23b932933a690998412caf3425e808b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd248baebfb509b5007f0064d393717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a8fd248baebfb509b5007f0064d393717">SVDValues</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;M)</td></tr>
<tr class="memdesc:a8fd248baebfb509b5007f0064d393717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs singular value decomposition on matrix <code>M</code> and returns the singular values.  <a href="namespacetensorwrapper_1_1tensor.html#a8fd248baebfb509b5007f0064d393717">More...</a><br /></td></tr>
<tr class="separator:a8fd248baebfb509b5007f0064d393717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace347025cf79a9c329debf1a27afa2e1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#ace347025cf79a9c329debf1a27afa2e1">SVDLeft</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;M)</td></tr>
<tr class="memdesc:ace347025cf79a9c329debf1a27afa2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs singular value decomposition on matrix <code>M</code> and returns the singular values and left vectors.  <a href="namespacetensorwrapper_1_1tensor.html#ace347025cf79a9c329debf1a27afa2e1">More...</a><br /></td></tr>
<tr class="separator:ace347025cf79a9c329debf1a27afa2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1e7f0399262fccc563d0c06c31bacc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a6f1e7f0399262fccc563d0c06c31bacc">SVDRight</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;M)</td></tr>
<tr class="memdesc:a6f1e7f0399262fccc563d0c06c31bacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs singular value decomposition on matrix <code>M</code> and returns the singular values and right vectors.  <a href="namespacetensorwrapper_1_1tensor.html#a6f1e7f0399262fccc563d0c06c31bacc">More...</a><br /></td></tr>
<tr class="separator:a6f1e7f0399262fccc563d0c06c31bacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c31c4968b7cc046d6b297b7b682697a"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TWrapper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a3c31c4968b7cc046d6b297b7b682697a">SVD</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;M)</td></tr>
<tr class="memdesc:a3c31c4968b7cc046d6b297b7b682697a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs singular value decomposition on matrix <code>M</code> and returns the singular values and vectors.  <a href="namespacetensorwrapper_1_1tensor.html#a3c31c4968b7cc046d6b297b7b682697a">More...</a><br /></td></tr>
<tr class="separator:a3c31c4968b7cc046d6b297b7b682697a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6511dd66dfcabf1a3c60fb58fefcad94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a6511dd66dfcabf1a3c60fb58fefcad94">remove_redundancy</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;C, const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;S, double thresh=1.0E-8)</td></tr>
<tr class="memdesc:a6511dd66dfcabf1a3c60fb58fefcad94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elminates linear dependencies in the provided transformation.  <a href="namespacetensorwrapper_1_1tensor.html#a6511dd66dfcabf1a3c60fb58fefcad94">More...</a><br /></td></tr>
<tr class="separator:a6511dd66dfcabf1a3c60fb58fefcad94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bd4f276c4eab843690fb4c75ccfd47"><td class="memTemplParams" colspan="2">template&lt;typename FieldType &gt; </td></tr>
<tr class="memitem:a57bd4f276c4eab843690fb4c75ccfd47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1Allocator.html">Allocator</a>&lt; FieldType &gt;::allocator_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1tensor.html#a57bd4f276c4eab843690fb4c75ccfd47">default_allocator</a> ()</td></tr>
<tr class="memdesc:a57bd4f276c4eab843690fb4c75ccfd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the process of creating a defaulted allocator.  <a href="namespacetensorwrapper_1_1tensor.html#a57bd4f276c4eab843690fb4c75ccfd47">More...</a><br /></td></tr>
<tr class="separator:a57bd4f276c4eab843690fb4c75ccfd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Forward declare the <a class="el" href="structtensorwrapper_1_1tensor_1_1Conversion.html" title="Dispatches to the correct conversion function based on the desired output type of the wrapped tensor.">Conversion</a> class. </p>
<p>TODO: Remove this. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a082bf5bdce3f92c475065107fae62e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082bf5bdce3f92c475065107fae62e4a">&#9670;&nbsp;</a></span>add_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#a082bf5bdce3f92c475065107fae62e4a">tensorwrapper::tensor::add_expr_t</a> = typedef decltype(std::declval&lt;LType&gt;() + std::declval&lt;RType&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the type that results from adding two tensors together. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The type of the tensor on the left side of the plus sign </td></tr>
    <tr><td class="paramname">RType</td><td>The type of the tensor on the right side of the plus sign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aad99a77f261567382e195b696d1315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aad99a77f261567382e195b696d1315">&#9670;&nbsp;</a></span>add_variant_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#a8aad99a77f261567382e195b696d1315">tensorwrapper::tensor::add_variant_t</a> = typedef utilities::type_traits::variant::product_t&lt;<a class="el" href="namespacetensorwrapper_1_1tensor.html#a082bf5bdce3f92c475065107fae62e4a">add_expr_t</a>, LType, RType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef of a variant resulting from adding two variants together. </p>
<p>Given a std::variant with <code>n</code> types and a std::variant with <code>m</code> types this typedef defines an std::variant with <code>n*m</code> types. Thinking of the resulting std::variant as a row-major matrix, the <code>i,j</code>-th type is that resulting from adding the <code>i</code>-th type in <code>LType</code> with the <code>j</code>-th type in <code>RType</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The variant on the left-side of the addition sign. </td></tr>
    <tr><td class="paramname">RType</td><td>The variant on the right-side of the addition sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a188d69e14ed295ed4c217277cf5e102f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188d69e14ed295ed4c217277cf5e102f">&#9670;&nbsp;</a></span>enable_if_expression_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#a188d69e14ed295ed4c217277cf5e102f">tensorwrapper::tensor::enable_if_expression_t</a> = typedef std::enable_if_t&lt;is_expression_v&lt;T&gt;, U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to enable a function via SFINAE when <code>T</code> is part of the expression layer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>If <code>T</code> is part of the expression layer the decorated function will participate in overload resolution otherwise it will not. </td></tr>
    <tr><td class="paramname">U</td><td>The type that the typedef will be set to if <code>T</code> is part of the expression layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba797881c277898dca86d419a0951a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba797881c277898dca86d419a0951a5b">&#9670;&nbsp;</a></span>labeled_variant_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorVariant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#aba797881c277898dca86d419a0951a5b">tensorwrapper::tensor::labeled_variant_t</a> = typedef typename <a class="el" href="structtensorwrapper_1_1tensor_1_1detail___1_1LabeledVariant.html">detail_::LabeledVariant</a>&lt;TensorVariant&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public API for getting a variant of labeled tensors. </p>
<p>This is the public API for turning a variant of tensors into a variant of labeled tensors. For the i-th type in <code>TensorVariant</code> the i-th type in the resulting variant will be the type which results from calling <code>operator()(std::string)</code> on a tensor of that type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorVariant</td><td>A variant of tensors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfa7d1d7864d1c8286f064c73fe522fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa7d1d7864d1c8286f064c73fe522fd">&#9670;&nbsp;</a></span>mult_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#abfa7d1d7864d1c8286f064c73fe522fd">tensorwrapper::tensor::mult_expr_t</a> = typedef decltype(std::declval&lt;LType&gt;() * std::declval&lt;RType&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the type that results from multiplying two tensors together. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The type of the tensor on the left side of the times sign </td></tr>
    <tr><td class="paramname">RType</td><td>The type of the tensor on the right side of the times sign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacaf6847e15b44694cbbcf24ed2ef00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaf6847e15b44694cbbcf24ed2ef00c">&#9670;&nbsp;</a></span>mult_variant_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#aacaf6847e15b44694cbbcf24ed2ef00c">tensorwrapper::tensor::mult_variant_t</a> = typedef utilities::type_traits::variant::product_t&lt;<a class="el" href="namespacetensorwrapper_1_1tensor.html#abfa7d1d7864d1c8286f064c73fe522fd">mult_expr_t</a>, LType, RType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef of a variant resulting from multiplying two variants together. </p>
<p>Given a std::variant with <code>n</code> types and a std::variant with <code>m</code> types this typedef defines an std::variant with <code>n*m</code> types. Thinking of the resulting std::variant as a row-major matrix, the <code>i,j</code>-th type is that resulting from multiplying the <code>i</code>-th type in <code>LType</code> with the <code>j</code>-th type in <code>RType</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The variant on the left-side of the multiplication sign. </td></tr>
    <tr><td class="paramname">RType</td><td>The variant on the right-side of the multiplication sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac50ac1f1c0854632ca823661c10c2e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50ac1f1c0854632ca823661c10c2e6b">&#9670;&nbsp;</a></span>n_d_initializer_list_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#ac50ac1f1c0854632ca823661c10c2e6b">tensorwrapper::tensor::n_d_initializer_list_t</a> = typedef typename <a class="el" href="structtensorwrapper_1_1tensor_1_1NDInitializerListTraits.html">NDInitializerListTraits</a>&lt;T, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience typedef of the initializer_list for a rank <code>N</code> tensor of scalars of type <code>T</code>. </p>
<p>This typedef is a typedef of the <code>type</code> member of the <code>NDInitializer&lt;T, N&gt;</code> type for coding convenience.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the scalars in the tensor. </td></tr>
    <tr><td class="paramname">N</td><td>The rank of the tensor we are generating the initializer_list for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6c7661c7365464aad167bcc57da35ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c7661c7365464aad167bcc57da35ae">&#9670;&nbsp;</a></span>subt_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#ac6c7661c7365464aad167bcc57da35ae">tensorwrapper::tensor::subt_expr_t</a> = typedef decltype(std::declval&lt;LType&gt;() - std::declval&lt;RType&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the type that results from subtracting two tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The type of the tensor on the left side of the minus sign </td></tr>
    <tr><td class="paramname">RType</td><td>The type of the tensor on the right side of the minus sign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8d82cad5a785c88c23c8de1f361e8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d82cad5a785c88c23c8de1f361e8d6">&#9670;&nbsp;</a></span>subt_variant_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LType , typename RType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#aa8d82cad5a785c88c23c8de1f361e8d6">tensorwrapper::tensor::subt_variant_t</a> = typedef utilities::type_traits::variant::product_t&lt;<a class="el" href="namespacetensorwrapper_1_1tensor.html#ac6c7661c7365464aad167bcc57da35ae">subt_expr_t</a>, LType, RType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef of a variant resulting from subtracting two variants. </p>
<p>Given a std::variant with <code>n</code> types and a std::variant with <code>m</code> types this typedef defines an std::variant with <code>n*m</code> types. Thinking of the resulting std::variant as a row-major matrix, the <code>i,j</code>-th type is that resulting from subtracting the <code>j</code>-th type in <code>RType</code> from the <code>i</code>-th type in <code>LType</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LType</td><td>The variant on the left-side of the minus sign. </td></tr>
    <tr><td class="paramname">RType</td><td>The variant on the right-side of the minus sign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af227ab63923553cb396011c0cc699cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af227ab63923553cb396011c0cc699cb2">&#9670;&nbsp;</a></span>variant_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetensorwrapper_1_1tensor.html#af227ab63923553cb396011c0cc699cb2">tensorwrapper::tensor::variant_type_t</a> = typedef typename <a class="el" href="structtensorwrapper_1_1tensor_1_1detail___1_1VariantType.html">detail_::VariantType</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public API for determining the variant type of a <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>. </p>
<p>This typedef is used to get the variant type of a <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> specialization. This typedef will fail to compile if <code>T</code> is not a specialization of <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A non-qualified <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4ea8bb0257e016416d3c643df10ff511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea8bb0257e016416d3c643df10ff511">&#9670;&nbsp;</a></span>abs_allclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tensorwrapper::tensor::abs_allclose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rtol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>atol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as allclose, except comparisons are done with unsigned elements. </p>
<p>Same as allclose except comparisons are done with unsigned elements. </p>

</div>
</div>
<a id="a22d3e8a517f61fed6aa39633ecfbb5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d3e8a517f61fed6aa39633ecfbb5ef">&#9670;&nbsp;</a></span>allclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tensorwrapper::tensor::allclose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>1.0E-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>atol</em> = <code>1.0E-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instances for closeness. </p>
<p>Same as allclose except that the tensors are hierarchical.</p>
<p>This function will compare two tensors, <img class="formulaInl" alt="$A$" src="form_1.png"/> and <img class="formulaInl" alt="$B$" src="form_3.png"/>, elementwise and determine if all their values are close to one another. "Close" is defined by two parameters. The absolute tolerance, <code>atol</code>, defines the effective zero for all comparisons. If for a given index <img class="formulaInl" alt="$I$" src="form_22.png"/>, <img class="formulaInl" alt="$\mid A[I] - B[I]\mid$" src="form_36.png"/> two differs by less than <code>atol</code>, the difference is considered indistinguishable from zero and the elements the same. Particularly for very large elements achieving a difference on the order of <code>atol</code> is not always reasonable; in these cases, one cares more about the percent error. In this case <img class="formulaInl" alt="$\frac{\mid A[I] - B[I]\mid}{\mid B[I]\mid}$" src="form_24.png"/> must be less than a relative tolerance, <code>rtol</code>.</p>
<p>This function combines these criteria and returns true if <img class="formulaInl" alt="$A$" src="form_1.png"/> and <img class="formulaInl" alt="$B$" src="form_3.png"/> satisfy:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mid A - B\mid \le atol + rtol\mid B\mid \]" src="form_25.png"/>
</p>
<p>Note that this is <b>NOT</b> symmetric in <img class="formulaInl" alt="$A$" src="form_1.png"/> and <img class="formulaInl" alt="$B$" src="form_3.png"/>, but is commensurate with <img class="formulaInl" alt="$B$" src="form_3.png"/> being the reference (thereby dictating what is an acceptable relative tolerance).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual</td><td>The tensor you computed and are comparing against a reference value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The tensor which <code>actual</code> is being compared to. Should be "the correct value". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rtol</td><td>The maximum percent error (as a decimal) allowed for any particular value. Assumed to be a positive decimal. Defaults to 1.0E-5, <em>i.e.</em>, 0.0001%. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atol</td><td>The effective value of zero for comparisons. Assumed to be a positive decimal less than 1.0. Defaults to 1.0E-8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>actual</code> is "close" to <code>ref</code> and false otherwise. </dd></dl>

</div>
</div>
<a id="ae45e86f816a8abfef42521998b1f5731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45e86f816a8abfef42521998b1f5731">&#9670;&nbsp;</a></span>apply_elementwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::apply_elementwise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(double)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new tensor by applying a function elementwise to an existing tensor. </p>
<p>This function is a convenience function for creating a new tensor whose initial elements can be determined solely based on the element values of another tensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The tensor supplying the input values <code>op</code> will be called with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The function to apply to each element of <code>input</code> to generate the resulting tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor having the same shape and distribution as <code>input</code>. The <img class="formulaInl" alt="$i$" src="form_9.png"/>-th element of the new tensor is the result of <code>op(input[i])</code>, where <code>input[i]</code> is the <img class="formulaInl" alt="$i$" src="form_9.png"/>-th element of <code>input</code>. </dd></dl>

</div>
</div>
<a id="a8b0377ab77c6d6ba5ca40b44412aaa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0377ab77c6d6ba5ca40b44412aaa26">&#9670;&nbsp;</a></span>apply_elementwise_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensorwrapper::tensor::apply_elementwise_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(double &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies an existing tensor by applying a function elementwise to its values. </p>
<p>This function is a convenience function for modifying an existing tensor by an elementwise in-place operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The tensor supplying the input values to be changed in-place by <code>op</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The function to apply to each element of <code>input</code> to modify the values in-place. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9c277d8c6b1e7088e302dcba5469c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c277d8c6b1e7088e302dcba5469c2e">&#9670;&nbsp;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TensorOfTensorsWrapper</a> tensorwrapper::tensor::concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatentaes two tensors together along the specified dimension. </p>
<p>Concatenates two ToTs along the specified dimension.</p>
<p>This function joins two tensors together by making concatenating them together along the specified mode. For a rank <img class="formulaInl" alt="$N$" src="form_0.png"/> tensor, this means that the shape of the remaining N-1 modes must be identical.</p>
<dl class="section note"><dt>Note</dt><dd>Concatenation is in general non-commutative, i.e., <code>concatenate(A, B, dim)</code> will not necessarilly be the same as <code>concatenate(B, A, dim)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The tensor which will serve as the base tensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The tensor which will be added on to <code>lhs</code>. Must be the same rank as <code>lhs</code> and all modes aside from mode <code>dim</code> must have the same shape as the corresponding mode in <code>lhs</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The 0-based offset indicating which mode of <code>lhs</code> and <code>rhs</code> will be concatenated. Must be in the range [0, rank(lhs)).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the shapes of the tensors are not compatible for the concatenation or if <code>dim</code> is not a valid mode offset. Strong throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is not yet implemented. </p>

</div>
</div>
<a id="a57bd4f276c4eab843690fb4c75ccfd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bd4f276c4eab843690fb4c75ccfd47">&#9670;&nbsp;</a></span>default_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1Allocator.html">Allocator</a>&lt;FieldType&gt;::allocator_ptr tensorwrapper::tensor::default_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps the process of creating a defaulted allocator. </p>
<p>As more advanced alloctors are added to the library it will make sense to change the default <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> allocator. To decouple code from this choice, classes and functions needing a default_allocator instance are encouraged to get that allocator from this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldType</td><td>The type of the field the tensor is over. Assumed to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a type-erased, allocator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocation fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57619cbf160f98bb1531bdfb627fd77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57619cbf160f98bb1531bdfb627fd77a">&#9670;&nbsp;</a></span>diagonal_tensor_wrapper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::diagonal_tensor_wrapper </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1Allocator.html">Allocator</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a new <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> with the given value along its diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The desired extents of the new tensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to place on the diagonal of the tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> containing a diagonal tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Whatever</td><td>TA's diagonal_array throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5d2d9e0172f0a3e9c31828c2031ab53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d2d9e0172f0a3e9c31828c2031ab53">&#9670;&nbsp;</a></span>diagonal_tensor_wrapper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::diagonal_tensor_wrapper </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1Allocator.html">Allocator</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a new <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> with the given values along its diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The desired extents of the new tensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>The values to place on the diagonal of the tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> containing a diagonal tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Whatever</td><td>TA's diagonal_array throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3764d8a3628f5861d9ab155829c3c9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3764d8a3628f5861d9ab155829c3c9da">&#9670;&nbsp;</a></span>eigen_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &gt; tensorwrapper::tensor::eigen_solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a traditional eigen solve on a matrix <code>X</code>. </p>
<p>This function will compute the eigen values and eigen vectors of the matrix <code>X</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>A symmetric matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of tensors, such that first tensor is a vector containing the eigenvalues and the second tensor is a matrix whose colums are the eigenvectors. </dd></dl>

</div>
</div>
<a id="a989873e763ebf2d9a440187fbe2dc6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989873e763ebf2d9a440187fbe2dc6b6">&#9670;&nbsp;</a></span>eigen_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &gt; tensorwrapper::tensor::eigen_solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a generalized eigen solve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>The (symmetric) matrix to diagonalize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The (symmetric) metric matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of tensors, such that the first tensor is a vector containing the eigenvalues, and the second tensor is a matrix whose columsn are the eigenvectors. </dd></dl>

</div>
</div>
<a id="ac99dcbf9e453092382750b7811b3fdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99dcbf9e453092382750b7811b3fdc4">&#9670;&nbsp;</a></span>eigen_to_tensor_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::eigen_to_tensor_wrapper </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> from an Eigen Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td>The Eigen Matric to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> with the elements of the Eigen Matrix.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Whatever</td><td>TA's eigen_to_array throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad017e1a20eaf2b0f4c8514f01efeb9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad017e1a20eaf2b0f4c8514f01efeb9fb">&#9670;&nbsp;</a></span>grab_diagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::grab_diagonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grabs the diagonal of a matrix and returns it as a vector. </p>
<p>It sometimes happens that we have a matrix, but we only need the diagonal of that matrix. This function wraps the process of copying the diagonal of that matrix into a vector.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> containing just the diagonal elements of the tensor. </dd></dl>

</div>
</div>
<a id="ac476a88ffbd4a608e39d003a0f910569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac476a88ffbd4a608e39d003a0f910569">&#9670;&nbsp;</a></span>hmatrix_pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::hmatrix_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises a Hermitian matrix to a power. </p>
<p>This function returns the matrix which behaves as the matrix <code>S</code> raised to the power <code>pow</code>. This is NOT the same as raising each element of <code>S</code> to the power <code>pow</code> (unless <code>S</code> is diagonal). By "behaves like" we mean that for integer powers <img class="formulaInl" alt="$p$" src="form_37.png"/>:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ S^p = \sum_{jk\cdots} S_{ij}S_{jk}\cdots \]" src="form_38.png"/>
</p>
<p>where the ellipses contain <img class="formulaInl" alt="$p-2$" src="form_39.png"/> more matrix multiplications. Fractional power <img class="formulaInl" alt="$p=\frac{1}{q}$" src="form_40.png"/> is the <img class="formulaInl" alt="$q$" src="form_41.png"/>-th root of the matrix, and negative powers are powers/roots of the inverse of <code>S</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The matrix we are raising to power <code>pow</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pow</td><td>The power we are raising <code>S</code> to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix which behaves like <code>S</code> raised to the power <code>pow</code>. </dd></dl>

</div>
</div>
<a id="a6511dd66dfcabf1a3c60fb58fefcad94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6511dd66dfcabf1a3c60fb58fefcad94">&#9670;&nbsp;</a></span>remove_redundancy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::remove_redundancy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresh</em> = <code>1.0E-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elminates linear dependencies in the provided transformation. </p>
<p>Given a matrix of column vectors, <code>C</code>, and their inner products, <code>S</code>, such that the inner product of vector <img class="formulaInl" alt="$i$" src="form_9.png"/> with vector <img class="formulaInl" alt="$j$" src="form_10.png"/> is given by <img class="formulaInl" alt="$S_{ij}$" src="form_42.png"/>. This function will return a new set of linearly-independent vectors by diagonalizing <code>S</code> and dropping vectors associated with eigen values below <code>thresh</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>A set of column vectors which may have some linear dependencies. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The overlap of the column vectors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh</td><td>Vectors associated with eigen values below this value will be dropped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new, linearly-independent, vectors. </dd></dl>

</div>
</div>
<a id="a913cacafad15e2d225d25d97d6f1a0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913cacafad15e2d225d25d97d6f1a0b2">&#9670;&nbsp;</a></span>stack_tensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::stack_tensors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &gt;&#160;</td>
          <td class="paramname"><em>tensors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stacks a group of tensors along a new dimension. </p>
<p>This function joins a group of tensors together along a brand new dimension. The tensors must all have the same shape in the existing dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>An std::vector of tensors to be stacked together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the shapes of the tensors are not compatible for stacking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c31c4968b7cc046d6b297b7b682697a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c31c4968b7cc046d6b297b7b682697a">&#9670;&nbsp;</a></span>SVD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &gt; tensorwrapper::tensor::SVD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs singular value decomposition on matrix <code>M</code> and returns the singular values and vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>A matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of three tensors, such that the first is a vector containing the singular values of the matrix, the second contains the left singular vectors, and the third contains the right singular vectors. </dd></dl>

</div>
</div>
<a id="ace347025cf79a9c329debf1a27afa2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace347025cf79a9c329debf1a27afa2e1">&#9670;&nbsp;</a></span>SVDLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &gt; tensorwrapper::tensor::SVDLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs singular value decomposition on matrix <code>M</code> and returns the singular values and left vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>A matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of tensors, such that the first is a vector containing the singular values of the matrix, and the second contains the left singular vectors. </dd></dl>

</div>
</div>
<a id="a6f1e7f0399262fccc563d0c06c31bacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1e7f0399262fccc563d0c06c31bacc">&#9670;&nbsp;</a></span>SVDRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &gt; tensorwrapper::tensor::SVDRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs singular value decomposition on matrix <code>M</code> and returns the singular values and right vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>A matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of tensors, such that the first is a vector containing the singular values of the matrix, and the second contains the right singular vectors. </dd></dl>

</div>
</div>
<a id="a8fd248baebfb509b5007f0064d393717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd248baebfb509b5007f0064d393717">&#9670;&nbsp;</a></span>SVDValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::SVDValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs singular value decomposition on matrix <code>M</code> and returns the singular values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>A matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the singular values of the matrix. </dd></dl>

</div>
</div>
<a id="a6ef09edb808f91be2e8fa82884d38ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef09edb808f91be2e8fa82884d38ecf">&#9670;&nbsp;</a></span>tensor_wrapper_to_eigen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd tensorwrapper::tensor::tensor_wrapper_to_eigen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce an Eigen Matrix version of the wrapped tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td>The tensor to convert to an Eigen Matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Eigen Matrix.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Whatever</td><td>TA's array_to_eigen throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab383a298714a0ccc29890a9935a16c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab383a298714a0ccc29890a9935a16c38">&#9670;&nbsp;</a></span>to_contiguous_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensorwrapper::tensor::to_contiguous_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>buffer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>buffer_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens a tensor out into a contiguous buffer. </p>
<p>This function will replicate the provided tensor (assuming it is distributed to begin with) and then flatten it into a contiguous buffer. The flattening will occur in row-major format.</p>
<dl class="section note"><dt>Note</dt><dd>This function is primarily intended for use with low rank <code>t</code>, e.g. in taking actions based on the value of an eigenvalue. Direct access of high-rank tensors should be avoided.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The tensor to vectorize. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_begin</td><td>The start of the contiguous buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_end</td><td>The end of the contiguous buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d0fa50760ae41be159cae427ea12f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0fa50760ae41be159cae427ea12f81">&#9670;&nbsp;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; tensorwrapper::tensor::to_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens a tensor out into an std::vector. </p>
<p>This function will replicate the provided tensor (assuming it is distributed to begin with) and then flatten it into a vector. The flattening will occur in row-major format.</p>
<dl class="section note"><dt>Note</dt><dd>This function is primarily intended for use with low rank <code>t</code>, e.g. in taking actions based on the value of an eigenvalue. Direct access of high-rank tensors should be avoided.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The tensor to vectorize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor vectorized into an std::vector. </dd></dl>

</div>
</div>
<a id="a0181c79745c39845d6018404c5ff1166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0181c79745c39845d6018404c5ff1166">&#9670;&nbsp;</a></span>wrap_std_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ScalarTensorWrapper</a> tensorwrapper::tensor::wrap_std_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a std::vector into a 1D ScalarTensorWrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The std::vector to wrap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 1D ScalarTensorWrapper wrapping the values of <code>v</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
