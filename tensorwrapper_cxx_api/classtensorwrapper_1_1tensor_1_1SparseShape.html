<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::tensor::SparseShape&lt; FieldType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorwrapper</b></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1tensor.html">tensor</a></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classtensorwrapper_1_1tensor_1_1SparseShape-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::tensor::SparseShape&lt; FieldType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Describes a tensor's shape when there's sparsity.  
 <a href="classtensorwrapper_1_1tensor_1_1SparseShape.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparse__shape_8hpp_source.html">sparse_shape.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tensorwrapper::tensor::SparseShape&lt; FieldType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtensorwrapper_1_1tensor_1_1SparseShape.png" usemap="#tensorwrapper::tensor::SparseShape_3C_20FieldType_20_3E_map" alt=""/>
  <map id="tensorwrapper::tensor::SparseShape_3C_20FieldType_20_3E_map" name="tensorwrapper::tensor::SparseShape_3C_20FieldType_20_3E_map">
<area href="classtensorwrapper_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout." alt="tensorwrapper::tensor::Shape&lt; FieldType &gt;" shape="rect" coords="0,0,297,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8dfc196e31e63400646ba22caa82f332"><td class="memItemLeft" align="right" valign="top"><a id="a8dfc196e31e63400646ba22caa82f332"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a8dfc196e31e63400646ba22caa82f332">sparse_map_type</a> = <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">sparse_map::SparseMap</a></td></tr>
<tr class="memdesc:a8dfc196e31e63400646ba22caa82f332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the sparse map taken as input. <br /></td></tr>
<tr class="separator:a8dfc196e31e63400646ba22caa82f332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f5ce396be163319189e8ba2e107431"><td class="memItemLeft" align="right" valign="top"><a id="aa1f5ce396be163319189e8ba2e107431"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#aa1f5ce396be163319189e8ba2e107431">const_sparse_map_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a8dfc196e31e63400646ba22caa82f332">sparse_map_type</a> &amp;</td></tr>
<tr class="memdesc:aa1f5ce396be163319189e8ba2e107431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the sparse map the shape is using. <br /></td></tr>
<tr class="separator:aa1f5ce396be163319189e8ba2e107431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a4d0a944702caf1a5db05516f3a3ca"><td class="memItemLeft" align="right" valign="top"><a id="ae4a4d0a944702caf1a5db05516f3a3ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ae4a4d0a944702caf1a5db05516f3a3ca">idx2mode_type</a> = std::vector&lt; std::size_t &gt;</td></tr>
<tr class="memdesc:ae4a4d0a944702caf1a5db05516f3a3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the input mapping sparse map indices to tensor modes. <br /></td></tr>
<tr class="separator:ae4a4d0a944702caf1a5db05516f3a3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d7ec3e01b6851923c8a1f7bdebf3e1"><td class="memItemLeft" align="right" valign="top"><a id="a64d7ec3e01b6851923c8a1f7bdebf3e1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a64d7ec3e01b6851923c8a1f7bdebf3e1">const_idx2mode_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ae4a4d0a944702caf1a5db05516f3a3ca">idx2mode_type</a> &amp;</td></tr>
<tr class="memdesc:a64d7ec3e01b6851923c8a1f7bdebf3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the sparse map to tensor mode map. <br /></td></tr>
<tr class="separator:a64d7ec3e01b6851923c8a1f7bdebf3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fcd6de874861a5267006eb8e553835"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a> = std::vector&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#af44543d687e89d35c2ee27ab4b3f3527">size_type</a> &gt;</td></tr>
<tr class="separator:a32fcd6de874861a5267006eb8e553835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac005ffdadbc624c71e084aa30452357b"><td class="memItemLeft" align="right" valign="top"><a id="ac005ffdadbc624c71e084aa30452357b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ac005ffdadbc624c71e084aa30452357b">inner_extents_type</a> = std::conditional_t&lt; field::is_scalar_field_v&lt; FieldType &gt;, <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#af44543d687e89d35c2ee27ab4b3f3527">size_type</a>, std::map&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#abae02a3a8889d68f6f574bcfeb3ebd3d">index_type</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ac005ffdadbc624c71e084aa30452357b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to treat inner-extents. <br /></td></tr>
<tr class="separator:ac005ffdadbc624c71e084aa30452357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae02a3a8889d68f6f574bcfeb3ebd3d"><td class="memItemLeft" align="right" valign="top"><a id="abae02a3a8889d68f6f574bcfeb3ebd3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#abae02a3a8889d68f6f574bcfeb3ebd3d">index_type</a> = <a class="el" href="structtensorwrapper_1_1sparse__map_1_1Index.html">sparse_map::Index</a></td></tr>
<tr class="memdesc:abae02a3a8889d68f6f574bcfeb3ebd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for initializer_lists of sizes. <br /></td></tr>
<tr class="separator:abae02a3a8889d68f6f574bcfeb3ebd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f422e3bfd5c37724dcd3d328cc3546a"><td class="memItemLeft" align="right" valign="top"><a id="a5f422e3bfd5c37724dcd3d328cc3546a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a5f422e3bfd5c37724dcd3d328cc3546a">pointer_type</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">my_type</a> &gt;</td></tr>
<tr class="memdesc:a5f422e3bfd5c37724dcd3d328cc3546a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to this class. <br /></td></tr>
<tr class="separator:a5f422e3bfd5c37724dcd3d328cc3546a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtensorwrapper_1_1tensor_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">tensorwrapper::tensor::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:a280f251b7852f82c716abea4bfb59a03 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a280f251b7852f82c716abea4bfb59a03"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a280f251b7852f82c716abea4bfb59a03">pimpl_pointer</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1detail___1_1ShapePIMPL.html">pimpl_type</a> &gt;</td></tr>
<tr class="memdesc:a280f251b7852f82c716abea4bfb59a03 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to a PIMPL instance. <br /></td></tr>
<tr class="separator:a280f251b7852f82c716abea4bfb59a03 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bffb4e1a617b7caa4ed41b4ba6c151 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a04bffb4e1a617b7caa4ed41b4ba6c151"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a04bffb4e1a617b7caa4ed41b4ba6c151">field_type</a> = FieldType</td></tr>
<tr class="memdesc:a04bffb4e1a617b7caa4ed41b4ba6c151 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the field the associated tensor is over. <br /></td></tr>
<tr class="separator:a04bffb4e1a617b7caa4ed41b4ba6c151 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44543d687e89d35c2ee27ab4b3f3527 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="af44543d687e89d35c2ee27ab4b3f3527"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#af44543d687e89d35c2ee27ab4b3f3527">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:af44543d687e89d35c2ee27ab4b3f3527 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing and offsets. <br /></td></tr>
<tr class="separator:af44543d687e89d35c2ee27ab4b3f3527 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae02a3a8889d68f6f574bcfeb3ebd3d inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="abae02a3a8889d68f6f574bcfeb3ebd3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#abae02a3a8889d68f6f574bcfeb3ebd3d">index_type</a> = <a class="el" href="structtensorwrapper_1_1sparse__map_1_1Index.html">sparse_map::Index</a></td></tr>
<tr class="memdesc:abae02a3a8889d68f6f574bcfeb3ebd3d inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for initializer_lists of sizes. <br /></td></tr>
<tr class="separator:abae02a3a8889d68f6f574bcfeb3ebd3d inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fcd6de874861a5267006eb8e553835 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a> = std::vector&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#af44543d687e89d35c2ee27ab4b3f3527">size_type</a> &gt;</td></tr>
<tr class="separator:a32fcd6de874861a5267006eb8e553835 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a15b53597676860a0d749bc43c50a06 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a9a15b53597676860a0d749bc43c50a06"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a9a15b53597676860a0d749bc43c50a06">const_extents_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a> &amp;</td></tr>
<tr class="memdesc:a9a15b53597676860a0d749bc43c50a06 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the (outer) extents. <br /></td></tr>
<tr class="separator:a9a15b53597676860a0d749bc43c50a06 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac005ffdadbc624c71e084aa30452357b inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="ac005ffdadbc624c71e084aa30452357b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#ac005ffdadbc624c71e084aa30452357b">inner_extents_type</a> = std::conditional_t&lt; field::is_scalar_field_v&lt; FieldType &gt;, <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#af44543d687e89d35c2ee27ab4b3f3527">size_type</a>, std::map&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#abae02a3a8889d68f6f574bcfeb3ebd3d">index_type</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a>&lt; <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html">field::Scalar</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ac005ffdadbc624c71e084aa30452357b inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to treat inner-extents. <br /></td></tr>
<tr class="separator:ac005ffdadbc624c71e084aa30452357b inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae82b9d4f4712501e199920ecbd1b63 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a2ae82b9d4f4712501e199920ecbd1b63"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a2ae82b9d4f4712501e199920ecbd1b63">const_inner_extents_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#ac005ffdadbc624c71e084aa30452357b">inner_extents_type</a> &amp;</td></tr>
<tr class="memdesc:a2ae82b9d4f4712501e199920ecbd1b63 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the inner. <br /></td></tr>
<tr class="separator:a2ae82b9d4f4712501e199920ecbd1b63 inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f422e3bfd5c37724dcd3d328cc3546a inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a5f422e3bfd5c37724dcd3d328cc3546a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a5f422e3bfd5c37724dcd3d328cc3546a">pointer_type</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">my_type</a> &gt;</td></tr>
<tr class="memdesc:a5f422e3bfd5c37724dcd3d328cc3546a inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to this class. <br /></td></tr>
<tr class="separator:a5f422e3bfd5c37724dcd3d328cc3546a inherit pub_types_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeeefda7594056d21acf594388077b935"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#aeeefda7594056d21acf594388077b935">SparseShape</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#aa36e8446d6fad47a93eaac8744a4f1b1">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a8dfc196e31e63400646ba22caa82f332">sparse_map_type</a> sm)</td></tr>
<tr class="memdesc:aeeefda7594056d21acf594388077b935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents and a SparseMap.  <a href="classtensorwrapper_1_1tensor_1_1SparseShape.html#aeeefda7594056d21acf594388077b935">More...</a><br /></td></tr>
<tr class="separator:aeeefda7594056d21acf594388077b935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad582e5ee7ae1e147db4cba641251a403"><td class="memItemLeft" align="right" valign="top"><a id="ad582e5ee7ae1e147db4cba641251a403"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SparseShape</b> (<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#aa36e8446d6fad47a93eaac8744a4f1b1">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#ac005ffdadbc624c71e084aa30452357b">inner_extents_type</a> inner_extents, <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a8dfc196e31e63400646ba22caa82f332">sparse_map_type</a> sm)</td></tr>
<tr class="separator:ad582e5ee7ae1e147db4cba641251a403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f23e74b1d2579c53cd9d39250ba8d9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a6f23e74b1d2579c53cd9d39250ba8d9c">SparseShape</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#aa36e8446d6fad47a93eaac8744a4f1b1">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a8dfc196e31e63400646ba22caa82f332">sparse_map_type</a> sm, <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ae4a4d0a944702caf1a5db05516f3a3ca">idx2mode_type</a> i2m)</td></tr>
<tr class="memdesc:a6f23e74b1d2579c53cd9d39250ba8d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents, a SparseMap, and a mapping from SparseMap indices to tensor modes.  <a href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a6f23e74b1d2579c53cd9d39250ba8d9c">More...</a><br /></td></tr>
<tr class="separator:a6f23e74b1d2579c53cd9d39250ba8d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53615029be9b3e203ac0e375c378c7f0"><td class="memItemLeft" align="right" valign="top"><a id="a53615029be9b3e203ac0e375c378c7f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SparseShape</b> (<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#aa36e8446d6fad47a93eaac8744a4f1b1">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#ac005ffdadbc624c71e084aa30452357b">inner_extents_type</a> inner_extents, <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a8dfc196e31e63400646ba22caa82f332">sparse_map_type</a> sm, <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ae4a4d0a944702caf1a5db05516f3a3ca">idx2mode_type</a> i2m)</td></tr>
<tr class="separator:a53615029be9b3e203ac0e375c378c7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefba6693f38242d810d0b1999b11e043"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#aefba6693f38242d810d0b1999b11e043">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:aefba6693f38242d810d0b1999b11e043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-polymorphic comparison of two <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances.  <a href="classtensorwrapper_1_1tensor_1_1SparseShape.html#aefba6693f38242d810d0b1999b11e043">More...</a><br /></td></tr>
<tr class="separator:aefba6693f38242d810d0b1999b11e043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a7c602054d31eca502d428ba025f15"><td class="memTemplParams" colspan="2">template&lt;typename RHSField , typename  = disable_if_same_field_t&lt;RHSField&gt;&gt; </td></tr>
<tr class="memitem:ac1a7c602054d31eca502d428ba025f15"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ac1a7c602054d31eca502d428ba025f15">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;) const noexcept</td></tr>
<tr class="memdesc:ac1a7c602054d31eca502d428ba025f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements operator== for different fields.  <a href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ac1a7c602054d31eca502d428ba025f15">More...</a><br /></td></tr>
<tr class="separator:ac1a7c602054d31eca502d428ba025f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdeb7927099e94b658d30baacbc7c16"><td class="memItemLeft" align="right" valign="top"><a id="a1cdeb7927099e94b658d30baacbc7c16"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#aa1f5ce396be163319189e8ba2e107431">const_sparse_map_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_map</b> () const</td></tr>
<tr class="separator:a1cdeb7927099e94b658d30baacbc7c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0bffe5cec4edfcb6330d6f07b04c55"><td class="memItemLeft" align="right" valign="top"><a id="a7b0bffe5cec4edfcb6330d6f07b04c55"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a64d7ec3e01b6851923c8a1f7bdebf3e1">const_idx2mode_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>idx2mode_map</b> () const</td></tr>
<tr class="separator:a7b0bffe5cec4edfcb6330d6f07b04c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtensorwrapper_1_1tensor_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">tensorwrapper::tensor::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:a87030a8ffb5223beb3b73e6d81246e18 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a87030a8ffb5223beb3b73e6d81246e18">Shape</a> () noexcept</td></tr>
<tr class="memdesc:a87030a8ffb5223beb3b73e6d81246e18 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape with no extents.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a87030a8ffb5223beb3b73e6d81246e18">More...</a><br /></td></tr>
<tr class="separator:a87030a8ffb5223beb3b73e6d81246e18 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e85764d88bfef98fb66e4ed094d4bc4 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a4e85764d88bfef98fb66e4ed094d4bc4">Shape</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#aa36e8446d6fad47a93eaac8744a4f1b1">extents</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#ac005ffdadbc624c71e084aa30452357b">inner_extents_type</a> inner_extents={})</td></tr>
<tr class="memdesc:a4e85764d88bfef98fb66e4ed094d4bc4 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape with the provided extents.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a4e85764d88bfef98fb66e4ed094d4bc4">More...</a><br /></td></tr>
<tr class="separator:a4e85764d88bfef98fb66e4ed094d4bc4 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2e0e51773394746229cebd5771c6ee inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#ade2e0e51773394746229cebd5771c6ee">Shape</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a> &amp;other)</td></tr>
<tr class="memdesc:ade2e0e51773394746229cebd5771c6ee inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape by copying another shape.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#ade2e0e51773394746229cebd5771c6ee">More...</a><br /></td></tr>
<tr class="separator:ade2e0e51773394746229cebd5771c6ee inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07070da342b1f3992834385d41ce730e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a07070da342b1f3992834385d41ce730e">Shape</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a07070da342b1f3992834385d41ce730e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shape by moving another shape.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a07070da342b1f3992834385d41ce730e">More...</a><br /></td></tr>
<tr class="separator:a07070da342b1f3992834385d41ce730e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff17e4bf8e3a921e70f4c1135c531ae inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a0ff17e4bf8e3a921e70f4c1135c531ae">operator=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a> &amp;other)</td></tr>
<tr class="memdesc:a0ff17e4bf8e3a921e70f4c1135c531ae inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the internal state of another <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> instance to the current instance.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a0ff17e4bf8e3a921e70f4c1135c531ae">More...</a><br /></td></tr>
<tr class="separator:a0ff17e4bf8e3a921e70f4c1135c531ae inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0929370fd78d70af4dd463324e100e8c inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a0929370fd78d70af4dd463324e100e8c">operator=</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a0929370fd78d70af4dd463324e100e8c inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the internal state of another <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> instance to the current instance.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a0929370fd78d70af4dd463324e100e8c">More...</a><br /></td></tr>
<tr class="separator:a0929370fd78d70af4dd463324e100e8c inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d7b8c1c53d794fa877503e1fe9b37e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="ab5d7b8c1c53d794fa877503e1fe9b37e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#ab5d7b8c1c53d794fa877503e1fe9b37e">~Shape</a> () noexcept</td></tr>
<tr class="memdesc:ab5d7b8c1c53d794fa877503e1fe9b37e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted dtor. <br /></td></tr>
<tr class="separator:ab5d7b8c1c53d794fa877503e1fe9b37e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816e7fd894a793668c85819d907bd685 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a5f422e3bfd5c37724dcd3d328cc3546a">pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a816e7fd894a793668c85819d907bd685">clone</a> () const</td></tr>
<tr class="memdesc:a816e7fd894a793668c85819d907bd685 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic deep-copy.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a816e7fd894a793668c85819d907bd685">More...</a><br /></td></tr>
<tr class="separator:a816e7fd894a793668c85819d907bd685 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36e8446d6fad47a93eaac8744a4f1b1 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a9a15b53597676860a0d749bc43c50a06">const_extents_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#aa36e8446d6fad47a93eaac8744a4f1b1">extents</a> () const</td></tr>
<tr class="memdesc:aa36e8446d6fad47a93eaac8744a4f1b1 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extents of the tensor described by this <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a>.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#aa36e8446d6fad47a93eaac8744a4f1b1">More...</a><br /></td></tr>
<tr class="separator:aa36e8446d6fad47a93eaac8744a4f1b1 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fea11182f5a3e8958bcf03a67ce84c inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="aa4fea11182f5a3e8958bcf03a67ce84c"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a2ae82b9d4f4712501e199920ecbd1b63">const_inner_extents_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inner_extents</b> () const</td></tr>
<tr class="separator:aa4fea11182f5a3e8958bcf03a67ce84c inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8985dd6d2987742a914793331e0d9146 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a8985dd6d2987742a914793331e0d9146"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#af44543d687e89d35c2ee27ab4b3f3527">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>field_rank</b> () const</td></tr>
<tr class="separator:a8985dd6d2987742a914793331e0d9146 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9a4c93cfc84a52ec4844b392eca67e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a0d9a4c93cfc84a52ec4844b392eca67e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_hard_zero</b> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#abae02a3a8889d68f6f574bcfeb3ebd3d">index_type</a> &amp;i) const</td></tr>
<tr class="separator:a0d9a4c93cfc84a52ec4844b392eca67e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3541021291aa6070ea6a9dd9d3e15d inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a2f3541021291aa6070ea6a9dd9d3e15d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_hard_zero</b> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#abae02a3a8889d68f6f574bcfeb3ebd3d">index_type</a> &amp;lo, const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#abae02a3a8889d68f6f574bcfeb3ebd3d">index_type</a> &amp;hi) const</td></tr>
<tr class="separator:a2f3541021291aa6070ea6a9dd9d3e15d inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1efbe57fc05e17d8bde31a0603914f inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="aba1efbe57fc05e17d8bde31a0603914f"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a5f422e3bfd5c37724dcd3d328cc3546a">pointer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>slice</b> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#abae02a3a8889d68f6f574bcfeb3ebd3d">index_type</a> &amp;lo, const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#abae02a3a8889d68f6f574bcfeb3ebd3d">index_type</a> &amp;hi) const</td></tr>
<tr class="separator:aba1efbe57fc05e17d8bde31a0603914f inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8c131200d751f53fa9eb0520bca50e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a2d8c131200d751f53fa9eb0520bca50e">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a2d8c131200d751f53fa9eb0520bca50e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-polymorphic equality comparison for shapes with the same field.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a2d8c131200d751f53fa9eb0520bca50e">More...</a><br /></td></tr>
<tr class="separator:a2d8c131200d751f53fa9eb0520bca50e inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b67ceb2bb72b50147d2d52fe2da106 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memTemplParams" colspan="2">template&lt;typename RHSType , typename  = enable_if_not_my_field_t&lt;RHSType&gt;&gt; </td></tr>
<tr class="memitem:a25b67ceb2bb72b50147d2d52fe2da106 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a25b67ceb2bb72b50147d2d52fe2da106">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a>&lt; RHSType &gt; &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a25b67ceb2bb72b50147d2d52fe2da106 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-polymorphic equality comparison for Shapes with different fields.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a25b67ceb2bb72b50147d2d52fe2da106">More...</a><br /></td></tr>
<tr class="separator:a25b67ceb2bb72b50147d2d52fe2da106 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a06372c74de8c2c91e2ad907941f22c inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top"><a id="a5a06372c74de8c2c91e2ad907941f22c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a5a06372c74de8c2c91e2ad907941f22c">is_equal</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a5a06372c74de8c2c91e2ad907941f22c inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic equality comparison. <br /></td></tr>
<tr class="separator:a5a06372c74de8c2c91e2ad907941f22c inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f00246132cd481366c8152dc1d0cc4 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a89f00246132cd481366c8152dc1d0cc4">hash</a> (tensorwrapper::detail_::Hasher &amp;h) const</td></tr>
<tr class="memdesc:a89f00246132cd481366c8152dc1d0cc4 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic hash function.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a89f00246132cd481366c8152dc1d0cc4">More...</a><br /></td></tr>
<tr class="separator:a89f00246132cd481366c8152dc1d0cc4 inherit pub_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af6e3c4731d4fa6fcc7d08588d4acb42f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#af6e3c4731d4fa6fcc7d08588d4acb42f">SparseShape</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a> &amp;other)</td></tr>
<tr class="memdesc:af6e3c4731d4fa6fcc7d08588d4acb42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a non-polymorphic copy of this instance.  <a href="classtensorwrapper_1_1tensor_1_1SparseShape.html#af6e3c4731d4fa6fcc7d08588d4acb42f">More...</a><br /></td></tr>
<tr class="separator:af6e3c4731d4fa6fcc7d08588d4acb42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classtensorwrapper_1_1tensor_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">tensorwrapper::tensor::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:af9665814a0cca90cecf3685fc244d33f inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#af9665814a0cca90cecf3685fc244d33f">Shape</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a280f251b7852f82c716abea4bfb59a03">pimpl_pointer</a> pimpl) noexcept</td></tr>
<tr class="memdesc:af9665814a0cca90cecf3685fc244d33f inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> with the specified PIMPL.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#af9665814a0cca90cecf3685fc244d33f">More...</a><br /></td></tr>
<tr class="separator:af9665814a0cca90cecf3685fc244d33f inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e7ba15ffc35eb9ccac9156a414120b inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtensorwrapper_1_1tensor_1_1detail___1_1ShapePIMPL.html">pimpl_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#ad7e7ba15ffc35eb9ccac9156a414120b">pimpl_</a> () const</td></tr>
<tr class="memdesc:ad7e7ba15ffc35eb9ccac9156a414120b inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PIMPL in a read-only state.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#ad7e7ba15ffc35eb9ccac9156a414120b">More...</a><br /></td></tr>
<tr class="separator:ad7e7ba15ffc35eb9ccac9156a414120b inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ee5052db73a221ffa31fd39ffd88fe inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a62ee5052db73a221ffa31fd39ffd88fe">assert_pimpl_</a> () const</td></tr>
<tr class="memdesc:a62ee5052db73a221ffa31fd39ffd88fe inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises an exception if the <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> instance does not contain a PIMPL.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a62ee5052db73a221ffa31fd39ffd88fe">More...</a><br /></td></tr>
<tr class="separator:a62ee5052db73a221ffa31fd39ffd88fe inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b64a30f12a58f1593fecd71d8be021 inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a50b64a30f12a58f1593fecd71d8be021">has_pimpl_</a> () const noexcept</td></tr>
<tr class="memdesc:a50b64a30f12a58f1593fecd71d8be021 inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the instance has a PIMPL or not.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#a50b64a30f12a58f1593fecd71d8be021">More...</a><br /></td></tr>
<tr class="separator:a50b64a30f12a58f1593fecd71d8be021 inherit pro_methods_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad74fa4db4f86c86b8826d964a0704751"><td class="memTemplParams" colspan="2">template&lt;typename LHSField , typename RHSField &gt; </td></tr>
<tr class="memitem:ad74fa4db4f86c86b8826d964a0704751"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ad74fa4db4f86c86b8826d964a0704751">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; LHSField &gt; &amp;lhs, const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad74fa4db4f86c86b8826d964a0704751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances are different, non-polymorphically.  <a href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ad74fa4db4f86c86b8826d964a0704751">More...</a><br /></td></tr>
<tr class="separator:ad74fa4db4f86c86b8826d964a0704751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classtensorwrapper_1_1tensor_1_1Shape"><td colspan="2" onclick="javascript:toggleInherit('related_classtensorwrapper_1_1tensor_1_1Shape')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">tensorwrapper::tensor::Shape&lt; FieldType &gt;</a></td></tr>
<tr class="memitem:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classtensorwrapper_1_1tensor_1_1Shape"><td class="memTemplParams" colspan="2">template&lt;typename LHSType , typename RHSType &gt; </td></tr>
<tr class="memitem:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classtensorwrapper_1_1tensor_1_1Shape"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#aeaf2b480cf78a28a492aa683cd05a0dd">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a>&lt; LHSType &gt; &amp;lhs, const <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">Shape</a>&lt; RHSType &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classtensorwrapper_1_1tensor_1_1Shape"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> instances are different.  <a href="classtensorwrapper_1_1tensor_1_1Shape.html#aeaf2b480cf78a28a492aa683cd05a0dd">More...</a><br /></td></tr>
<tr class="separator:aeaf2b480cf78a28a492aa683cd05a0dd inherit related_classtensorwrapper_1_1tensor_1_1Shape"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename FieldType&gt;<br />
class tensorwrapper::tensor::SparseShape&lt; FieldType &gt;</h3>

<p>Describes a tensor's shape when there's sparsity. </p>
<p>This class uses a SparseMap and an allocator to properly determine which tiles are 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldType</td><td>Type of the elements in the field associated with the tensor. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a32fcd6de874861a5267006eb8e553835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fcd6de874861a5267006eb8e553835">&#9670;&nbsp;</a></span>extents_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">tensorwrapper::tensor::Shape</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a> =  std::vector&lt;<a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#af44543d687e89d35c2ee27ab4b3f3527">size_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type used to provide/return extents (outer extents for FieldType == Tensor) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeeefda7594056d21acf594388077b935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeefda7594056d21acf594388077b935">&#9670;&nbsp;</a></span>SparseShape() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">tensorwrapper::tensor::SparseShape</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a>&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a8dfc196e31e63400646ba22caa82f332">sparse_map_type</a>&#160;</td>
          <td class="paramname"><em>sm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents and a SparseMap. </p>
<p>This ctor delegates to the primary constructor. It assumes that the mapping from an independent and dependent index to a tensor index is simply concatenation, <em>e.g.</em>, given independent index (1, 2) and dependent index (3, 4) this function assumes that the corresponding tensor index is (1, 2; 3, 4) (semi-colon separating outer and inner tensor indices). This constructor is primarily of use when the shape is describing a ToT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The length of each mode.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The SparseMap specifying which dependent indices must be considered for a given independent index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the overall rank <code>sm</code> is inconsistent with the length of <code>extents</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f23e74b1d2579c53cd9d39250ba8d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f23e74b1d2579c53cd9d39250ba8d9c">&#9670;&nbsp;</a></span>SparseShape() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">tensorwrapper::tensor::SparseShape</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html#a32fcd6de874861a5267006eb8e553835">extents_type</a>&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#a8dfc196e31e63400646ba22caa82f332">sparse_map_type</a>&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#ae4a4d0a944702caf1a5db05516f3a3ca">idx2mode_type</a>&#160;</td>
          <td class="paramname"><em>i2m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> from extents, a SparseMap, and a mapping from SparseMap indices to tensor modes. </p>
<p>This is the primary constructor for creating a <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The length of each mode.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The SparseMap containing a map from independent indices to non-zero dependent indices.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx2mode</td><td>Assuming <code>sm</code> contains independent indices of rank <img class="formulaInl" alt="$i$" src="form_9.png"/>, and dependent indices of rank <img class="formulaInl" alt="$d$" src="form_26.png"/>, <code>idx2mode</code> is an <img class="formulaInl" alt="$i + d$" src="form_27.png"/> element vector such that for <img class="formulaInl" alt="$j&lt;i$" src="form_28.png"/> <code>idx2mode[j]</code> is the mode of the shape that the <img class="formulaInl" alt="$j$" src="form_10.png"/>-th independent mode maps to. For <img class="formulaInl" alt="$i &lt;= j &lt; i + d$" src="form_29.png"/> <code>idx2mode[j]</code> is the mode of the shape that the <img class="formulaInl" alt="$j-i$" src="form_30.png"/>-th dependent mode maps to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the overall rank of <code>sm</code> is inconsistent with the length of <code>idx2mode</code>. Strong throw gurantee. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>If any element of <code>idx2mode</code> is larger than the rank of the shape. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6e3c4731d4fa6fcc7d08588d4acb42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e3c4731d4fa6fcc7d08588d4acb42f">&#9670;&nbsp;</a></span>SparseShape() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">tensorwrapper::tensor::SparseShape</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a non-polymorphic copy of this instance. </p>
<p>This copy operation will deep-copy all state in the <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> part of the object (including the <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a> base class). This function is primarily used to implement Clone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance we are copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating memory. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aefba6693f38242d810d0b1999b11e043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefba6693f38242d810d0b1999b11e043">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">tensorwrapper::tensor::SparseShape</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-polymorphic comparison of two <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances. </p>
<p>Two <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances are equivalent if there base classes compare equal, they both have the same sparse map, and the sparse map indices are mapped to the tensor modes the same way. If a class derives from <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a>, any state in the derived class is not considered by this comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this instance compares equivalent to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1a7c602054d31eca502d428ba025f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a7c602054d31eca502d428ba025f15">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<div class="memtemplate">
template&lt;typename RHSField , typename  = disable_if_same_field_t&lt;RHSField&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">tensorwrapper::tensor::SparseShape</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements operator== for different fields. </p>
<p>If two <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances have different fields they are not equal. This function is chosen when the two <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances have different fields and will return false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RHSField</td><td>The type of field <code>rhs</code> is defined over. Assumed to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>. </td></tr>
    <tr><td class="paramname">&lt;anonymous&gt;</td><td>Used to enable this function, via SFINAE, when <code>RHSField</code> is different from FieldType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False. This function is only used when the fields are different, in which case the shapes are also different.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad74fa4db4f86c86b8826d964a0704751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74fa4db4f86c86b8826d964a0704751">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSField , typename RHSField &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; LHSField &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html">SparseShape</a>&lt; RHSField &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances are different, non-polymorphically. </p>
<p>This function simply negates <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#aefba6693f38242d810d0b1999b11e043" title="Non-polymorphic comparison of two SparseShape instances.">SparseShape::operator==</a>. See documentation for <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html#aefba6693f38242d810d0b1999b11e043" title="Non-polymorphic comparison of two SparseShape instances.">SparseShape::operator==</a> for what constitutes equivalency for <a class="el" href="classtensorwrapper_1_1tensor_1_1SparseShape.html" title="Describes a tensor&#39;s shape when there&#39;s sparsity.">SparseShape</a> instances.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSField</td><td>The type of the field associated with <code>lhs</code>. Assumed to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>. </td></tr>
    <tr><td class="paramname">RHSField</td><td>The type of the field associated with <code>rhs</code>. Assumed to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The shape instance on the left side of the comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The shape instance on the right side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <code>lhs</code> and <code>rhs</code> compare equal and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tensorwrapper/tensor/shapes/<a class="el" href="sparse__shape_8hpp_source.html">sparse_shape.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
