<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tensorwrapper<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetensorwrapper.html">tensorwrapper</a></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1utilities.html">utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tensorwrapper::utilities Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for helper functions.  
<a href="namespacetensorwrapper_1_1utilities.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aefdedef162f875b7cc860ac94476603c" id="r_aefdedef162f875b7cc860ac94476603c"><td class="memItemLeft" align="right" valign="top"><a id="aefdedef162f875b7cc860ac94476603c" name="aefdedef162f875b7cc860ac94476603c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>offset_type</b> = std::size_t</td></tr>
<tr class="separator:aefdedef162f875b7cc860ac94476603c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7960a4930e23b5d7c012353f487401" id="r_a4e7960a4930e23b5d7c012353f487401"><td class="memItemLeft" align="right" valign="top"><a id="a4e7960a4930e23b5d7c012353f487401" name="a4e7960a4930e23b5d7c012353f487401"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>offset_vector</b> = std::vector&lt; offset_type &gt;</td></tr>
<tr class="separator:a4e7960a4930e23b5d7c012353f487401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c96846ed35db6038c5f7cef54b58f16" id="r_a7c96846ed35db6038c5f7cef54b58f16"><td class="memTemplParams" colspan="2"><a id="a7c96846ed35db6038c5f7cef54b58f16" name="a7c96846ed35db6038c5f7cef54b58f16"></a>
template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:a7c96846ed35db6038c5f7cef54b58f16"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>buffer_type</b> = <a class="el" href="classtensorwrapper_1_1buffer_1_1Contiguous.html">buffer::Contiguous</a>&lt; DataType &gt;</td></tr>
<tr class="separator:a7c96846ed35db6038c5f7cef54b58f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0774866423ee9cc913691920250088e2" id="r_a0774866423ee9cc913691920250088e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1utilities.html#a0774866423ee9cc913691920250088e2">block_diagonal_matrix</a> (std::vector&lt; <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &gt; matrices)</td></tr>
<tr class="memdesc:a0774866423ee9cc913691920250088e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a block diagonal matrix from a set of square matrices.  <br /></td></tr>
<tr class="separator:a0774866423ee9cc913691920250088e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb0104fde24d1a4aaef8f5e00c69ee" id="r_aa2cb0104fde24d1a4aaef8f5e00c69ee"><td class="memTemplParams" colspan="2">template&lt;typename KernelType , typename BufferType , typename... Args&gt; </td></tr>
<tr class="memitem:aa2cb0104fde24d1a4aaef8f5e00c69ee"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1utilities.html#aa2cb0104fde24d1a4aaef8f5e00c69ee">floating_point_dispatch</a> (KernelType &amp;&amp;kernel, BufferType &amp;&amp;buffer, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa2cb0104fde24d1a4aaef8f5e00c69ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the logic needed to work out the floating point type of buffer.  <br /></td></tr>
<tr class="separator:aa2cb0104fde24d1a4aaef8f5e00c69ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d89014992766effe38b8f7eb20cf8c" id="r_aa2d89014992766effe38b8f7eb20cf8c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetensorwrapper_1_1utilities.html#aa2d89014992766effe38b8f7eb20cf8c">to_json</a> (std::ostream &amp;os, const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;t)</td></tr>
<tr class="memdesc:aa2d89014992766effe38b8f7eb20cf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a JSON representation of <code>to</code> <code>os</code>.  <br /></td></tr>
<tr class="separator:aa2d89014992766effe38b8f7eb20cf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be514f8b2bb43b9b8bec3cfb29ddf3f" id="r_a4be514f8b2bb43b9b8bec3cfb29ddf3f"><td class="memTemplParams" colspan="2"><a id="a4be514f8b2bb43b9b8bec3cfb29ddf3f" name="a4be514f8b2bb43b9b8bec3cfb29ddf3f"></a>
template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:a4be514f8b2bb43b9b8bec3cfb29ddf3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_json_</b> (std::ostream &amp;os, const <a class="el" href="classtensorwrapper_1_1buffer_1_1Contiguous.html">buffer_type</a>&lt; DataType &gt; &amp;t, offset_vector index)</td></tr>
<tr class="separator:a4be514f8b2bb43b9b8bec3cfb29ddf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for helper functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a0774866423ee9cc913691920250088e2" name="a0774866423ee9cc913691920250088e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0774866423ee9cc913691920250088e2">&#9670;&#160;</a></span>block_diagonal_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> tensorwrapper::utilities::block_diagonal_matrix </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>matrices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a block diagonal matrix from a set of square matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrices</td><td>The vector of matrices to be placed along the output diagonal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A block diagonal matrix whose block values are equal to the input matrices. </dd></dl>

</div>
</div>
<a id="aa2cb0104fde24d1a4aaef8f5e00c69ee" name="aa2cb0104fde24d1a4aaef8f5e00c69ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb0104fde24d1a4aaef8f5e00c69ee">&#9670;&#160;</a></span>floating_point_dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelType , typename BufferType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) tensorwrapper::utilities::floating_point_dispatch </td>
          <td>(</td>
          <td class="paramtype">KernelType &amp;&amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferType &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps the logic needed to work out the floating point type of buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KernelType</td><td>Type of a functor. The functor must define a function template called <code>run</code> that takes one explicit template type parameter (will be the floating point type of <code>buffer</code>) and <code>buffer</code>. <code>run</code> may take an arbitrary amount of additional arguments. </td></tr>
    <tr><td class="paramname">BufferType</td><td>The type of <code>buffer</code>. Must be derived from BufferBase. May contain cv or reference qualifiers. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of any additional arguments which will be forwarded to <code>kernel</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel</td><td>The functor instance to call <code>run</code> on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The type of the elements in <code>buffer</code> will be used to dispatch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Any additional arguments to forward to <code>kernel</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whatever <code>kernel</code> returns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>buffer</code> is not derived from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2d89014992766effe38b8f7eb20cf8c" name="aa2d89014992766effe38b8f7eb20cf8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d89014992766effe38b8f7eb20cf8c">&#9670;&#160;</a></span>to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; tensorwrapper::utilities::to_json </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a JSON representation of <code>to</code> <code>os</code>. </p>
<p>This function can be used to print a tensor out in a JSON format. For dense tensors this will be as a list of lists such that number of nestings is equal to the rank of the tensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream to print <code>t</code> to. After the function is called <code>os</code> will contain the JSON representation of <code>t</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The tensor to print to <code>os</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Since the caller controls the stream that is passed in, it is assumed that the caller has set the stream up to print floating point values in their desired format. For example, do <code>os &lt;&lt; std::fixed &lt;&lt; std::setprecision(8);</code> prior to calling <code>to_json</code> to guarantee all floating point values are printed with 8 decimal places.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns <code>os</code> by reference to support chaining. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
