<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::tensor::expression::Expression&lt; FieldType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorwrapper</b></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1tensor.html">tensor</a></li><li class="navelem"><b>expression</b></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::tensor::expression::Expression&lt; FieldType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A piece of a type-erased tensor expression.  
 <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="expression__class_8hpp_source.html">expression_class.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2d8a8fd320abbe3b3ccefdc8fde22e17"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a2d8a8fd320abbe3b3ccefdc8fde22e17">label_type</a> = typename ft::label_type</td></tr>
<tr class="separator:a2d8a8fd320abbe3b3ccefdc8fde22e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822c62091042646825be8f83cb1c98d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a822c62091042646825be8f83cb1c98d9">const_label_reference</a> = typename ft::const_label_reference</td></tr>
<tr class="separator:a822c62091042646825be8f83cb1c98d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61a71c143796fcde0b642deb0f1a7e1"><td class="memItemLeft" align="right" valign="top"><a id="ad61a71c143796fcde0b642deb0f1a7e1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ad61a71c143796fcde0b642deb0f1a7e1">tensor_type</a> = typename <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">ft::tensor_type</a></td></tr>
<tr class="memdesc:ad61a71c143796fcde0b642deb0f1a7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a tensor. Defined by FieldTraits&lt;FieldType&gt;::tensor_type. <br /></td></tr>
<tr class="separator:ad61a71c143796fcde0b642deb0f1a7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2055333023397fc7248565d51e2ee646"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a2055333023397fc7248565d51e2ee646">const_allocator_reference</a> = typename <a class="el" href="classtensorwrapper_1_1tensor_1_1allocator_1_1Allocator.html">ft::const_allocator_reference</a></td></tr>
<tr class="separator:a2055333023397fc7248565d51e2ee646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f3449c129ab53532d200913847b7fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#af4f3449c129ab53532d200913847b7fb">const_shape_reference</a> = typename <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">ft::const_shape_reference</a></td></tr>
<tr class="separator:af4f3449c129ab53532d200913847b7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd59c613296e2ec8cd53f951d998925"><td class="memItemLeft" align="right" valign="top"><a id="a1fd59c613296e2ec8cd53f951d998925"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a1fd59c613296e2ec8cd53f951d998925">pimpl_type</a> = <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1detail___1_1ExpressionPIMPL.html">detail_::ExpressionPIMPL</a>&lt; FieldType &gt;</td></tr>
<tr class="memdesc:a1fd59c613296e2ec8cd53f951d998925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the object implementing *this. <br /></td></tr>
<tr class="separator:a1fd59c613296e2ec8cd53f951d998925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c09651a44b28f0759bee276fd52b90e"><td class="memItemLeft" align="right" valign="top"><a id="a1c09651a44b28f0759bee276fd52b90e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a1c09651a44b28f0759bee276fd52b90e">pimpl_pointer</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a1fd59c613296e2ec8cd53f951d998925">pimpl_type</a> &gt;</td></tr>
<tr class="memdesc:a1c09651a44b28f0759bee276fd52b90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to a pimpl_type instance. <br /></td></tr>
<tr class="separator:a1c09651a44b28f0759bee276fd52b90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4c10179ce315246c12524ae3006aa8ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a4c10179ce315246c12524ae3006aa8ab">Expression</a> () noexcept</td></tr>
<tr class="memdesc:a4c10179ce315246c12524ae3006aa8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a4c10179ce315246c12524ae3006aa8ab">More...</a><br /></td></tr>
<tr class="separator:a4c10179ce315246c12524ae3006aa8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35bbe9d5b51baa79196e0d2f94088d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ac35bbe9d5b51baa79196e0d2f94088d5">Expression</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a1c09651a44b28f0759bee276fd52b90e">pimpl_pointer</a> p) noexcept</td></tr>
<tr class="memdesc:ac35bbe9d5b51baa79196e0d2f94088d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> with the specified state.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ac35bbe9d5b51baa79196e0d2f94088d5">More...</a><br /></td></tr>
<tr class="separator:ac35bbe9d5b51baa79196e0d2f94088d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4d4754e8b6a1b01dc97a59d0b2f65c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a7d4d4754e8b6a1b01dc97a59d0b2f65c">Expression</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;other)</td></tr>
<tr class="memdesc:a7d4d4754e8b6a1b01dc97a59d0b2f65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> which is a deep copy of <code>other</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a7d4d4754e8b6a1b01dc97a59d0b2f65c">More...</a><br /></td></tr>
<tr class="separator:a7d4d4754e8b6a1b01dc97a59d0b2f65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbc4eefab5c9fee2fb0281f10a14215"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a4cbc4eefab5c9fee2fb0281f10a14215">Expression</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a4cbc4eefab5c9fee2fb0281f10a14215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> which takes ownership of the state in <code>other</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a4cbc4eefab5c9fee2fb0281f10a14215">More...</a><br /></td></tr>
<tr class="separator:a4cbc4eefab5c9fee2fb0281f10a14215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad147672b10295d52cc7e940cf56c9865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ad147672b10295d52cc7e940cf56c9865">operator=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad147672b10295d52cc7e940cf56c9865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state of *this to a deep copy of the state in <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ad147672b10295d52cc7e940cf56c9865">More...</a><br /></td></tr>
<tr class="separator:ad147672b10295d52cc7e940cf56c9865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22542c6b7ea0ebe93a09775cf063b529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a22542c6b7ea0ebe93a09775cf063b529">operator=</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a22542c6b7ea0ebe93a09775cf063b529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state of *this to the state in <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a22542c6b7ea0ebe93a09775cf063b529">More...</a><br /></td></tr>
<tr class="separator:a22542c6b7ea0ebe93a09775cf063b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1864f8e5e20422ae4e4e05318e6d1c72"><td class="memItemLeft" align="right" valign="top"><a id="a1864f8e5e20422ae4e4e05318e6d1c72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a1864f8e5e20422ae4e4e05318e6d1c72">~Expression</a> () noexcept</td></tr>
<tr class="memdesc:a1864f8e5e20422ae4e4e05318e6d1c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default no-throw dtor. <br /></td></tr>
<tr class="separator:a1864f8e5e20422ae4e4e05318e6d1c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140e0af96c8907279143c989f658d83b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a140e0af96c8907279143c989f658d83b">operator+</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a140e0af96c8907279143c989f658d83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds *this to <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a140e0af96c8907279143c989f658d83b">More...</a><br /></td></tr>
<tr class="separator:a140e0af96c8907279143c989f658d83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a012772dc7eaf8e6907ed3348a20607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a5a012772dc7eaf8e6907ed3348a20607">operator-</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a5a012772dc7eaf8e6907ed3348a20607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts <code>rhs</code> from *this.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a5a012772dc7eaf8e6907ed3348a20607">More...</a><br /></td></tr>
<tr class="separator:a5a012772dc7eaf8e6907ed3348a20607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d8aa33653f5a4608a91d73339d235d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a31d8aa33653f5a4608a91d73339d235d">operator*</a> (double rhs) const</td></tr>
<tr class="memdesc:a31d8aa33653f5a4608a91d73339d235d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales *this by <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a31d8aa33653f5a4608a91d73339d235d">More...</a><br /></td></tr>
<tr class="separator:a31d8aa33653f5a4608a91d73339d235d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1426242d9f58812aea955a0c75eb90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a9d1426242d9f58812aea955a0c75eb90">operator*</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a9d1426242d9f58812aea955a0c75eb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies *this and <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a9d1426242d9f58812aea955a0c75eb90">More...</a><br /></td></tr>
<tr class="separator:a9d1426242d9f58812aea955a0c75eb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42766b871072883f8e55a44d468c5f6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a2d8a8fd320abbe3b3ccefdc8fde22e17">label_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a42766b871072883f8e55a44d468c5f6c">labels</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a822c62091042646825be8f83cb1c98d9">const_label_reference</a> lhs_labels) const</td></tr>
<tr class="memdesc:a42766b871072883f8e55a44d468c5f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the labels for the tensor resulting from this expression.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a42766b871072883f8e55a44d468c5f6c">More...</a><br /></td></tr>
<tr class="separator:a42766b871072883f8e55a44d468c5f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca724fe3ea3538050a621d01bb55f18c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ad61a71c143796fcde0b642deb0f1a7e1">tensor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#aca724fe3ea3538050a621d01bb55f18c">tensor</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a822c62091042646825be8f83cb1c98d9">const_label_reference</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a42766b871072883f8e55a44d468c5f6c">labels</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#af4f3449c129ab53532d200913847b7fb">const_shape_reference</a> shape, <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a2055333023397fc7248565d51e2ee646">const_allocator_reference</a> alloc) const</td></tr>
<tr class="memdesc:aca724fe3ea3538050a621d01bb55f18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates *this into a tensor with the specified state.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#aca724fe3ea3538050a621d01bb55f18c">More...</a><br /></td></tr>
<tr class="separator:aca724fe3ea3538050a621d01bb55f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d973df83fdecb71c03c6c70a59730c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ae1d973df83fdecb71c03c6c70a59730c">is_empty</a> () const noexcept</td></tr>
<tr class="memdesc:ae1d973df83fdecb71c03c6c70a59730c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance empty?  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ae1d973df83fdecb71c03c6c70a59730c">More...</a><br /></td></tr>
<tr class="separator:ae1d973df83fdecb71c03c6c70a59730c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6eb101fc5ec14fc3dd69f04c92d513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ace6eb101fc5ec14fc3dd69f04c92d513">swap</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ace6eb101fc5ec14fc3dd69f04c92d513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the state of two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ace6eb101fc5ec14fc3dd69f04c92d513">More...</a><br /></td></tr>
<tr class="separator:ace6eb101fc5ec14fc3dd69f04c92d513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab126788974ca7e0d9d9ccb0148db9eda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ab126788974ca7e0d9d9ccb0148db9eda">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ab126788974ca7e0d9d9ccb0148db9eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances are value equal.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ab126788974ca7e0d9d9ccb0148db9eda">More...</a><br /></td></tr>
<tr class="separator:ab126788974ca7e0d9d9ccb0148db9eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f7a383662cddc8704860abdeff2ab6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a56f7a383662cddc8704860abdeff2ab6">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a56f7a383662cddc8704860abdeff2ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances are different.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a56f7a383662cddc8704860abdeff2ab6">More...</a><br /></td></tr>
<tr class="separator:a56f7a383662cddc8704860abdeff2ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename FieldType&gt;<br />
class tensorwrapper::tensor::expression::Expression&lt; FieldType &gt;</h3>

<p>A piece of a type-erased tensor expression. </p>
<p>Doing math with <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instances uses a domain specific language (DSL). <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances are type-erased pieces of the DSL. By using type-erasure (as opposed to expression templating which is more common) it is easier to perform runtime manipulations on the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> layer. Each piece of the DSL contains a lazy operation. For example an <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance meant to add two tensors, will simply hold two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances (which themselves are also lazy operations) and not add the sub instances together until told to (by calling <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#aca724fe3ea3538050a621d01bb55f18c" title="Evaluates *this into a tensor with the specified state.">tensor()</a>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldType</td><td>A strong type indicating whether the tensors in the expression contain scalars or tensors as elements. Expected to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2055333023397fc7248565d51e2ee646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2055333023397fc7248565d51e2ee646">&#9670;&nbsp;</a></span>const_allocator_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a2055333023397fc7248565d51e2ee646">const_allocator_reference</a> =  typename <a class="el" href="classtensorwrapper_1_1tensor_1_1allocator_1_1Allocator.html">ft::const_allocator_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a read-only Allocator. Ultimately defined by FieldTraits&lt;FieldType&gt;::const_allocator_reference </p>

</div>
</div>
<a id="a822c62091042646825be8f83cb1c98d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822c62091042646825be8f83cb1c98d9">&#9670;&nbsp;</a></span>const_label_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a822c62091042646825be8f83cb1c98d9">const_label_reference</a> =  typename ft::const_label_reference</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a read-only reference to labels. Ultimately defined by FieldTraits&lt;FieldType&gt;::const_label_reference </p>

</div>
</div>
<a id="af4f3449c129ab53532d200913847b7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f3449c129ab53532d200913847b7fb">&#9670;&nbsp;</a></span>const_shape_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#af4f3449c129ab53532d200913847b7fb">const_shape_reference</a> =  typename <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html">ft::const_shape_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a read-only <a class="el" href="classtensorwrapper_1_1tensor_1_1Shape.html" title="Object describing a tensor&#39;s elemental layout.">Shape</a>. Ultimately defined by FieldTraits&lt;FieldType&gt;::const_shape_reference </p>

</div>
</div>
<a id="a2d8a8fd320abbe3b3ccefdc8fde22e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8a8fd320abbe3b3ccefdc8fde22e17">&#9670;&nbsp;</a></span>label_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a2d8a8fd320abbe3b3ccefdc8fde22e17">label_type</a> =  typename ft::label_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type used to label tensors. Ultimately defined by FieldTraits&lt;FieldType&gt;::label_type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4c10179ce315246c12524ae3006aa8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c10179ce315246c12524ae3006aa8ab">&#9670;&nbsp;</a></span>Expression() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a>. </p>
<p>This Ctor creates an empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> (i.e., an <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> wrapping no state). Empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances are typically used as placeholders. To convert an empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> to a non-empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> a user must assign a non-empty Expressio to it.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac35bbe9d5b51baa79196e0d2f94088d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35bbe9d5b51baa79196e0d2f94088d5">&#9670;&nbsp;</a></span>Expression() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a1c09651a44b28f0759bee276fd52b90e">pimpl_pointer</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> with the specified state. </p>
<p>This Ctor can be used to create either an empty or non-empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a>. Providing a null pointer will create an empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a>, whereas providing a non-null pointer creates a non-empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a>. Users of <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> will in general not directly create non-empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances. Rather, non-empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances are created automatically by the DSL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A PIMPL to the implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d4d4754e8b6a1b01dc97a59d0b2f65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4d4754e8b6a1b01dc97a59d0b2f65c">&#9670;&nbsp;</a></span>Expression() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> which is a deep copy of <code>other</code>. </p>
<p>This ctor creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> which is a deep copy of <code>other</code>. In practice <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances are defined in terms of <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instances (which alias <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> instances on deep copy) .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>This method throws if calling the PIMPL's copy ctor throws. At the moment PIMPL copy ctors only throw if there is a problem allocating. Strong throw guarantee </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cbc4eefab5c9fee2fb0281f10a14215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbc4eefab5c9fee2fb0281f10a14215">&#9670;&nbsp;</a></span>Expression() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> which takes ownership of the state in <code>other</code>. </p>
<p>This ctor passes ownership of <code>other's</code> internal state to the newly created instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> we are taking the state from. After calling this method <code>other</code> will be in an empty state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1d973df83fdecb71c03c6c70a59730c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d973df83fdecb71c03c6c70a59730c">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance empty? </p>
<p>An <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance is empty if it does not contain a PIMPL. This can occur because the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> was default initialized, initialized with a null pointer, or because it was moved from. This method can be used to determine if the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>True if *this is empty and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42766b871072883f8e55a44d468c5f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42766b871072883f8e55a44d468c5f6c">&#9670;&nbsp;</a></span>labels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a2d8a8fd320abbe3b3ccefdc8fde22e17">label_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::labels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a822c62091042646825be8f83cb1c98d9">const_label_reference</a>&#160;</td>
          <td class="paramname"><em>lhs_labels</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the labels for the tensor resulting from this expression. </p>
<p>Expressions are typically a tree-like object in which each <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance contains sub-Expression instances. The entire treee ultimately gets assigned to a labeled tensor. This method is given the target labels for the entire expression tree and returns the labels for the sub-tree held in *this. For simple trees the result of this call will usually just be <code>lhs_labels</code>; however, for more complicated trees the result may differ depending on whether it is possible to account for permutations of modes in the wrapped operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs_labels</td><td>The labels on the tensor to which the entire <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> tree is being assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The labels for the tensor in to which *this should be assigned. Note that sub-expressions are evaluated into temporary tensors and the result need not equal <code>lhs_labels</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If *this is empty. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56f7a383662cddc8704860abdeff2ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f7a383662cddc8704860abdeff2ab6">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances are different. </p>
<p>This function simply negates operator==. In turn we define two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances as different if they are not value equal. See the description of operator== for the definition of value equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance being compared to *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if *this is value equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d1426242d9f58812aea955a0c75eb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1426242d9f58812aea955a0c75eb90">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies *this and <code>rhs</code>. </p>
<p>This operator is used for element-wise multiplication and contractions. Whether the operation is element-wise, contraction, or a mixture depends on the labels of the tensors involved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> being multiplied with *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance, which when evaluated will return the product of *this and <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If *this or <code>rhs</code> is empty. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the PIMPL for the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31d8aa33653f5a4608a91d73339d235d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d8aa33653f5a4608a91d73339d235d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales *this by <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The value to scale *this by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance, which when evaluated will return the scale *this by <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this is empty. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the PIMPL for the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a140e0af96c8907279143c989f658d83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140e0af96c8907279143c989f658d83b">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds *this to <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> being added to *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance, which when evaluated will return the sum of *this and <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If *this or <code>rhs</code> is empty. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the PIMPL for the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a012772dc7eaf8e6907ed3348a20607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a012772dc7eaf8e6907ed3348a20607">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts <code>rhs</code> from *this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> being subtracted from *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance, which when evaluated will return the difference between *this and <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If *this or <code>rhs</code> is empty. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the PIMPL for the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad147672b10295d52cc7e940cf56c9865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad147672b10295d52cc7e940cf56c9865">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&amp; <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state of *this to a deep copy of the state in <code>rhs</code>. </p>
<p>This method will overwrite the state *this holds (freeing it up in the process) with a deep copy of the state in <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state is being copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this after setting the internal state to a deep copy of <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>This method throws if calling the PIMPL's copy ctor throws. At the moment PIMPL copy ctors only throw if there is a problem allocating. Strong throw guarantee </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22542c6b7ea0ebe93a09775cf063b529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22542c6b7ea0ebe93a09775cf063b529">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&amp; <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the state of *this to the state in <code>rhs</code>. </p>
<p>This method will overwrite the state of *this (freeing it up in the process) with the state contained in <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The instance whose state is being transferred to *this. After this method <code>rhs</code> will behave like an empty <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this after taking ownership of the state in <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab126788974ca7e0d9d9ccb0148db9eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab126788974ca7e0d9d9ccb0148db9eda">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances are value equal. </p>
<p>Two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances are value equal if they are both empty or if they both contain PIMPLs which are value equal. PIMPLs are value equal if they both describe the same operation (e.g., both are addition or both are multiplication), and if any subexpressions comapre value equal. N.B. that recursion stops when reaching labeled tensors and the subexpressions wrapping the labeled tensors are value equal if the labels on the tensors are equal and the tensors compare value equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance being compared to *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this is value equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace6eb101fc5ec14fc3dd69f04c92d513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6eb101fc5ec14fc3dd69f04c92d513">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the state of two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances. </p>
<p>This method will swap the state of two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The instance whose state is being exchanged with *this. After this call <code>rhs</code> will have the state *this had prior to the call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca724fe3ea3538050a621d01bb55f18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca724fe3ea3538050a621d01bb55f18c">&#9670;&nbsp;</a></span>tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#ad61a71c143796fcde0b642deb0f1a7e1">tensor_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">tensorwrapper::tensor::expression::Expression</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">tensor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a822c62091042646825be8f83cb1c98d9">const_label_reference</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#af4f3449c129ab53532d200913847b7fb">const_shape_reference</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html#a2055333023397fc7248565d51e2ee646">const_allocator_reference</a>&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates *this into a tensor with the specified state. </p>
<p>This method is used to actually evaluate *this. The inputs to this method describe the tensor instance in to which *this is being directly assigned (this may only be a temporary intermediate and not represent the final result). It is this method's responsibility to do any transformation necessary to put the contents of *this into such a tensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>The labels for the tensor *this is being assigned to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The shape object of the tensor *this is being assigned to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>The allocator for the tensor *this is being assigned to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor resulting from evaluating *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this is empty. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tensorwrapper/tensor/expression/<a class="el" href="expression__class_8hpp_source.html">expression_class.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
