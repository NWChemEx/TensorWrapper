<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::tensor::expression::LabeledView&lt; FieldType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorwrapper</b></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1tensor.html">tensor</a></li><li class="navelem"><b>expression</b></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::tensor::expression::LabeledView&lt; FieldType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Associates an annotation with a reference to a tensor.  
 <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="labeled__view_8hpp_source.html">labeled_view.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a54b7dd1255aa1644b850f533184c067d"><td class="memItemLeft" align="right" valign="top"><a id="a54b7dd1255aa1644b850f533184c067d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a54b7dd1255aa1644b850f533184c067d">tensor_type</a> = <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">TensorWrapper</a>&lt; FieldType &gt;</td></tr>
<tr class="memdesc:a54b7dd1255aa1644b850f533184c067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the tensor this is a view of. <br /></td></tr>
<tr class="separator:a54b7dd1255aa1644b850f533184c067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809711f9cfa5864d97609a0959116933"><td class="memItemLeft" align="right" valign="top"><a id="a809711f9cfa5864d97609a0959116933"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a809711f9cfa5864d97609a0959116933">tensor_reference</a> = <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a54b7dd1255aa1644b850f533184c067d">tensor_type</a> &amp;</td></tr>
<tr class="memdesc:a809711f9cfa5864d97609a0959116933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read/write reference to the tensor this is a view of. <br /></td></tr>
<tr class="separator:a809711f9cfa5864d97609a0959116933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77eb8a16420a07abfc4b186956aabe53"><td class="memItemLeft" align="right" valign="top"><a id="a77eb8a16420a07abfc4b186956aabe53"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a77eb8a16420a07abfc4b186956aabe53">const_tensor_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a54b7dd1255aa1644b850f533184c067d">tensor_type</a> &amp;</td></tr>
<tr class="memdesc:a77eb8a16420a07abfc4b186956aabe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the tensor this is a view of. <br /></td></tr>
<tr class="separator:a77eb8a16420a07abfc4b186956aabe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71538e02e15f10f09bdfda913be4e201"><td class="memItemLeft" align="right" valign="top"><a id="a71538e02e15f10f09bdfda913be4e201"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a71538e02e15f10f09bdfda913be4e201">label_type</a> = std::string</td></tr>
<tr class="memdesc:a71538e02e15f10f09bdfda913be4e201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to label the modes of the tensor. <br /></td></tr>
<tr class="separator:a71538e02e15f10f09bdfda913be4e201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd5c5741315a83ba83bcd3b172701eb"><td class="memItemLeft" align="right" valign="top"><a id="addd5c5741315a83ba83bcd3b172701eb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#addd5c5741315a83ba83bcd3b172701eb">const_label_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a71538e02e15f10f09bdfda913be4e201">label_type</a> &amp;</td></tr>
<tr class="memdesc:addd5c5741315a83ba83bcd3b172701eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the tensor's labels. <br /></td></tr>
<tr class="separator:addd5c5741315a83ba83bcd3b172701eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dde012a3b9a3cf3104370fc53c8d883"><td class="memItemLeft" align="right" valign="top"><a id="a3dde012a3b9a3cf3104370fc53c8d883"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a> = <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html">Expression</a>&lt; FieldType &gt;</td></tr>
<tr class="memdesc:a3dde012a3b9a3cf3104370fc53c8d883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type resulting from promoting this instance to the expression layer. <br /></td></tr>
<tr class="separator:a3dde012a3b9a3cf3104370fc53c8d883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c77f312ec373067558974dda327aa40"><td class="memItemLeft" align="right" valign="top"><a id="a9c77f312ec373067558974dda327aa40"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a9c77f312ec373067558974dda327aa40">const_expression_reference</a> = const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a> &amp;</td></tr>
<tr class="memdesc:a9c77f312ec373067558974dda327aa40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only reference to object in the expression layer. <br /></td></tr>
<tr class="separator:a9c77f312ec373067558974dda327aa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abd93c1d0540d4158ba35173d409a1f05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#abd93c1d0540d4158ba35173d409a1f05">LabeledView</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a71538e02e15f10f09bdfda913be4e201">label_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ab6c93c2907397d6979d838afd17c53a2">labels</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a809711f9cfa5864d97609a0959116933">tensor_reference</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">tensor</a>) noexcept</td></tr>
<tr class="memdesc:abd93c1d0540d4158ba35173d409a1f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotates a read/write view of a tensor.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#abd93c1d0540d4158ba35173d409a1f05">More...</a><br /></td></tr>
<tr class="separator:abd93c1d0540d4158ba35173d409a1f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc041680aa79b0f66a725956c1a84d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a2bc041680aa79b0f66a725956c1a84d8">LabeledView</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a71538e02e15f10f09bdfda913be4e201">label_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ab6c93c2907397d6979d838afd17c53a2">labels</a>, <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a77eb8a16420a07abfc4b186956aabe53">const_tensor_reference</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">tensor</a>) noexcept</td></tr>
<tr class="memdesc:a2bc041680aa79b0f66a725956c1a84d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotates a read-only view of a tensor.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a2bc041680aa79b0f66a725956c1a84d8">More...</a><br /></td></tr>
<tr class="separator:a2bc041680aa79b0f66a725956c1a84d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d5c7e2b201be7d493278b1eb1ae5ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a96d5c7e2b201be7d493278b1eb1ae5ca">LabeledView</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;other)=default</td></tr>
<tr class="memdesc:a96d5c7e2b201be7d493278b1eb1ae5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> which is a copy of <code>other</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a96d5c7e2b201be7d493278b1eb1ae5ca">More...</a><br /></td></tr>
<tr class="separator:a96d5c7e2b201be7d493278b1eb1ae5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c94e4014a6f8822448847bb6c148a53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3c94e4014a6f8822448847bb6c148a53">LabeledView</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a3c94e4014a6f8822448847bb6c148a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> which owns the state of <code>other</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3c94e4014a6f8822448847bb6c148a53">More...</a><br /></td></tr>
<tr class="separator:a3c94e4014a6f8822448847bb6c148a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624760c7670e7f43e7d9191c2ec231b0"><td class="memItemLeft" align="right" valign="top"><a id="a624760c7670e7f43e7d9191c2ec231b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a624760c7670e7f43e7d9191c2ec231b0">~LabeledView</a> () noexcept=default</td></tr>
<tr class="memdesc:a624760c7670e7f43e7d9191c2ec231b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default no-throw dtor (N.B. the aliased tensor is NOT cleaned-up) <br /></td></tr>
<tr class="separator:a624760c7670e7f43e7d9191c2ec231b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3606fbb2bfcff6046c169a2345cf5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#abd3606fbb2bfcff6046c169a2345cf5d">expression</a> () const</td></tr>
<tr class="memdesc:abd3606fbb2bfcff6046c169a2345cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps this <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> in an <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> class.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#abd3606fbb2bfcff6046c169a2345cf5d">More...</a><br /></td></tr>
<tr class="separator:abd3606fbb2bfcff6046c169a2345cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0903ad58edc4cb9cf6f2d1dcae0c5b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a809711f9cfa5864d97609a0959116933">tensor_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ae0903ad58edc4cb9cf6f2d1dcae0c5b1">tensor</a> ()</td></tr>
<tr class="memdesc:ae0903ad58edc4cb9cf6f2d1dcae0c5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides read/write access to the aliased tensor.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ae0903ad58edc4cb9cf6f2d1dcae0c5b1">More...</a><br /></td></tr>
<tr class="separator:ae0903ad58edc4cb9cf6f2d1dcae0c5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862591318dd90711b380453d4e5a61ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a77eb8a16420a07abfc4b186956aabe53">const_tensor_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a862591318dd90711b380453d4e5a61ab">tensor</a> () const</td></tr>
<tr class="memdesc:a862591318dd90711b380453d4e5a61ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides read-only access to the aliased tensor.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a862591318dd90711b380453d4e5a61ab">More...</a><br /></td></tr>
<tr class="separator:a862591318dd90711b380453d4e5a61ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c93c2907397d6979d838afd17c53a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#addd5c5741315a83ba83bcd3b172701eb">const_label_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ab6c93c2907397d6979d838afd17c53a2">labels</a> () const</td></tr>
<tr class="memdesc:ab6c93c2907397d6979d838afd17c53a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides read-only access to the labels annotating the tensor.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ab6c93c2907397d6979d838afd17c53a2">More...</a><br /></td></tr>
<tr class="separator:ab6c93c2907397d6979d838afd17c53a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f00e6d2dc35a55b44df6d0e851e7e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a71f00e6d2dc35a55b44df6d0e851e7e3">operator=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;rhs)</td></tr>
<tr class="memdesc:a71f00e6d2dc35a55b44df6d0e851e7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the contents by transforming <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a71f00e6d2dc35a55b44df6d0e851e7e3">More...</a><br /></td></tr>
<tr class="separator:a71f00e6d2dc35a55b44df6d0e851e7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372e55c5408da353d0b5c2aa185b830a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a372e55c5408da353d0b5c2aa185b830a">operator=</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a9c77f312ec373067558974dda327aa40">const_expression_reference</a> rhs)</td></tr>
<tr class="memdesc:a372e55c5408da353d0b5c2aa185b830a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the contents by evaluating <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a372e55c5408da353d0b5c2aa185b830a">More...</a><br /></td></tr>
<tr class="separator:a372e55c5408da353d0b5c2aa185b830a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410eb7345af1bad283fcaf4f3034ba6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a410eb7345af1bad283fcaf4f3034ba6a">operator+</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a410eb7345af1bad283fcaf4f3034ba6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expression that sums *this and <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a410eb7345af1bad283fcaf4f3034ba6a">More...</a><br /></td></tr>
<tr class="separator:a410eb7345af1bad283fcaf4f3034ba6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bf19538024c33c9c51050ed103d0ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a44bf19538024c33c9c51050ed103d0ea">operator-</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a44bf19538024c33c9c51050ed103d0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expression that subtracts <code>rhs</code> from *this.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a44bf19538024c33c9c51050ed103d0ea">More...</a><br /></td></tr>
<tr class="separator:a44bf19538024c33c9c51050ed103d0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3487d4565eb883d91bf00027f7fa6ba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3487d4565eb883d91bf00027f7fa6ba3">operator*</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a3487d4565eb883d91bf00027f7fa6ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expression that multiplies *this by <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3487d4565eb883d91bf00027f7fa6ba3">More...</a><br /></td></tr>
<tr class="separator:a3487d4565eb883d91bf00027f7fa6ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e0e1ac496e3bf9f3151bc01b5ffa39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ab4e0e1ac496e3bf9f3151bc01b5ffa39">operator*</a> (double rhs) const</td></tr>
<tr class="memdesc:ab4e0e1ac496e3bf9f3151bc01b5ffa39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expression that creates a scaled version of *this.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ab4e0e1ac496e3bf9f3151bc01b5ffa39">More...</a><br /></td></tr>
<tr class="separator:ab4e0e1ac496e3bf9f3151bc01b5ffa39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44300cfacda668699bfc6431703ec4c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a44300cfacda668699bfc6431703ec4c6">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a44300cfacda668699bfc6431703ec4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two labeledView instances are value equal.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a44300cfacda668699bfc6431703ec4c6">More...</a><br /></td></tr>
<tr class="separator:a44300cfacda668699bfc6431703ec4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef928f895b7ff866732d761b42487b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a9ef928f895b7ff866732d761b42487b9">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a9ef928f895b7ff866732d761b42487b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instances are different.  <a href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a9ef928f895b7ff866732d761b42487b9">More...</a><br /></td></tr>
<tr class="separator:a9ef928f895b7ff866732d761b42487b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename FieldType&gt;<br />
class tensorwrapper::tensor::expression::LabeledView&lt; FieldType &gt;</h3>

<p>Associates an annotation with a reference to a tensor. </p>
<p>This class associates a set of labels with a reference to a tensor. In particular this means the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instance does not manage the lifetime of the <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> used to create it and it is the caller's responsibility to ensure the <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> remains in scope until the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> goes out of scope.</p>
<p>In practice lifetime management is straightforward because <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> objects are typically unnamed temporaries. For example: </p><div class="fragment"><div class="line">TensorWrapper a,b,c;</div>
<div class="line">c(<span class="stringliteral">&quot;i,j&quot;</span>) = a(<span class="stringliteral">&quot;i,k&quot;</span>) * b(<span class="stringliteral">&quot;k,j&quot;</span>);</div>
</div><!-- fragment --><p> Here the three calls to TensorWrapper::operator(std::string) create three unnamed <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instances, all of which are out of scope after the multiplication.</p>
<p>The only thing slightly tricky about this class is getting the const correctness right. In most expression layers this is done by having const show up somewhere in the type argument. We avoid this by having the class hold either a read/write reference or a read-only reference to the tensor. For the most part everything just works. The only hiccup comes from when you a non-const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instance, but it was initialized with a const reference (say from a const <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> object). In this case calling <code><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ae0903ad58edc4cb9cf6f2d1dcae0c5b1" title="Provides read/write access to the aliased tensor.">tensor()</a></code> will throw as it would violate const-correctness by returing a read/write reference. Instead the user needs to call <code><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a862591318dd90711b380453d4e5a61ab" title="Provides read-only access to the aliased tensor.">tensor() const</a></code> to get back the read-only reference. In practice end users of <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> usually interact with this class implicitly, so this is only a complication seen by developers of <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a> (it only really affects the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> class). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abd93c1d0540d4158ba35173d409a1f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd93c1d0540d4158ba35173d409a1f05">&#9670;&nbsp;</a></span>LabeledView() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a71538e02e15f10f09bdfda913be4e201">label_type</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a809711f9cfa5864d97609a0959116933">tensor_reference</a>&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Annotates a read/write view of a tensor. </p>
<p>This ctor creates a labeled view of <code>tensor</code>. Since <code>tensor</code> need not be initialized (e.g., if it appears on the left side of an assignment operation) no checks will be performed to ensure that <code>labels</code> are consistent with <code>tensor</code>.</p>
<p>It should be noted that the resulting <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> only aliases <code>tensor</code> and it is thus the caller's responsibilty to manage the lifetime of <code>tensor</code>, in particular the caller needs to ensure <code>tensor</code> does not go out of scope while the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instance is still in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>The annotation for <code>tensor</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td>The tensor this is a view of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bc041680aa79b0f66a725956c1a84d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc041680aa79b0f66a725956c1a84d8">&#9670;&nbsp;</a></span>LabeledView() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a71538e02e15f10f09bdfda913be4e201">label_type</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a77eb8a16420a07abfc4b186956aabe53">const_tensor_reference</a>&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Annotates a read-only view of a tensor. </p>
<p>This ctor behaves identical to the read/write view ctor except that the resulting <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instance will enforce read-only access to the aliased tensor. Notably this means that attempting to call <code><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ae0903ad58edc4cb9cf6f2d1dcae0c5b1" title="Provides read/write access to the aliased tensor.">tensor()</a></code> instead of <code><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a862591318dd90711b380453d4e5a61ab" title="Provides read-only access to the aliased tensor.">tensor() const</a></code> will raise an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>The annotation for <code>tensor</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td>The tensor this is a view of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96d5c7e2b201be7d493278b1eb1ae5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d5c7e2b201be7d493278b1eb1ae5ca">&#9670;&nbsp;</a></span>LabeledView() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> which is a copy of <code>other</code>. </p>
<p>This ctor will create a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> which is a deep copy of <code>other</code>. However, since views of a tensor have alias semantics, the deep- copy of the view also has alias semantics of the same tensor. The labels are actually deep copied. (It's a deep copy in the sense that the holder in the copy is not an alias of the holder in the original, but immediately following the copy both holders will alias the same tensor.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> we are deep copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem deep copying the labels. Strong throw guarantee. (Copying the tensor reference is no-throw guarantee.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c94e4014a6f8822448847bb6c148a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c94e4014a6f8822448847bb6c148a53">&#9670;&nbsp;</a></span>LabeledView() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&lt; FieldType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> which owns the state of <code>other</code>. </p>
<p>This ctor creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> by moving the new instance's state from <code>other</code>. The resulting <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> will still alias the same tensor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The view we are taking the state from. After this operation <code>other</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abd3606fbb2bfcff6046c169a2345cf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3606fbb2bfcff6046c169a2345cf5d">&#9670;&nbsp;</a></span>expression()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::expression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps this <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> in an <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> class. </p>
<p>The expression layer describes how pieces of tensor equations are combined. Every piece of the expression layer must be wrapped in an <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance. This method creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance by wrapping *this.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance that contains a copy of *this. Note that this means the resulting <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> still aliases the same tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is problem creating the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6c93c2907397d6979d838afd17c53a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c93c2907397d6979d838afd17c53a2">&#9670;&nbsp;</a></span>labels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#addd5c5741315a83ba83bcd3b172701eb">const_label_reference</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::labels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides read-only access to the labels annotating the tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>The labels associated with the aliased tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ef928f895b7ff866732d761b42487b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef928f895b7ff866732d761b42487b9">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instances are different. </p>
<p>This method simply negates operator==. See the description there for the definition of value equal.</p>
<dl class="section return"><dt>Returns</dt><dd>False if *this is the same as <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3487d4565eb883d91bf00027f7fa6ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3487d4565eb883d91bf00027f7fa6ba3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an expression that multiplies *this by <code>rhs</code>. </p>
<p>This operation will multiply *this by <code>rhs</code>. Whether this is an element-wise multiplication, a contraction, or a combination of both is ultimately determined by the labels on *this, the labels on <code>rhs</code>, and the labels on the tensor the expression is assigned to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> being multiplied with *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance, which when evaluated, will return the result of subtracting <code>rhs</code> from *this</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocationg the state for the returned object. Str </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4e0e1ac496e3bf9f3151bc01b5ffa39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e0e1ac496e3bf9f3151bc01b5ffa39">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an expression that creates a scaled version of *this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The scalar to scale *this by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance which, when evaluated, will result in the product of *this and <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a410eb7345af1bad283fcaf4f3034ba6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410eb7345af1bad283fcaf4f3034ba6a">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an expression that sums *this and <code>rhs</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance which, when evaluated, will return the result of summing *this and <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the state for the returned object. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44bf19538024c33c9c51050ed103d0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bf19538024c33c9c51050ed103d0ea">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a3dde012a3b9a3cf3104370fc53c8d883">expression_type</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an expression that subtracts <code>rhs</code> from *this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> being subtracted from *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1Expression.html" title="A piece of a type-erased tensor expression.">Expression</a> instance, which when evaluated, will return the result of subtracting <code>rhs</code> from *this</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocationg the state for the returned object. Str </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71f00e6d2dc35a55b44df6d0e851e7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f00e6d2dc35a55b44df6d0e851e7e3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&amp; <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites the contents by transforming <code>rhs</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>In general this is NOT just copy assignment.</dd></dl>
<p>This method is copy assignment only when:</p>
<ul>
<li>this instance has the same labels as <code>rhs</code>, and</li>
<li>this instance aliases a default constructed <a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html" title="Fundamental type for wrapping tensors.">TensorWrapper</a></li>
</ul>
<p>In all other circumstances this method represents a transformation of <code>rhs</code>. Arguably the most common use case is permutation of the modes of <code>rhs</code>. An example of such an invocation is something like: </p><div class="fragment"><div class="line">TensorWrapper a, b;</div>
<div class="line">a(<span class="stringliteral">&quot;i,j&quot;</span>) = b(<span class="stringliteral">&quot;j,i&quot;</span>);</div>
</div><!-- fragment --><p> In this example, after the operation, <code>a</code> will contain <code>b</code> transposed. The other possible transformations are syntactic sugar for reallocating or reshaping <code>rhs</code>. These transformations occur if the tensor aliased by *this contains a different allocator and/or shape than <code>rhs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The input to transform into the tensor wrapped by *this</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance after transforming it according to the operation defined by the comparing the shapes, allocators, and labels in *this and <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this holds a read-only tensor and thus can not be assigned to. Strong throw guarantee.</td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating memory for the temporary expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a372e55c5408da353d0b5c2aa185b830a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372e55c5408da353d0b5c2aa185b830a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&amp; <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a9c77f312ec373067558974dda327aa40">const_expression_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites the contents by evaluating <code>rhs</code>. </p>
<p>This method behaves similar to operator=(LabeledView) except that <code>rhs</code> is in general a more complicated expression than simply a labeled tensor. Upon invocation, this method will:</p>
<ul>
<li>set the allocator for this-&gt;<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ae0903ad58edc4cb9cf6f2d1dcae0c5b1" title="Provides read/write access to the aliased tensor.">tensor()</a></li>
<li>set the shape for this-&gt;<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ae0903ad58edc4cb9cf6f2d1dcae0c5b1" title="Provides read/write access to the aliased tensor.">tensor()</a></li>
<li>set the buffer for this-&gt;buffer()</li>
<li>return *this</li>
</ul>
<p>It should be noted that if the allocator and/or shape of this-&gt;<a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#ae0903ad58edc4cb9cf6f2d1dcae0c5b1" title="Provides read/write access to the aliased tensor.">tensor()</a> is already set that allocator and/or shape will be used (assuming the values are compatible with evaluation of <code>rhs</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The expression we are evaluating and assigning to *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance after assigning the result of <code>rhs</code> to it.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this contains a read-only tensor and thus can not be assigned to. Strong throw guarantee.</td></tr>
    <tr><td class="paramname">???</td><td>If the expression throws. Same throw guarantee as the expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44300cfacda668699bfc6431703ec4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44300cfacda668699bfc6431703ec4c6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">LabeledView</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two labeledView instances are value equal. </p>
<p>Two <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instances are value equal if they both contain the same set of labels, both alias the same tensor, and if they both alias the tensor with the same const-ness (i.e., they both either alias the tensor by read/write alias or they both alias it read-only).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The labeled view we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this is value equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0903ad58edc4cb9cf6f2d1dcae0c5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0903ad58edc4cb9cf6f2d1dcae0c5b1">&#9670;&nbsp;</a></span>tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a809711f9cfa5864d97609a0959116933">tensor_reference</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">tensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides read/write access to the aliased tensor. </p>
<p>This method should only be used if this <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> is holding a read/write tensor.</p>
<dl class="section return"><dt>Returns</dt><dd>The tensor aliased by *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this instance is wrapping a read-only tensor. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a862591318dd90711b380453d4e5a61ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862591318dd90711b380453d4e5a61ab">&#9670;&nbsp;</a></span>tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html#a77eb8a16420a07abfc4b186956aabe53">const_tensor_reference</a> <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html">tensorwrapper::tensor::expression::LabeledView</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1TensorWrapper.html">tensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides read-only access to the aliased tensor. </p>
<p>This method will return the aliased tensor in a read-only state regardless of whether we are aliasing a read/write or read-only tensor.</p>
<dl class="section return"><dt>Returns</dt><dd>The tensor aliased by *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this instance is not holding a tensor. In general this state can only be achieved by trying to use a <a class="el" href="classtensorwrapper_1_1tensor_1_1expression_1_1LabeledView.html" title="Associates an annotation with a reference to a tensor.">LabeledView</a> instance after moving from it. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tensorwrapper/tensor/expression/<a class="el" href="labeled__view_8hpp_source.html">labeled_view.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
