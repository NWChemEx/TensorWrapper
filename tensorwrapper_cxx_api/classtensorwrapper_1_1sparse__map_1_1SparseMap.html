<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::sparse_map::SparseMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorwrapper</b></li><li class="navelem"><b>sparse_map</b></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classtensorwrapper_1_1sparse__map_1_1SparseMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::sparse_map::SparseMap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a832e1e642093c1fe906e85e1471b5ae1"><td class="memItemLeft" align="right" valign="top"><a id="a832e1e642093c1fe906e85e1471b5ae1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a832e1e642093c1fe906e85e1471b5ae1">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a832e1e642093c1fe906e85e1471b5ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for offsets and counting. <br /></td></tr>
<tr class="separator:a832e1e642093c1fe906e85e1471b5ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1b74131c19ff3a4af347ac82fdfe4e"><td class="memItemLeft" align="right" valign="top"><a id="add1b74131c19ff3a4af347ac82fdfe4e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a> = <a class="el" href="structtensorwrapper_1_1sparse__map_1_1Index.html">Index</a></td></tr>
<tr class="memdesc:add1b74131c19ff3a4af347ac82fdfe4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the independent index. <br /></td></tr>
<tr class="separator:add1b74131c19ff3a4af347ac82fdfe4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1912c661ee8252152e87dc83b2d0155a"><td class="memItemLeft" align="right" valign="top"><a id="a1912c661ee8252152e87dc83b2d0155a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a1912c661ee8252152e87dc83b2d0155a">mapped_type</a> = <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html">Domain</a></td></tr>
<tr class="memdesc:a1912c661ee8252152e87dc83b2d0155a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a domain of dependent indices. <br /></td></tr>
<tr class="separator:a1912c661ee8252152e87dc83b2d0155a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6063a17a28e2234c3c2a992d40cf7191"><td class="memItemLeft" align="right" valign="top"><a id="a6063a17a28e2234c3c2a992d40cf7191"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a6063a17a28e2234c3c2a992d40cf7191">value_type</a> = std::pair&lt; const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a>, <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a1912c661ee8252152e87dc83b2d0155a">mapped_type</a> &gt;</td></tr>
<tr class="memdesc:a6063a17a28e2234c3c2a992d40cf7191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the independent-index-domain pairs. <br /></td></tr>
<tr class="separator:a6063a17a28e2234c3c2a992d40cf7191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3344bd579a43d9ae096bcd2444438e5"><td class="memItemLeft" align="right" valign="top"><a id="ae3344bd579a43d9ae096bcd2444438e5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ae3344bd579a43d9ae096bcd2444438e5">const_iterator</a> = utilities::iterators::OffsetIterator&lt; const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &gt;</td></tr>
<tr class="memdesc:ae3344bd579a43d9ae096bcd2444438e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a bidirectional iterator with read-only access to indices. <br /></td></tr>
<tr class="separator:ae3344bd579a43d9ae096bcd2444438e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a941726056f63ce42383b22fc483c5e21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a941726056f63ce42383b22fc483c5e21">SparseMap</a> ()</td></tr>
<tr class="memdesc:a941726056f63ce42383b22fc483c5e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new empty <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a941726056f63ce42383b22fc483c5e21">More...</a><br /></td></tr>
<tr class="separator:a941726056f63ce42383b22fc483c5e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f41a950a9ab5c8ab4fe76986230407"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a51f41a950a9ab5c8ab4fe76986230407">SparseMap</a> (il_t il)</td></tr>
<tr class="memdesc:a51f41a950a9ab5c8ab4fe76986230407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a51f41a950a9ab5c8ab4fe76986230407">More...</a><br /></td></tr>
<tr class="separator:a51f41a950a9ab5c8ab4fe76986230407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2829f8552a4d0bcc27dde0b5277ce00a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a2829f8552a4d0bcc27dde0b5277ce00a">SparseMap</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs)</td></tr>
<tr class="memdesc:a2829f8552a4d0bcc27dde0b5277ce00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> by copying another instance.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a2829f8552a4d0bcc27dde0b5277ce00a">More...</a><br /></td></tr>
<tr class="separator:a2829f8552a4d0bcc27dde0b5277ce00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed75e12341dca6b7b925ea0b7a57c367"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#aed75e12341dca6b7b925ea0b7a57c367">SparseMap</a> (<a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:aed75e12341dca6b7b925ea0b7a57c367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> instance by taking ownership of another instance's state.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#aed75e12341dca6b7b925ea0b7a57c367">More...</a><br /></td></tr>
<tr class="separator:aed75e12341dca6b7b925ea0b7a57c367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb5b575b289737dd481855483ccbf47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a4cb5b575b289737dd481855483ccbf47">operator=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4cb5b575b289737dd481855483ccbf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this instance's state to a copy of <code>rhs's</code> state.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a4cb5b575b289737dd481855483ccbf47">More...</a><br /></td></tr>
<tr class="separator:a4cb5b575b289737dd481855483ccbf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b567184db536fe87a51570f0186027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ab7b567184db536fe87a51570f0186027">operator=</a> (<a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab7b567184db536fe87a51570f0186027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of another instance's state.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ab7b567184db536fe87a51570f0186027">More...</a><br /></td></tr>
<tr class="separator:ab7b567184db536fe87a51570f0186027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dd94115535fd67dccb622af030aef3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a21dd94115535fd67dccb622af030aef3">~SparseMap</a> () noexcept</td></tr>
<tr class="memdesc:a21dd94115535fd67dccb622af030aef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default dtor.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a21dd94115535fd67dccb622af030aef3">More...</a><br /></td></tr>
<tr class="separator:a21dd94115535fd67dccb622af030aef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a80ca8e78a385b976c96b63a50ad39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a05a80ca8e78a385b976c96b63a50ad39">swap</a> (<a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a05a80ca8e78a385b976c96b63a50ad39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the state of two SparseMaps.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a05a80ca8e78a385b976c96b63a50ad39">More...</a><br /></td></tr>
<tr class="separator:a05a80ca8e78a385b976c96b63a50ad39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7231e1af43736fdb4d194f7b7d5465"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a832e1e642093c1fe906e85e1471b5ae1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#adb7231e1af43736fdb4d194f7b7d5465">size</a> () const noexcept</td></tr>
<tr class="memdesc:adb7231e1af43736fdb4d194f7b7d5465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of independent indices in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#adb7231e1af43736fdb4d194f7b7d5465">More...</a><br /></td></tr>
<tr class="separator:adb7231e1af43736fdb4d194f7b7d5465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f09c69e64cd8171d42598c3a0aebde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ac8f09c69e64cd8171d42598c3a0aebde">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ac8f09c69e64cd8171d42598c3a0aebde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is empty.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ac8f09c69e64cd8171d42598c3a0aebde">More...</a><br /></td></tr>
<tr class="separator:ac8f09c69e64cd8171d42598c3a0aebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fe9787a7ea42cd838b56b060b106db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a38fe9787a7ea42cd838b56b060b106db">count</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a> &amp;i) const noexcept</td></tr>
<tr class="memdesc:a38fe9787a7ea42cd838b56b060b106db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> contains the specified independent index.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a38fe9787a7ea42cd838b56b060b106db">More...</a><br /></td></tr>
<tr class="separator:a38fe9787a7ea42cd838b56b060b106db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f83281ad8ab4abbe214e40185c21236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a832e1e642093c1fe906e85e1471b5ae1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a0f83281ad8ab4abbe214e40185c21236">ind_rank</a> () const noexcept</td></tr>
<tr class="memdesc:a0f83281ad8ab4abbe214e40185c21236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the independent indices.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a0f83281ad8ab4abbe214e40185c21236">More...</a><br /></td></tr>
<tr class="separator:a0f83281ad8ab4abbe214e40185c21236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa8975ac562b8d895a097ca90ca83d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a832e1e642093c1fe906e85e1471b5ae1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a5fa8975ac562b8d895a097ca90ca83d8">dep_rank</a> () const noexcept</td></tr>
<tr class="memdesc:a5fa8975ac562b8d895a097ca90ca83d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of independent modes associated with each <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a5fa8975ac562b8d895a097ca90ca83d8">More...</a><br /></td></tr>
<tr class="separator:a5fa8975ac562b8d895a097ca90ca83d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c79675bca6577fef52bba3bdf02c7d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a3c79675bca6577fef52bba3bdf02c7d9">add_to_domain</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a> &amp;key, <a class="el" href="structtensorwrapper_1_1sparse__map_1_1Index.html">Index</a> value)</td></tr>
<tr class="memdesc:a3c79675bca6577fef52bba3bdf02c7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dependent index to an independent index's <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a3c79675bca6577fef52bba3bdf02c7d9">More...</a><br /></td></tr>
<tr class="separator:a3c79675bca6577fef52bba3bdf02c7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee48ee2983b0ea8bfc90fde18bd5422"><td class="memItemLeft" align="right" valign="top"><a id="aeee48ee2983b0ea8bfc90fde18bd5422"></a>
const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a6063a17a28e2234c3c2a992d40cf7191">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (<a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a832e1e642093c1fe906e85e1471b5ae1">size_type</a> i) const</td></tr>
<tr class="separator:aeee48ee2983b0ea8bfc90fde18bd5422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518d8fe6b059fe990cdb8d35912ce935"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a1912c661ee8252152e87dc83b2d0155a">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a518d8fe6b059fe990cdb8d35912ce935">operator[]</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a518d8fe6b059fe990cdb8d35912ce935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with the specified independent index.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a518d8fe6b059fe990cdb8d35912ce935">More...</a><br /></td></tr>
<tr class="separator:a518d8fe6b059fe990cdb8d35912ce935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bfea6b53a11ff4017eabcd787c5824"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a1912c661ee8252152e87dc83b2d0155a">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ab7bfea6b53a11ff4017eabcd787c5824">at</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:ab7bfea6b53a11ff4017eabcd787c5824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with the specified independent index.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ab7bfea6b53a11ff4017eabcd787c5824">More...</a><br /></td></tr>
<tr class="separator:ab7bfea6b53a11ff4017eabcd787c5824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48af5c020de82f52b8416aa64edec4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ae3344bd579a43d9ae096bcd2444438e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#af48af5c020de82f52b8416aa64edec4b">begin</a> () const</td></tr>
<tr class="memdesc:af48af5c020de82f52b8416aa64edec4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator which points to the first independent-index-Domain pair.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#af48af5c020de82f52b8416aa64edec4b">More...</a><br /></td></tr>
<tr class="separator:af48af5c020de82f52b8416aa64edec4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e06cc65078b27c81bfb84069e02124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ae3344bd579a43d9ae096bcd2444438e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a32e06cc65078b27c81bfb84069e02124">end</a> () const</td></tr>
<tr class="memdesc:a32e06cc65078b27c81bfb84069e02124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the end of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a32e06cc65078b27c81bfb84069e02124">More...</a><br /></td></tr>
<tr class="separator:a32e06cc65078b27c81bfb84069e02124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fc7f0e81a13ad3c17c1562ee46b495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#aa8fc7f0e81a13ad3c17c1562ee46b495">direct_product</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aa8fc7f0e81a13ad3c17c1562ee46b495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the direct product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> and another <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#aa8fc7f0e81a13ad3c17c1562ee46b495">More...</a><br /></td></tr>
<tr class="separator:aa8fc7f0e81a13ad3c17c1562ee46b495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5952782e9e8c32a476ad6888613feb08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a5952782e9e8c32a476ad6888613feb08">operator*</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a5952782e9e8c32a476ad6888613feb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> with domains given by the Cartesian product of the Domains in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> with the Domains in <code>rhs</code>.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a5952782e9e8c32a476ad6888613feb08">More...</a><br /></td></tr>
<tr class="separator:a5952782e9e8c32a476ad6888613feb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26769d30a718f375e7fa9205bb27b0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a26769d30a718f375e7fa9205bb27b0c4">operator*=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs)</td></tr>
<tr class="memdesc:a26769d30a718f375e7fa9205bb27b0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> with domains given by the Cartesian product of the Domains previously in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> with the Domains in <code>rhs</code>.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a26769d30a718f375e7fa9205bb27b0c4">More...</a><br /></td></tr>
<tr class="separator:a26769d30a718f375e7fa9205bb27b0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de936b5a542971b17f931241db31f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a8de936b5a542971b17f931241db31f08">operator+=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8de936b5a542971b17f931241db31f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the union of this and another map.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a8de936b5a542971b17f931241db31f08">More...</a><br /></td></tr>
<tr class="separator:a8de936b5a542971b17f931241db31f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7198aa2b2d6326d65d455494bd95a91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ae7198aa2b2d6326d65d455494bd95a91">operator+</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ae7198aa2b2d6326d65d455494bd95a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> which is the union of this and another map.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ae7198aa2b2d6326d65d455494bd95a91">More...</a><br /></td></tr>
<tr class="separator:ae7198aa2b2d6326d65d455494bd95a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aa17a5c8df0056804087c607638130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a83aa17a5c8df0056804087c607638130">operator^=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs)</td></tr>
<tr class="memdesc:a83aa17a5c8df0056804087c607638130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this the intersection of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> and another map.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a83aa17a5c8df0056804087c607638130">More...</a><br /></td></tr>
<tr class="separator:a83aa17a5c8df0056804087c607638130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8720c0cdcfd92372a0b052740ab151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a9a8720c0cdcfd92372a0b052740ab151">operator^</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a9a8720c0cdcfd92372a0b052740ab151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> and another map.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a9a8720c0cdcfd92372a0b052740ab151">More...</a><br /></td></tr>
<tr class="separator:a9a8720c0cdcfd92372a0b052740ab151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dff630e8ca7206a173332d9b5fa2093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a5dff630e8ca7206a173332d9b5fa2093">inverse</a> () const</td></tr>
<tr class="memdesc:a5dff630e8ca7206a173332d9b5fa2093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the inverse <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a5dff630e8ca7206a173332d9b5fa2093">More...</a><br /></td></tr>
<tr class="separator:a5dff630e8ca7206a173332d9b5fa2093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67e6750bc6b11983d55fc724e39cd90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#af67e6750bc6b11983d55fc724e39cd90">chain</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;sm) const</td></tr>
<tr class="memdesc:af67e6750bc6b11983d55fc724e39cd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> from chaining two maps together.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#af67e6750bc6b11983d55fc724e39cd90">More...</a><br /></td></tr>
<tr class="separator:af67e6750bc6b11983d55fc724e39cd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578312a3cbaf4704c642e5dc31e2dcb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a578312a3cbaf4704c642e5dc31e2dcb2">operator==</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a578312a3cbaf4704c642e5dc31e2dcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two SparseMaps are identical.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a578312a3cbaf4704c642e5dc31e2dcb2">More...</a><br /></td></tr>
<tr class="separator:a578312a3cbaf4704c642e5dc31e2dcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb9ba13a4bcafe6c8c11e534febc46b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a1cb9ba13a4bcafe6c8c11e534febc46b">print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a1cb9ba13a4bcafe6c8c11e534febc46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to the stream.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a1cb9ba13a4bcafe6c8c11e534febc46b">More...</a><br /></td></tr>
<tr class="separator:a1cb9ba13a4bcafe6c8c11e534febc46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad2e8b3dacca237c0b42b6c39305bfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#adad2e8b3dacca237c0b42b6c39305bfe">hash</a> (tensorwrapper::detail_::Hasher &amp;h) const</td></tr>
<tr class="memdesc:adad2e8b3dacca237c0b42b6c39305bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>'s state to a hash.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#adad2e8b3dacca237c0b42b6c39305bfe">More...</a><br /></td></tr>
<tr class="separator:adad2e8b3dacca237c0b42b6c39305bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa289991131f62d0fe365b191a2b0ed62"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#aa289991131f62d0fe365b191a2b0ed62">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;smb)</td></tr>
<tr class="memdesc:aa289991131f62d0fe365b191a2b0ed62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to the stream.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#aa289991131f62d0fe365b191a2b0ed62">More...</a><br /></td></tr>
<tr class="separator:aa289991131f62d0fe365b191a2b0ed62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc7959672acf3ed5f19669a86b3fdc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a4fc7959672acf3ed5f19669a86b3fdc6">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;lhs, const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4fc7959672acf3ed5f19669a86b3fdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two SparseMaps are different.  <a href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a4fc7959672acf3ed5f19669a86b3fdc6">More...</a><br /></td></tr>
<tr class="separator:a4fc7959672acf3ed5f19669a86b3fdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a941726056f63ce42383b22fc483c5e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941726056f63ce42383b22fc483c5e21">&#9670;&nbsp;</a></span>SparseMap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::sparse_map::SparseMap::SparseMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new empty <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. </p>
<p>This constructor is used to create a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> which contains no independent elements (and thus no dependent elements either).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the PIMPL. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51f41a950a9ab5c8ab4fe76986230407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f41a950a9ab5c8ab4fe76986230407">&#9670;&nbsp;</a></span>SparseMap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::sparse_map::SparseMap::SparseMap </td>
          <td>(</td>
          <td class="paramtype">il_t&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of. </p>
<p>This ctor allows you to specify at construction the independent indices and the domains they map to. The format is:</p>
<div class="fragment"><div class="line">{{i0, {d00, d01, ...}}, {i1, {d10, d11, ...}}, ...}</div>
</div><!-- fragment --><p>where <code>i0</code>, and <code>i1</code> are independent indices <code>d00</code>, <code>d01</code> are the first two dependent indices associated with <code>i0</code> and <code>d10</code> and <code>d11</code> are the first two dependent indices associated with <code>i1</code>. In practice this ctor is intended primarily for use with unit testing as that is one of the few scenarios where one can just lay out the contents of the sparse map to create.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The initial state of the sparse map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the initial state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2829f8552a4d0bcc27dde0b5277ce00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2829f8552a4d0bcc27dde0b5277ce00a">&#9670;&nbsp;</a></span>SparseMap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::sparse_map::SparseMap::SparseMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> by copying another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> we are copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>rhs</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed75e12341dca6b7b925ea0b7a57c367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed75e12341dca6b7b925ea0b7a57c367">&#9670;&nbsp;</a></span>SparseMap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::sparse_map::SparseMap::SparseMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> instance by taking ownership of another instance's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state is being taken. After this call <code>rhs</code> will contain no PIMPL and thus will behave like an empty <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21dd94115535fd67dccb622af030aef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21dd94115535fd67dccb622af030aef3">&#9670;&nbsp;</a></span>~SparseMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::sparse_map::SparseMap::~SparseMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default dtor. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3c79675bca6577fef52bba3bdf02c7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c79675bca6577fef52bba3bdf02c7d9">&#9670;&nbsp;</a></span>add_to_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensorwrapper::sparse_map::SparseMap::add_to_domain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtensorwrapper_1_1sparse__map_1_1Index.html">Index</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a dependent index to an independent index's <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. </p>
<p>This function adds an dependent index to and independent index's <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. This function will create the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> if the independent index is not already in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. If the dependent index is already in the independent index's <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The independent index to which <code>value</code> should be added. If this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is non-empty the rank of <code>key</code> must be equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a0f83281ad8ab4abbe214e40185c21236" title="Returns the rank of the independent indices.">ind_rank()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The dependent index being added to <code>key's</code> domain. If <code>key's</code> <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> is non-empty the rank of <code>value</code> must be equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a5fa8975ac562b8d895a097ca90ca83d8" title="The number of independent modes associated with each Domain.">dep_rank()</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to add the new state. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is non-empty and the rank of <code>key</code> is not equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a0f83281ad8ab4abbe214e40185c21236" title="Returns the rank of the independent indices.">ind_rank()</a></code> or if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with <code>key</code> is non-empty and the rank of <code>value</code> is not equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a5fa8975ac562b8d895a097ca90ca83d8" title="The number of independent modes associated with each Domain.">dep_rank()</a></code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7bfea6b53a11ff4017eabcd787c5824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bfea6b53a11ff4017eabcd787c5824">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a1912c661ee8252152e87dc83b2d0155a">mapped_type</a>&amp; tensorwrapper::sparse_map::SparseMap::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with the specified independent index. </p>
<p>This function can be used to retrieve the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with a independent index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The independent index whose <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> we want. The rank of <code>key</code> must be equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a0f83281ad8ab4abbe214e40185c21236" title="Returns the rank of the independent indices.">ind_rank()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with <code>key</code> in a read-only manner.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> is not in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the rank of <code>key</code> is not equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a0f83281ad8ab4abbe214e40185c21236" title="Returns the rank of the independent indices.">ind_rank()</a></code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af48af5c020de82f52b8416aa64edec4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48af5c020de82f52b8416aa64edec4b">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ae3344bd579a43d9ae096bcd2444438e5">const_iterator</a> tensorwrapper::sparse_map::SparseMap::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator which points to the first independent-index-Domain pair. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element of this map. Elements of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> can not be modified through the iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is no PIMPL. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af67e6750bc6b11983d55fc724e39cd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67e6750bc6b11983d55fc724e39cd90">&#9670;&nbsp;</a></span>chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> tensorwrapper::sparse_map::SparseMap::chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> from chaining two maps together. </p>
<p>Given the SparseMaps sm1(f -&gt; g) and sm2(g -&gt; h), the chained map from (f -&gt; h) is formed by mapping each element f_i to a set of {g_i} using sm1, and then to any element in h which is mapped to from an element of {g_i} by sm2.</p>
<p>Requires that the maps share a common set of indices, g, as the dependent and independent indices respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to chain with this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The chained map. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the rank of the dependent indices of this instance is not equal to the rank of the independent indices of <code>sm</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38fe9787a7ea42cd838b56b060b106db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fe9787a7ea42cd838b56b060b106db">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tensorwrapper::sparse_map::SparseMap::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> contains the specified independent index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index we are looking for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the index is in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fa8975ac562b8d895a097ca90ca83d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa8975ac562b8d895a097ca90ca83d8">&#9670;&nbsp;</a></span>dep_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a832e1e642093c1fe906e85e1471b5ae1">SparseMap::size_type</a> tensorwrapper::sparse_map::SparseMap::dep_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of independent modes associated with each <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. </p>
<p>Each independent index maps to a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. Each <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> contains indices of the same rank. For a given <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> all of the mapped to Domains must contain indices of the same rank (or be empty). This function will return the rank of the indices in the Domains. The return is 0 if this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is empty, all the Domains are empty, or all Domains contain a rank 0 index.</p>
<dl class="section return"><dt>Returns</dt><dd>The rank of the indices in the Domains this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> maps to.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8fc7f0e81a13ad3c17c1562ee46b495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fc7f0e81a13ad3c17c1562ee46b495">&#9670;&nbsp;</a></span>direct_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> tensorwrapper::sparse_map::SparseMap::direct_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the direct product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> and another <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. </p>
<p>Given a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> <img class="formulaInl" alt="$A$" src="form_1.png"/> with <img class="formulaInl" alt="$i$" src="form_9.png"/>-th element <img class="formulaInl" alt="$(a_i, \alpha_i)$" src="form_14.png"/> ( <img class="formulaInl" alt="$a_i$" src="form_15.png"/> is the independent index and <img class="formulaInl" alt="$\alpha_i$" src="form_16.png"/> is the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with <img class="formulaInl" alt="$a_i$" src="form_15.png"/>) and a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> <img class="formulaInl" alt="$B$" src="form_3.png"/> with <img class="formulaInl" alt="$j$" src="form_10.png"/>-th element <img class="formulaInl" alt="$(b_j, \beta_j)$" src="form_17.png"/> this function computes a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> <img class="formulaInl" alt="$C$" src="form_5.png"/> which we say is the direct product of <img class="formulaInl" alt="$A$" src="form_1.png"/> with <img class="formulaInl" alt="$B$" src="form_3.png"/>. <img class="formulaInl" alt="$C$" src="form_5.png"/> is given by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C = \left\lbrace (a_ib_j, \alpha_i\beta_j) \forall (a_i, \alpha_i) \in A \forall (b_j, \beta_j) \in B \right\rbrace \]" src="form_18.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> we are taking the direct product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The direct product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>'s state with <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is not enough memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8f09c69e64cd8171d42598c3a0aebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f09c69e64cd8171d42598c3a0aebde">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tensorwrapper::sparse_map::SparseMap::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is empty. </p>
<p>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is empty if it contains no independent indices. Of note a sparse map with an independent rank 0 index contains one index and is not empty.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is empty and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is implemented by checking if size equals zero so that it can be no-throw. </dd></dl>

</div>
</div>
<a id="a32e06cc65078b27c81bfb84069e02124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e06cc65078b27c81bfb84069e02124">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ae3344bd579a43d9ae096bcd2444438e5">const_iterator</a> tensorwrapper::sparse_map::SparseMap::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the end of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to just past the end of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the map has no PIMPL. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adad2e8b3dacca237c0b42b6c39305bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad2e8b3dacca237c0b42b6c39305bfe">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensorwrapper::sparse_map::SparseMap::hash </td>
          <td>(</td>
          <td class="paramtype">tensorwrapper::detail_::Hasher &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>'s state to a hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>The object hashing the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. After this call the internal hash of <code>h</code> will be updated to include this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>'s state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f83281ad8ab4abbe214e40185c21236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f83281ad8ab4abbe214e40185c21236">&#9670;&nbsp;</a></span>ind_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a832e1e642093c1fe906e85e1471b5ae1">SparseMap::size_type</a> tensorwrapper::sparse_map::SparseMap::ind_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the independent indices. </p>
<p>All independent indices in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> must have the same rank (<em>i.e.</em>, number of modes). This function can be used to determine what the rank of the independent indices are. Note that if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is empty we return a rank of 0; hence both empty sparse maps and SparseMaps with independent indices of rank 0 return 0 (use <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#ac8f09c69e64cd8171d42598c3a0aebde" title="Determines if the SparseMap is empty.">empty()</a></code> to distinguish between the two cases).</p>
<dl class="section return"><dt>Returns</dt><dd>The rank of the independent indices.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dff630e8ca7206a173332d9b5fa2093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dff630e8ca7206a173332d9b5fa2093">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> tensorwrapper::sparse_map::SparseMap::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the inverse <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. </p>
<p>Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> which maps from the dependent indices to the independent indices of the current map.</p>
<p>sparse_map.inverse().<a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a5dff630e8ca7206a173332d9b5fa2093" title="Constructs the inverse SparseMap.">inverse()</a> == sparse_map</p>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to create the returned value. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5952782e9e8c32a476ad6888613feb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5952782e9e8c32a476ad6888613feb08">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> tensorwrapper::sparse_map::SparseMap::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> with domains given by the Cartesian product of the Domains in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> with the Domains in <code>rhs</code>. </p>
<p>Given a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> <img class="formulaInl" alt="$A$" src="form_1.png"/> which maps independent index <img class="formulaInl" alt="$i$" src="form_9.png"/> to <img class="formulaInl" alt="$a_i$" src="form_15.png"/> and a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> <img class="formulaInl" alt="$B$" src="form_3.png"/> which maps independent index <img class="formulaInl" alt="$i$" src="form_9.png"/> to <img class="formulaInl" alt="$b_i$" src="form_19.png"/>. This function computes a third <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>, <img class="formulaInl" alt="$C$" src="form_5.png"/>, where the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> <img class="formulaInl" alt="$c_i$" src="form_20.png"/>-th element is the Cartesian product of <img class="formulaInl" alt="$a_i$" src="form_15.png"/> with <img class="formulaInl" alt="$b_i$" src="form_19.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> we are taking the Cartesian product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> resulting from the Cartesian product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>'s domains with <code>rhs's</code> Domains.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is not enough memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26769d30a718f375e7fa9205bb27b0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26769d30a718f375e7fa9205bb27b0c4">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp; tensorwrapper::sparse_map::SparseMap::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> with domains given by the Cartesian product of the Domains previously in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> with the Domains in <code>rhs</code>. </p>
<p>Given a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> <img class="formulaInl" alt="$A$" src="form_1.png"/> which maps independent index <img class="formulaInl" alt="$i$" src="form_9.png"/> to <img class="formulaInl" alt="$a_i$" src="form_15.png"/> and a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> <img class="formulaInl" alt="$B$" src="form_3.png"/> which maps independent index <img class="formulaInl" alt="$i$" src="form_9.png"/> to <img class="formulaInl" alt="$b_i$" src="form_19.png"/>. This function computes a third <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>, <img class="formulaInl" alt="$C$" src="form_5.png"/>, where the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> <img class="formulaInl" alt="$c_i$" src="form_20.png"/>-th element is the Cartesian product of <img class="formulaInl" alt="$a_i$" src="form_15.png"/> with <img class="formulaInl" alt="$b_i$" src="form_19.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> we are taking the Cartesian product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> with Domains set to the resultof the Cartesian product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>'s previous domains with <code>rhs's</code> Domains.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is not enough memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7198aa2b2d6326d65d455494bd95a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7198aa2b2d6326d65d455494bd95a91">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> tensorwrapper::sparse_map::SparseMap::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> which is the union of this and another map. </p>
<p>Given two SparseMaps sm1(f -&gt; g) and sm2(f -&gt; g), the union is formed by mapping f_i to any element in g which f_i is mapped to by either sm1 or sm2.</p>
<p>Requires that either one of the sets is empty or both sets have the same rank in independent and dependent indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to take the union with this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the two maps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if neither map is empty and the rank of the independent/dependent indices of this instance are not equal to the rank of the independent/ dependent indices of <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8de936b5a542971b17f931241db31f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de936b5a542971b17f931241db31f08">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp; tensorwrapper::sparse_map::SparseMap::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to the union of this and another map. </p>
<p>Given two SparseMaps sm1(f -&gt; g) and sm2(f -&gt; g), the union is formed by mapping f_i to any element in g which f_i is mapped to by either sm1 or sm2.</p>
<p>Requires that either one of the sets is empty or both sets have the same rank in independent and dependent indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to take the union with this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance set to the union of the two maps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if neither map is empty and the rank of the independent/dependent indices of this instance are not equal to the rank of the independent/ dependent indices of <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cb5b575b289737dd481855483ccbf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb5b575b289737dd481855483ccbf47">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp; tensorwrapper::sparse_map::SparseMap::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this instance's state to a copy of <code>rhs's</code> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state is being copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance after setting its state to a copy of <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>rhs</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7b567184db536fe87a51570f0186027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b567184db536fe87a51570f0186027">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp; tensorwrapper::sparse_map::SparseMap::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of another instance's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state is being transferred. After this call <code>rhs</code> will have no PIMPL and will behave like an empty <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance containing <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a578312a3cbaf4704c642e5dc31e2dcb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578312a3cbaf4704c642e5dc31e2dcb2">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tensorwrapper::sparse_map::SparseMap::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two SparseMaps are identical. </p>
<p>Two SparseMaps are the same if they:</p><ul>
<li>contain the same number of independent-indices</li>
<li>the set of independent indices is the same, and</li>
<li>each independent index maps to the same <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is the same as <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a518d8fe6b059fe990cdb8d35912ce935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518d8fe6b059fe990cdb8d35912ce935">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a1912c661ee8252152e87dc83b2d0155a">SparseMap::mapped_type</a> &amp; tensorwrapper::sparse_map::SparseMap::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#add1b74131c19ff3a4af347ac82fdfe4e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with the specified independent index. </p>
<p>This function can be used to retrieve the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with a independent index. Since this is a const method an exception will be raised if the independent index is not in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> (as it can not be added).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The independent index whose <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> we want. The rank of <code>key</code> must be equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a0f83281ad8ab4abbe214e40185c21236" title="Returns the rank of the independent indices.">ind_rank()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with <code>key</code> in a read-only manner.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> is not in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the rank of <code>key</code> is not equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a0f83281ad8ab4abbe214e40185c21236" title="Returns the rank of the independent indices.">ind_rank()</a></code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a8720c0cdcfd92372a0b052740ab151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8720c0cdcfd92372a0b052740ab151">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> tensorwrapper::sparse_map::SparseMap::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> and another map. </p>
<p>Given two SparseMaps sm1(f -&gt; g) and sm2(f -&gt; g), the intersection is formed by mapping f_i to any element in g which f_i is mapped to by both sm1 and sm2. Note that if the ranks of the independent indices (or the dependent indices) are different between the two maps the intersection is empty. Similarly the intersection of any map with an empty map is also empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to take the intersection with this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The intersection of the two maps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83aa17a5c8df0056804087c607638130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83aa17a5c8df0056804087c607638130">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp; tensorwrapper::sparse_map::SparseMap::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this the intersection of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> and another map. </p>
<p>Given two SparseMaps sm1(f -&gt; g) and sm2(f -&gt; g), the intersection is formed by mapping f_i to any element in g which f_i is mapped to by both sm1 and sm2. Note that if the ranks of the independent indices (or the dependent indices) are different between the two maps the intersection is empty. Similarly the intersection of any map with an empty map is also empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to take the intersection with this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> set to the intersection of the two maps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cb9ba13a4bcafe6c8c11e534febc46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb9ba13a4bcafe6c8c11e534febc46b">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; tensorwrapper::sparse_map::SparseMap::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we are adding the string representation to. After this call the stream will contain the string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> with this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> added to it. </dd></dl>

</div>
</div>
<a id="adb7231e1af43736fdb4d194f7b7d5465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7231e1af43736fdb4d194f7b7d5465">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a832e1e642093c1fe906e85e1471b5ae1">SparseMap::size_type</a> tensorwrapper::sparse_map::SparseMap::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of independent indices in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. </p>
<p>Each independent index in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is paired with a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. This function can be used to retrieve the number of independent indices in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>, which is also the number of Domains and the number of independent-index-domain pairs.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of independent indices in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05a80ca8e78a385b976c96b63a50ad39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a80ca8e78a385b976c96b63a50ad39">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tensorwrapper::sparse_map::SparseMap::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the state of two SparseMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The instance whose state is being swapped with. After this operation <code>rhs</code> will contain this instance's original state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4fc7959672acf3ed5f19669a86b3fdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc7959672acf3ed5f19669a86b3fdc6">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two SparseMaps are different. </p>
<p>Two SparseMaps are the same if they:</p><ul>
<li>contain the same number of independent-indices</li>
<li>the set of independent indices is the same, and</li>
<li>each independent index maps to the same <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> on the right side of the operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> on the left side of the operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> is the same as <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa289991131f62d0fe365b191a2b0ed62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa289991131f62d0fe365b191a2b0ed62">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> &amp;&#160;</td>
          <td class="paramname"><em>smb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> to the stream. </p>
<p>This is a convenience function for calling <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html#a1cb9ba13a4bcafe6c8c11e534febc46b" title="Adds a string representation of the SparseMap to the stream.">SparseMap::print</a> on a stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we are adding the string representation to. After this call the stream will contain the string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smb</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> we are printing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> with this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a> added to it. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/tensorwrapper/sparse_map/sparse_map/<a class="el" href="sparse__map_2sparse__map_8hpp_source.html">sparse_map.hpp</a></li>
<li>src/tensorwrapper/sparse_map/sparse_map/sparse_map.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
