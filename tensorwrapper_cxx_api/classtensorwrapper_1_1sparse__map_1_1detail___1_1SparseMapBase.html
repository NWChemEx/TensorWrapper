<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::sparse_map::detail_::SparseMapBase&lt; DerivedType, IndIndex, DepIndex &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorwrapper</b></li><li class="navelem"><a class="el" href="namespacetensorwrapper_1_1sparse__map.html">sparse_map</a></li><li class="navelem"><b>detail_</b></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::sparse_map::detail_::SparseMapBase&lt; DerivedType, IndIndex, DepIndex &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c475619efe52b4e15b7bf202b868cc6"><td class="memItemLeft" align="right" valign="top"><a id="a9c475619efe52b4e15b7bf202b868cc6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c475619efe52b4e15b7bf202b868cc6">size_type</a> = typename traits_t::size_type</td></tr>
<tr class="memdesc:a9c475619efe52b4e15b7bf202b868cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for offsets and counting. <br /></td></tr>
<tr class="separator:a9c475619efe52b4e15b7bf202b868cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf66b1504e7c0206fc34aa228c97e9db"><td class="memItemLeft" align="right" valign="top"><a id="adf66b1504e7c0206fc34aa228c97e9db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adf66b1504e7c0206fc34aa228c97e9db">key_type</a> = typename traits_t::key_type</td></tr>
<tr class="memdesc:adf66b1504e7c0206fc34aa228c97e9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the independent index. <br /></td></tr>
<tr class="separator:adf66b1504e7c0206fc34aa228c97e9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6e9226c94b50733c1a0ba6b4faeec5"><td class="memItemLeft" align="right" valign="top"><a id="acf6e9226c94b50733c1a0ba6b4faeec5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#acf6e9226c94b50733c1a0ba6b4faeec5">mapped_type</a> = typename traits_t::mapped_type</td></tr>
<tr class="memdesc:acf6e9226c94b50733c1a0ba6b4faeec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a domain of dependent indices. <br /></td></tr>
<tr class="separator:acf6e9226c94b50733c1a0ba6b4faeec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a831c108393d6622b0b6fed0f58ee71"><td class="memItemLeft" align="right" valign="top"><a id="a9a831c108393d6622b0b6fed0f58ee71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9a831c108393d6622b0b6fed0f58ee71">value_type</a> = typename traits_t::value_type</td></tr>
<tr class="memdesc:a9a831c108393d6622b0b6fed0f58ee71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the independent-index-domain pairs. <br /></td></tr>
<tr class="separator:a9a831c108393d6622b0b6fed0f58ee71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2301769aa0e939481f13eabe7aaee869"><td class="memItemLeft" align="right" valign="top"><a id="a2301769aa0e939481f13eabe7aaee869"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2301769aa0e939481f13eabe7aaee869">const_iterator</a> = typename traits_t::template <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2301769aa0e939481f13eabe7aaee869">const_iterator</a>&lt; DerivedType &gt;</td></tr>
<tr class="memdesc:a2301769aa0e939481f13eabe7aaee869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a bidirectional iterator with read-only access to indices. <br /></td></tr>
<tr class="separator:a2301769aa0e939481f13eabe7aaee869"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac84fb4fad4e1fd2b928faef4e90c495f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ac84fb4fad4e1fd2b928faef4e90c495f">SparseMapBase</a> ()</td></tr>
<tr class="memdesc:ac84fb4fad4e1fd2b928faef4e90c495f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new empty <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ac84fb4fad4e1fd2b928faef4e90c495f">More...</a><br /></td></tr>
<tr class="separator:ac84fb4fad4e1fd2b928faef4e90c495f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16bf91c749bdc56ae27a82d2633dc8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ae16bf91c749bdc56ae27a82d2633dc8d">SparseMapBase</a> (il_t il)</td></tr>
<tr class="memdesc:ae16bf91c749bdc56ae27a82d2633dc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ae16bf91c749bdc56ae27a82d2633dc8d">More...</a><br /></td></tr>
<tr class="separator:ae16bf91c749bdc56ae27a82d2633dc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad6b7d4e274cf8e889f1fb967b4ac0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a8ad6b7d4e274cf8e889f1fb967b4ac0a">SparseMapBase</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8ad6b7d4e274cf8e889f1fb967b4ac0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> by copying another instance.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a8ad6b7d4e274cf8e889f1fb967b4ac0a">More...</a><br /></td></tr>
<tr class="separator:a8ad6b7d4e274cf8e889f1fb967b4ac0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3e087f4900f605a53c11b24edf0bbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c3e087f4900f605a53c11b24edf0bbd">SparseMapBase</a> (<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9c3e087f4900f605a53c11b24edf0bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> instance by taking ownership of another instance's state.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c3e087f4900f605a53c11b24edf0bbd">More...</a><br /></td></tr>
<tr class="separator:a9c3e087f4900f605a53c11b24edf0bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cd01e635511dfb30307b0e92ce408e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a49cd01e635511dfb30307b0e92ce408e">operator=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs)</td></tr>
<tr class="memdesc:a49cd01e635511dfb30307b0e92ce408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this instance's state to a copy of <code>rhs's</code> state.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a49cd01e635511dfb30307b0e92ce408e">More...</a><br /></td></tr>
<tr class="separator:a49cd01e635511dfb30307b0e92ce408e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55eb76a76891e797590a75dab5b1daa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a55eb76a76891e797590a75dab5b1daa6">operator=</a> (<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a55eb76a76891e797590a75dab5b1daa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of another instance's state.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a55eb76a76891e797590a75dab5b1daa6">More...</a><br /></td></tr>
<tr class="separator:a55eb76a76891e797590a75dab5b1daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac095de39b6da19ed8907c9d54dfbb0cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ac095de39b6da19ed8907c9d54dfbb0cc">~SparseMapBase</a> () noexcept</td></tr>
<tr class="memdesc:ac095de39b6da19ed8907c9d54dfbb0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default dtor.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ac095de39b6da19ed8907c9d54dfbb0cc">More...</a><br /></td></tr>
<tr class="separator:ac095de39b6da19ed8907c9d54dfbb0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266d573a5acf17556c9014b842fd19f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a266d573a5acf17556c9014b842fd19f1">swap</a> (<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a266d573a5acf17556c9014b842fd19f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the state of two SparseMaps.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a266d573a5acf17556c9014b842fd19f1">More...</a><br /></td></tr>
<tr class="separator:a266d573a5acf17556c9014b842fd19f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f1ab18d065f00653b83d29458feaa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c475619efe52b4e15b7bf202b868cc6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a01f1ab18d065f00653b83d29458feaa0">size</a> () const noexcept</td></tr>
<tr class="memdesc:a01f1ab18d065f00653b83d29458feaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of independent indices in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a01f1ab18d065f00653b83d29458feaa0">More...</a><br /></td></tr>
<tr class="separator:a01f1ab18d065f00653b83d29458feaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d50f6687718c0724b64b2055ddf0bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a18d50f6687718c0724b64b2055ddf0bb">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a18d50f6687718c0724b64b2055ddf0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is empty.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a18d50f6687718c0724b64b2055ddf0bb">More...</a><br /></td></tr>
<tr class="separator:a18d50f6687718c0724b64b2055ddf0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52205d3a4572b6acd31594cbc4580ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ac52205d3a4572b6acd31594cbc4580ab">count</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adf66b1504e7c0206fc34aa228c97e9db">key_type</a> &amp;i) const noexcept</td></tr>
<tr class="memdesc:ac52205d3a4572b6acd31594cbc4580ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> contains the specified independent index.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ac52205d3a4572b6acd31594cbc4580ab">More...</a><br /></td></tr>
<tr class="separator:ac52205d3a4572b6acd31594cbc4580ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c7b0e49e36a57d92e1f111bd4c81ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c475619efe52b4e15b7bf202b868cc6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44c7b0e49e36a57d92e1f111bd4c81ce">ind_rank</a> () const noexcept</td></tr>
<tr class="memdesc:a44c7b0e49e36a57d92e1f111bd4c81ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the independent indices.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44c7b0e49e36a57d92e1f111bd4c81ce">More...</a><br /></td></tr>
<tr class="separator:a44c7b0e49e36a57d92e1f111bd4c81ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfdff4261d8ba34e205a763b0d2e268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c475619efe52b4e15b7bf202b868cc6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2bfdff4261d8ba34e205a763b0d2e268">dep_rank</a> () const noexcept</td></tr>
<tr class="memdesc:a2bfdff4261d8ba34e205a763b0d2e268"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of independent modes associated with each <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2bfdff4261d8ba34e205a763b0d2e268">More...</a><br /></td></tr>
<tr class="separator:a2bfdff4261d8ba34e205a763b0d2e268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14406a910603a784b92110a647e8cfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ac14406a910603a784b92110a647e8cfa">add_to_domain</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adf66b1504e7c0206fc34aa228c97e9db">key_type</a> &amp;key, DepIndex value)</td></tr>
<tr class="memdesc:ac14406a910603a784b92110a647e8cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dependent index to an independent index's <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ac14406a910603a784b92110a647e8cfa">More...</a><br /></td></tr>
<tr class="separator:ac14406a910603a784b92110a647e8cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce1fa69f05b269ba46464b10a0ff2f9"><td class="memItemLeft" align="right" valign="top"><a id="a8ce1fa69f05b269ba46464b10a0ff2f9"></a>
const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9a831c108393d6622b0b6fed0f58ee71">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c475619efe52b4e15b7bf202b868cc6">size_type</a> i) const</td></tr>
<tr class="separator:a8ce1fa69f05b269ba46464b10a0ff2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf568271841950935c9b5cd21ec4758"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#acf6e9226c94b50733c1a0ba6b4faeec5">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adaf568271841950935c9b5cd21ec4758">operator[]</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adf66b1504e7c0206fc34aa228c97e9db">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:adaf568271841950935c9b5cd21ec4758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with the specified independent index.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adaf568271841950935c9b5cd21ec4758">More...</a><br /></td></tr>
<tr class="separator:adaf568271841950935c9b5cd21ec4758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db3300be9229d009439d385efd680f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#acf6e9226c94b50733c1a0ba6b4faeec5">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a7db3300be9229d009439d385efd680f0">at</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adf66b1504e7c0206fc34aa228c97e9db">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a7db3300be9229d009439d385efd680f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with the specified independent index.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a7db3300be9229d009439d385efd680f0">More...</a><br /></td></tr>
<tr class="separator:a7db3300be9229d009439d385efd680f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad88b5fb5fbe50d66960f8c31b2c944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2301769aa0e939481f13eabe7aaee869">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a8ad88b5fb5fbe50d66960f8c31b2c944">begin</a> () const</td></tr>
<tr class="memdesc:a8ad88b5fb5fbe50d66960f8c31b2c944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator which points to the first independent-index-Domain pair.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a8ad88b5fb5fbe50d66960f8c31b2c944">More...</a><br /></td></tr>
<tr class="separator:a8ad88b5fb5fbe50d66960f8c31b2c944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d36ed59e8b5acba6e7c9e8471198baf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2301769aa0e939481f13eabe7aaee869">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a0d36ed59e8b5acba6e7c9e8471198baf">end</a> () const</td></tr>
<tr class="memdesc:a0d36ed59e8b5acba6e7c9e8471198baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the end of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a0d36ed59e8b5acba6e7c9e8471198baf">More...</a><br /></td></tr>
<tr class="separator:a0d36ed59e8b5acba6e7c9e8471198baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed9fd249aef5b0f9c8f41de22c6148f"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a5ed9fd249aef5b0f9c8f41de22c6148f">direct_product</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a5ed9fd249aef5b0f9c8f41de22c6148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the direct product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> and another <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a5ed9fd249aef5b0f9c8f41de22c6148f">More...</a><br /></td></tr>
<tr class="separator:a5ed9fd249aef5b0f9c8f41de22c6148f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada08cf2682ace45e1ba0fc187da170a5"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ada08cf2682ace45e1ba0fc187da170a5">operator*</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ada08cf2682ace45e1ba0fc187da170a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> with domains given by the Cartesian product of the Domains in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> with the Domains in <code>rhs</code>.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ada08cf2682ace45e1ba0fc187da170a5">More...</a><br /></td></tr>
<tr class="separator:ada08cf2682ace45e1ba0fc187da170a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4560f94f6975e0741084e09d1cf1e3a7"><td class="memItemLeft" align="right" valign="top">DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a4560f94f6975e0741084e09d1cf1e3a7">operator*=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4560f94f6975e0741084e09d1cf1e3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> with domains given by the Cartesian product of the Domains previously in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> with the Domains in <code>rhs</code>.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a4560f94f6975e0741084e09d1cf1e3a7">More...</a><br /></td></tr>
<tr class="separator:a4560f94f6975e0741084e09d1cf1e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f3038512caeea87f5f1cecb414ed8"><td class="memItemLeft" align="right" valign="top">DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ae75f3038512caeea87f5f1cecb414ed8">operator+=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs)</td></tr>
<tr class="memdesc:ae75f3038512caeea87f5f1cecb414ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the union of this and another map.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ae75f3038512caeea87f5f1cecb414ed8">More...</a><br /></td></tr>
<tr class="separator:ae75f3038512caeea87f5f1cecb414ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab238cb2ffa9bbf1837992ea1deb5df10"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ab238cb2ffa9bbf1837992ea1deb5df10">operator+</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ab238cb2ffa9bbf1837992ea1deb5df10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> which is the union of this and another map.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ab238cb2ffa9bbf1837992ea1deb5df10">More...</a><br /></td></tr>
<tr class="separator:ab238cb2ffa9bbf1837992ea1deb5df10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69280ccc01a48b8ece75a0a6ec42926"><td class="memItemLeft" align="right" valign="top">DerivedType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#af69280ccc01a48b8ece75a0a6ec42926">operator^=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs)</td></tr>
<tr class="memdesc:af69280ccc01a48b8ece75a0a6ec42926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this the intersection of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> and another map.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#af69280ccc01a48b8ece75a0a6ec42926">More...</a><br /></td></tr>
<tr class="separator:af69280ccc01a48b8ece75a0a6ec42926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511907365fadafead4e13638657e4b1c"><td class="memItemLeft" align="right" valign="top">DerivedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a511907365fadafead4e13638657e4b1c">operator^</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a511907365fadafead4e13638657e4b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> and another map.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a511907365fadafead4e13638657e4b1c">More...</a><br /></td></tr>
<tr class="separator:a511907365fadafead4e13638657e4b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1618217e5c6b92d6b7d36716de9513f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&lt; DepIndex, IndIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a1618217e5c6b92d6b7d36716de9513f7">inverse</a> () const</td></tr>
<tr class="memdesc:a1618217e5c6b92d6b7d36716de9513f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the inverse <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a1618217e5c6b92d6b7d36716de9513f7">More...</a><br /></td></tr>
<tr class="separator:a1618217e5c6b92d6b7d36716de9513f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7e961a7992c2e514fc49d451fdebfb"><td class="memTemplParams" colspan="2">template&lt;typename RHpluginplaypIdx &gt; </td></tr>
<tr class="memitem:a3f7e961a7992c2e514fc49d451fdebfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&lt; IndIndex, RHpluginplaypIdx &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a3f7e961a7992c2e514fc49d451fdebfb">chain</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&lt; DepIndex, RHpluginplaypIdx &gt; &amp;sm) const</td></tr>
<tr class="memdesc:a3f7e961a7992c2e514fc49d451fdebfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> from chaining two maps together.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a3f7e961a7992c2e514fc49d451fdebfb">More...</a><br /></td></tr>
<tr class="separator:a3f7e961a7992c2e514fc49d451fdebfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae599163ddd47676b97f0dfda73d3104b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ae599163ddd47676b97f0dfda73d3104b">operator==</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ae599163ddd47676b97f0dfda73d3104b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two SparseMaps are identical.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ae599163ddd47676b97f0dfda73d3104b">More...</a><br /></td></tr>
<tr class="separator:ae599163ddd47676b97f0dfda73d3104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade746d28bdc63a27ef712c94620f164f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ade746d28bdc63a27ef712c94620f164f">print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:ade746d28bdc63a27ef712c94620f164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to the stream.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ade746d28bdc63a27ef712c94620f164f">More...</a><br /></td></tr>
<tr class="separator:ade746d28bdc63a27ef712c94620f164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb471fcae240fe26e0d6eb4c5049b156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adb471fcae240fe26e0d6eb4c5049b156">hash</a> (tensorwrapper::detail_::Hasher &amp;h) const</td></tr>
<tr class="memdesc:adb471fcae240fe26e0d6eb4c5049b156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>'s state to a hash.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adb471fcae240fe26e0d6eb4c5049b156">More...</a><br /></td></tr>
<tr class="separator:adb471fcae240fe26e0d6eb4c5049b156"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ada16d657e7cee5cd9a8edba13fc9fa21"><td class="memItemLeft" align="right" valign="top"><a id="ada16d657e7cee5cd9a8edba13fc9fa21"></a>
<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapPIMPL.html">pimpl_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ada16d657e7cee5cd9a8edba13fc9fa21">pimpl_</a> ()</td></tr>
<tr class="memdesc:ada16d657e7cee5cd9a8edba13fc9fa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures the instance has a PIMPL and returns it. <br /></td></tr>
<tr class="separator:ada16d657e7cee5cd9a8edba13fc9fa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3f57d257e5d34513f6a0d3730df934"><td class="memItemLeft" align="right" valign="top"><a id="afe3f57d257e5d34513f6a0d3730df934"></a>
const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapPIMPL.html">pimpl_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#afe3f57d257e5d34513f6a0d3730df934">pimpl_</a> () const</td></tr>
<tr class="memdesc:afe3f57d257e5d34513f6a0d3730df934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures the instance has a PIMPL and returns it in a read-only state. <br /></td></tr>
<tr class="separator:afe3f57d257e5d34513f6a0d3730df934"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a44ff90ff84b1c561f8fb7f4d5cef25c2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </td></tr>
<tr class="memitem:a44ff90ff84b1c561f8fb7f4d5cef25c2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44ff90ff84b1c561f8fb7f4d5cef25c2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;smb)</td></tr>
<tr class="memdesc:a44ff90ff84b1c561f8fb7f4d5cef25c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to the stream.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44ff90ff84b1c561f8fb7f4d5cef25c2">More...</a><br /></td></tr>
<tr class="separator:a44ff90ff84b1c561f8fb7f4d5cef25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133651c177469b5769f44a3b9b88bfaa"><td class="memTemplParams" colspan="2">template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </td></tr>
<tr class="memitem:a133651c177469b5769f44a3b9b88bfaa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a133651c177469b5769f44a3b9b88bfaa">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;lhs, const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a133651c177469b5769f44a3b9b88bfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two SparseMaps are different.  <a href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a133651c177469b5769f44a3b9b88bfaa">More...</a><br /></td></tr>
<tr class="separator:a133651c177469b5769f44a3b9b88bfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac84fb4fad4e1fd2b928faef4e90c495f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84fb4fad4e1fd2b928faef4e90c495f">&#9670;&nbsp;</a></span>SparseMapBase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new empty <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. </p>
<p>This constructor is used to create a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> which contains no independent elements (and thus no dependent elements either).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the PIMPL. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae16bf91c749bdc56ae27a82d2633dc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16bf91c749bdc56ae27a82d2633dc8d">&#9670;&nbsp;</a></span>SparseMapBase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> </td>
          <td>(</td>
          <td class="paramtype">il_t&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of. </p>
<p>This ctor allows you to specify at construction the independent indices and the domains they map to. The format is:</p>
<div class="fragment"><div class="line">{{i0, {d00, d01, ...}}, {i1, {d10, d11, ...}}, ...}</div>
</div><!-- fragment --><p>where <code>i0</code>, and <code>i1</code> are independent indices <code>d00</code>, <code>d01</code> are the first two dependent indices associated with <code>i0</code> and <code>d10</code> and <code>d11</code> are the first two dependent indices associated with <code>i1</code>. In practice this ctor is intended primarily for use with unit testing as that is one of the few scenarios where one can just lay out the contents of the sparse map to create.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The initial state of the sparse map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the initial state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ad6b7d4e274cf8e889f1fb967b4ac0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad6b7d4e274cf8e889f1fb967b4ac0a">&#9670;&nbsp;</a></span>SparseMapBase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> by copying another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> we are copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>rhs</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c3e087f4900f605a53c11b24edf0bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3e087f4900f605a53c11b24edf0bbd">&#9670;&nbsp;</a></span>SparseMapBase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> instance by taking ownership of another instance's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state is being taken. After this call <code>rhs</code> will contain no PIMPL and thus will behave like an empty <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac095de39b6da19ed8907c9d54dfbb0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac095de39b6da19ed8907c9d54dfbb0cc">&#9670;&nbsp;</a></span>~SparseMapBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::~<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default dtor. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac14406a910603a784b92110a647e8cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14406a910603a784b92110a647e8cfa">&#9670;&nbsp;</a></span>add_to_domain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::add_to_domain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adf66b1504e7c0206fc34aa228c97e9db">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DepIndex&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a dependent index to an independent index's <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. </p>
<p>This function adds an dependent index to and independent index's <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. This function will create the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> if the independent index is not already in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. If the dependent index is already in the independent index's <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The independent index to which <code>value</code> should be added. If this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is non-empty the rank of <code>key</code> must be equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44c7b0e49e36a57d92e1f111bd4c81ce" title="Returns the rank of the independent indices.">ind_rank()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The dependent index being added to <code>key's</code> domain. If <code>key's</code> <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> is non-empty the rank of <code>value</code> must be equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2bfdff4261d8ba34e205a763b0d2e268" title="The number of independent modes associated with each Domain.">dep_rank()</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to add the new state. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is non-empty and the rank of <code>key</code> is not equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44c7b0e49e36a57d92e1f111bd4c81ce" title="Returns the rank of the independent indices.">ind_rank()</a></code> or if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with <code>key</code> is non-empty and the rank of <code>value</code> is not equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2bfdff4261d8ba34e205a763b0d2e268" title="The number of independent modes associated with each Domain.">dep_rank()</a></code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7db3300be9229d009439d385efd680f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db3300be9229d009439d385efd680f0">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#acf6e9226c94b50733c1a0ba6b4faeec5">mapped_type</a>&amp; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adf66b1504e7c0206fc34aa228c97e9db">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with the specified independent index. </p>
<p>This function can be used to retrieve the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with a independent index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The independent index whose <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> we want. The rank of <code>key</code> must be equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44c7b0e49e36a57d92e1f111bd4c81ce" title="Returns the rank of the independent indices.">ind_rank()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with <code>key</code> in a read-only manner.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> is not in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the rank of <code>key</code> is not equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44c7b0e49e36a57d92e1f111bd4c81ce" title="Returns the rank of the independent indices.">ind_rank()</a></code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ad88b5fb5fbe50d66960f8c31b2c944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad88b5fb5fbe50d66960f8c31b2c944">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2301769aa0e939481f13eabe7aaee869">const_iterator</a> <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator which points to the first independent-index-Domain pair. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element of this map. Elements of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> can not be modified through the iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is no PIMPL. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f7e961a7992c2e514fc49d451fdebfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7e961a7992c2e514fc49d451fdebfb">&#9670;&nbsp;</a></span>chain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<div class="memtemplate">
template&lt;typename RHpluginplaypIdx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&lt;IndIndex, RHpluginplaypIdx&gt; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&lt; DepIndex, RHpluginplaypIdx &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> from chaining two maps together. </p>
<p>Given the SparseMaps sm1(f -&gt; g) and sm2(g -&gt; h), the chained map from (f -&gt; h) is formed by mapping each element f_i to a set of {g_i} using sm1, and then to any element in h which is mapped to from an element of {g_i} by sm2.</p>
<p>Requires that the maps share a common set of indices, g, as the dependent and independent indices respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to chain with this instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The chained map. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the rank of the dependent indices of this instance is not equal to the rank of the independent indices of <code>sm</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac52205d3a4572b6acd31594cbc4580ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52205d3a4572b6acd31594cbc4580ab">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adf66b1504e7c0206fc34aa228c97e9db">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> contains the specified independent index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index we are looking for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the index is in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bfdff4261d8ba34e205a763b0d2e268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfdff4261d8ba34e205a763b0d2e268">&#9670;&nbsp;</a></span>dep_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c475619efe52b4e15b7bf202b868cc6">size_type</a> <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::dep_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of independent modes associated with each <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. </p>
<p>Each independent index maps to a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. Each <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> contains indices of the same rank. For a given <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> all of the mapped to Domains must contain indices of the same rank (or be empty). This function will return the rank of the indices in the Domains. The return is 0 if this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is empty, all the Domains are empty, or all Domains contain a rank 0 index.</p>
<dl class="section return"><dt>Returns</dt><dd>The rank of the indices in the Domains this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> maps to.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ed9fd249aef5b0f9c8f41de22c6148f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed9fd249aef5b0f9c8f41de22c6148f">&#9670;&nbsp;</a></span>direct_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedType <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::direct_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the direct product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> and another <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. </p>
<p>Given a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> <img class="formulaInl" alt="$A$" src="form_1.png"/> with <img class="formulaInl" alt="$i$" src="form_9.png"/>-th element <img class="formulaInl" alt="$(a_i, \alpha_i)$" src="form_14.png"/> ( <img class="formulaInl" alt="$a_i$" src="form_15.png"/> is the independent index and <img class="formulaInl" alt="$\alpha_i$" src="form_16.png"/> is the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with <img class="formulaInl" alt="$a_i$" src="form_15.png"/>) and a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> <img class="formulaInl" alt="$B$" src="form_3.png"/> with <img class="formulaInl" alt="$j$" src="form_10.png"/>-th element <img class="formulaInl" alt="$(b_j, \beta_j)$" src="form_17.png"/> this function computes a new <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> <img class="formulaInl" alt="$C$" src="form_5.png"/> which we say is the direct product of <img class="formulaInl" alt="$A$" src="form_1.png"/> with <img class="formulaInl" alt="$B$" src="form_3.png"/>. <img class="formulaInl" alt="$C$" src="form_5.png"/> is given by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C = \left\lbrace (a_ib_j, \alpha_i\beta_j) \forall (a_i, \alpha_i) \in A \forall (b_j, \beta_j) \in B \right\rbrace \]" src="form_18.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> we are taking the direct product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The direct product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>'s state with <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is not enough memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18d50f6687718c0724b64b2055ddf0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d50f6687718c0724b64b2055ddf0bb">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is empty. </p>
<p>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is empty if it contains no independent indices. Of note a sparse map with an independent rank 0 index contains one index and is not empty.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is empty and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is implemented by checking if size equals zero so that it can be no-throw. </dd></dl>

</div>
</div>
<a id="a0d36ed59e8b5acba6e7c9e8471198baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d36ed59e8b5acba6e7c9e8471198baf">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a2301769aa0e939481f13eabe7aaee869">const_iterator</a> <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the end of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to just past the end of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the map has no PIMPL. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb471fcae240fe26e0d6eb4c5049b156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb471fcae240fe26e0d6eb4c5049b156">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">tensorwrapper::detail_::Hasher &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>'s state to a hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>The object hashing the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. After this call the internal hash of <code>h</code> will be updated to include this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>'s state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44c7b0e49e36a57d92e1f111bd4c81ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c7b0e49e36a57d92e1f111bd4c81ce">&#9670;&nbsp;</a></span>ind_rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c475619efe52b4e15b7bf202b868cc6">size_type</a> <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::ind_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the independent indices. </p>
<p>All independent indices in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> must have the same rank (<em>i.e.</em>, number of modes). This function can be used to determine what the rank of the independent indices are. Note that if the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is empty we return a rank of 0; hence both empty sparse maps and SparseMaps with independent indices of rank 0 return 0 (use <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a18d50f6687718c0724b64b2055ddf0bb" title="Determines if the SparseMap is empty.">empty()</a></code> to distinguish between the two cases).</p>
<dl class="section return"><dt>Returns</dt><dd>The rank of the independent indices.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1618217e5c6b92d6b7d36716de9513f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1618217e5c6b92d6b7d36716de9513f7">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html">SparseMap</a>&lt;DepIndex, IndIndex&gt; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the inverse <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. </p>
<p>Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> which maps from the dependent indices to the independent indices of the current map.</p>
<p>sparse_map.inverse().<a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a1618217e5c6b92d6b7d36716de9513f7" title="Constructs the inverse SparseMap.">inverse()</a> == <a class="el" href="namespacetensorwrapper_1_1sparse__map.html" title="Contains classes and functions related to SparseMap objects.">sparse_map</a></p>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to create the returned value. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada08cf2682ace45e1ba0fc187da170a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada08cf2682ace45e1ba0fc187da170a5">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedType <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> with domains given by the Cartesian product of the Domains in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> with the Domains in <code>rhs</code>. </p>
<p>Given a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> <img class="formulaInl" alt="$A$" src="form_1.png"/> which maps independent index <img class="formulaInl" alt="$i$" src="form_9.png"/> to <img class="formulaInl" alt="$a_i$" src="form_15.png"/> and a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> <img class="formulaInl" alt="$B$" src="form_3.png"/> which maps independent index <img class="formulaInl" alt="$i$" src="form_9.png"/> to <img class="formulaInl" alt="$b_i$" src="form_19.png"/>. This function computes a third <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>, <img class="formulaInl" alt="$C$" src="form_5.png"/>, where the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> <img class="formulaInl" alt="$c_i$" src="form_20.png"/>-th element is the Cartesian product of <img class="formulaInl" alt="$a_i$" src="form_15.png"/> with <img class="formulaInl" alt="$b_i$" src="form_19.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> we are taking the Cartesian product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> resulting from the Cartesian product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>'s domains with <code>rhs's</code> Domains.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is not enough memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4560f94f6975e0741084e09d1cf1e3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4560f94f6975e0741084e09d1cf1e3a7">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedType&amp; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> with domains given by the Cartesian product of the Domains previously in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> with the Domains in <code>rhs</code>. </p>
<p>Given a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> <img class="formulaInl" alt="$A$" src="form_1.png"/> which maps independent index <img class="formulaInl" alt="$i$" src="form_9.png"/> to <img class="formulaInl" alt="$a_i$" src="form_15.png"/> and a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> <img class="formulaInl" alt="$B$" src="form_3.png"/> which maps independent index <img class="formulaInl" alt="$i$" src="form_9.png"/> to <img class="formulaInl" alt="$b_i$" src="form_19.png"/>. This function computes a third <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>, <img class="formulaInl" alt="$C$" src="form_5.png"/>, where the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> <img class="formulaInl" alt="$c_i$" src="form_20.png"/>-th element is the Cartesian product of <img class="formulaInl" alt="$a_i$" src="form_15.png"/> with <img class="formulaInl" alt="$b_i$" src="form_19.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> we are taking the Cartesian product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> with Domains set to the resultof the Cartesian product of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>'s previous domains with <code>rhs's</code> Domains.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is not enough memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab238cb2ffa9bbf1837992ea1deb5df10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab238cb2ffa9bbf1837992ea1deb5df10">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedType <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> which is the union of this and another map. </p>
<p>Given two SparseMaps sm1(f -&gt; g) and sm2(f -&gt; g), the union is formed by mapping f_i to any element in g which f_i is mapped to by either sm1 or sm2.</p>
<p>Requires that either one of the sets is empty or both sets have the same rank in independent and dependent indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to take the union with this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the two maps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if neither map is empty and the rank of the independent/dependent indices of this instance are not equal to the rank of the independent/ dependent indices of <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae75f3038512caeea87f5f1cecb414ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75f3038512caeea87f5f1cecb414ed8">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedType&amp; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to the union of this and another map. </p>
<p>Given two SparseMaps sm1(f -&gt; g) and sm2(f -&gt; g), the union is formed by mapping f_i to any element in g which f_i is mapped to by either sm1 or sm2.</p>
<p>Requires that either one of the sets is empty or both sets have the same rank in independent and dependent indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to take the union with this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance set to the union of the two maps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if neither map is empty and the rank of the independent/dependent indices of this instance are not equal to the rank of the independent/ dependent indices of <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49cd01e635511dfb30307b0e92ce408e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cd01e635511dfb30307b0e92ce408e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&amp; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this instance's state to a copy of <code>rhs's</code> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state is being copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance after setting its state to a copy of <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>rhs</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55eb76a76891e797590a75dab5b1daa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55eb76a76891e797590a75dab5b1daa6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&amp; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of another instance's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state is being transferred. After this call <code>rhs</code> will have no PIMPL and will behave like an empty <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance containing <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae599163ddd47676b97f0dfda73d3104b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae599163ddd47676b97f0dfda73d3104b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two SparseMaps are identical. </p>
<p>Two SparseMaps are the same if they:</p><ul>
<li>map from the same type of independent/dependent index<ul>
<li><em>e.g.</em> independent indices ar both ElementalIndex and dependent indices are both <a class="el" href="structtensorwrapper_1_1sparse__map_1_1TileIndex.html" title="Strong type signaling that a tuple of integers should be regarded as the index of a tile in the tenso...">TileIndex</a></li>
</ul>
</li>
<li>contain the same number of independent-indices</li>
<li>the set of independent indices is the same, and</li>
<li>each independent index maps to the same <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is the same as <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaf568271841950935c9b5cd21ec4758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf568271841950935c9b5cd21ec4758">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#acf6e9226c94b50733c1a0ba6b4faeec5">mapped_type</a>&amp; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#adf66b1504e7c0206fc34aa228c97e9db">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with the specified independent index. </p>
<p>This function can be used to retrieve the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with a independent index. Since this is a const method an exception will be raised if the independent index is not in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> (as it can not be added).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The independent index whose <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> we want. The rank of <code>key</code> must be equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44c7b0e49e36a57d92e1f111bd4c81ce" title="Returns the rank of the independent indices.">ind_rank()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a> associated with <code>key</code> in a read-only manner.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> is not in the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the rank of <code>key</code> is not equal to <code><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a44c7b0e49e36a57d92e1f111bd4c81ce" title="Returns the rank of the independent indices.">ind_rank()</a></code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a511907365fadafead4e13638657e4b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511907365fadafead4e13638657e4b1c">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedType <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the intersection of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> and another map. </p>
<p>Given two SparseMaps sm1(f -&gt; g) and sm2(f -&gt; g), the intersection is formed by mapping f_i to any element in g which f_i is mapped to by both sm1 and sm2. Note that if the ranks of the independent indices (or the dependent indices) are different between the two maps the intersection is empty. Similarly the intersection of any map with an empty map is also empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to take the intersection with this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The intersection of the two maps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69280ccc01a48b8ece75a0a6ec42926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69280ccc01a48b8ece75a0a6ec42926">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedType&amp; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this the intersection of this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> and another map. </p>
<p>Given two SparseMaps sm1(f -&gt; g) and sm2(f -&gt; g), the intersection is formed by mapping f_i to any element in g which f_i is mapped to by both sm1 and sm2. Note that if the ranks of the independent indices (or the dependent indices) are different between the two maps the intersection is empty. Similarly the intersection of any map with an empty map is also empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sm</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to take the intersection with this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> set to the intersection of the two maps.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to store the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade746d28bdc63a27ef712c94620f164f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade746d28bdc63a27ef712c94620f164f">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we are adding the string representation to. After this call the stream will contain the string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> with this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> added to it. </dd></dl>

</div>
</div>
<a id="a01f1ab18d065f00653b83d29458feaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f1ab18d065f00653b83d29458feaa0">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#a9c475619efe52b4e15b7bf202b868cc6">size_type</a> <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of independent indices in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. </p>
<p>Each independent index in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is paired with a <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a>. This function can be used to retrieve the number of independent indices in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>, which is also the number of Domains and the number of independent-index-domain pairs.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of independent indices in this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a266d573a5acf17556c9014b842fd19f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266d573a5acf17556c9014b842fd19f1">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">tensorwrapper::sparse_map::detail_::SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the state of two SparseMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The instance whose state is being swapped with. After this operation <code>rhs</code> will contain this instance's original state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a133651c177469b5769f44a3b9b88bfaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133651c177469b5769f44a3b9b88bfaa">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two SparseMaps are different. </p>
<p>Two SparseMaps are the same if they:</p><ul>
<li>map from the same type of independent/dependent index<ul>
<li><em>e.g.</em> independent indices ar both ElementalIndex and dependent indices are both <a class="el" href="structtensorwrapper_1_1sparse__map_1_1TileIndex.html" title="Strong type signaling that a tuple of integers should be regarded as the index of a tile in the tenso...">TileIndex</a></li>
</ul>
</li>
<li>contain the same number of independent-indices</li>
<li>the set of independent indices is the same, and</li>
<li>each independent index maps to the same <a class="el" href="classtensorwrapper_1_1sparse__map_1_1Domain.html" title="A set of element coordinate indices.">Domain</a></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedType</td><td>Type of the class implemented by the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> </td></tr>
    <tr><td class="paramname">IndIndex</td><td>Type of the independent indices </td></tr>
    <tr><td class="paramname">DepIndex</td><td>Type of the dependent indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> on the right side of the operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> on the left side of the operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> is the same as <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44ff90ff84b1c561f8fb7f4d5cef25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ff90ff84b1c561f8fb7f4d5cef25c2">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType , typename IndIndex , typename DepIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a>&lt; DerivedType, IndIndex, DepIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>smb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> to the stream. </p>
<p>This is a convenience function for calling <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html#ade746d28bdc63a27ef712c94620f164f" title="Adds a string representation of the SparseMap to the stream.">SparseMapBase::print</a> on a stream.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedType</td><td>The type of the class being implemented by <a class="el" href="classtensorwrapper_1_1sparse__map_1_1detail___1_1SparseMapBase.html">SparseMapBase</a> </td></tr>
    <tr><td class="paramname">IndIndex</td><td>The type of the independent indices. </td></tr>
    <tr><td class="paramname">DepIndex</td><td>The type of the dependent indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we are adding the string representation to. After this call the stream will contain the string representation of the <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smb</td><td>The <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> we are printing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> with this <a class="el" href="classtensorwrapper_1_1sparse__map_1_1SparseMap.html" title="Stores the sparsity relation among indices.">SparseMap</a> added to it. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tensorwrapper/sparse_map/sparse_map/detail_/<a class="el" href="sparse__map__base_8hpp_source.html">sparse_map_base.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
