<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::Tensor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">0.0.58</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetensorwrapper.html">tensorwrapper</a></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classtensorwrapper_1_1Tensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::Tensor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a multi-dimensional array of values.  
 <a href="classtensorwrapper_1_1Tensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tensor__class_8hpp_source.html">tensor_class.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tensorwrapper::Tensor:</div>
<div class="dyncontent">
<div class="center"><img src="classtensorwrapper_1_1Tensor__inherit__graph.png" border="0" usemap="#atensorwrapper_1_1Tensor_inherit__map" alt="Inheritance graph"/></div>
<map name="atensorwrapper_1_1Tensor_inherit__map" id="atensorwrapper_1_1Tensor_inherit__map">
<area shape="rect" title="Represents a multi&#45;dimensional array of values." alt="" coords="276,46,443,73"/>
<area shape="rect" href="classtensorwrapper_1_1detail___1_1DSLBase.html" title=" " alt="" coords="33,5,200,47"/>
<area shape="rect" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html" title=" " alt="" coords="5,71,228,112"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for tensorwrapper::Tensor:</div>
<div class="dyncontent">
<div class="center"><img src="classtensorwrapper_1_1Tensor__coll__graph.png" border="0" usemap="#atensorwrapper_1_1Tensor_coll__map" alt="Collaboration graph"/></div>
<map name="atensorwrapper_1_1Tensor_coll__map" id="atensorwrapper_1_1Tensor_coll__map">
<area shape="rect" title="Represents a multi&#45;dimensional array of values." alt="" coords="276,46,443,73"/>
<area shape="rect" href="classtensorwrapper_1_1detail___1_1DSLBase.html" title=" " alt="" coords="33,5,200,47"/>
<area shape="rect" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html" title=" " alt="" coords="5,71,228,112"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a272fea9e213b7be56e8e4feab18b53da"><td class="memItemLeft" align="right" valign="top"><a id="a272fea9e213b7be56e8e4feab18b53da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a272fea9e213b7be56e8e4feab18b53da">pimpl_type</a> = <a class="el" href="classtensorwrapper_1_1detail___1_1TensorPIMPL.html">detail_::TensorPIMPL</a></td></tr>
<tr class="memdesc:a272fea9e213b7be56e8e4feab18b53da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the object implementing *this. <br /></td></tr>
<tr class="separator:a272fea9e213b7be56e8e4feab18b53da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761be2f8023866d6b4dbcffb69d419be"><td class="memItemLeft" align="right" valign="top"><a id="a761be2f8023866d6b4dbcffb69d419be"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a761be2f8023866d6b4dbcffb69d419be">pimpl_pointer</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1Tensor.html#a272fea9e213b7be56e8e4feab18b53da">pimpl_type</a> &gt;</td></tr>
<tr class="memdesc:a761be2f8023866d6b4dbcffb69d419be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to an object of type pimpl_type. <br /></td></tr>
<tr class="separator:a761be2f8023866d6b4dbcffb69d419be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1eae787afa93e13c30631326573432"><td class="memItemLeft" align="right" valign="top"><a id="a2e1eae787afa93e13c30631326573432"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a2e1eae787afa93e13c30631326573432">logical_layout_type</a> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a811127e0e61e256475682ab5a35ca7e1">input_type::logical_layout_type</a></td></tr>
<tr class="memdesc:a2e1eae787afa93e13c30631326573432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an object storing the logical layout of the tensor. <br /></td></tr>
<tr class="separator:a2e1eae787afa93e13c30631326573432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f0826cf3a1b0b2241c728ecdf0ae84"><td class="memItemLeft" align="right" valign="top"><a id="ab9f0826cf3a1b0b2241c728ecdf0ae84"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#ab9f0826cf3a1b0b2241c728ecdf0ae84">const_logical_reference</a> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a68c18d210e3f26d574fb76b477189945">input_type::const_logical_reference</a></td></tr>
<tr class="memdesc:ab9f0826cf3a1b0b2241c728ecdf0ae84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the tensor's logical layout. <br /></td></tr>
<tr class="separator:ab9f0826cf3a1b0b2241c728ecdf0ae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d43088dce5da7fcaf93e981b273f1a"><td class="memItemLeft" align="right" valign="top"><a id="a40d43088dce5da7fcaf93e981b273f1a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a40d43088dce5da7fcaf93e981b273f1a">logical_layout_pointer</a> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#aa7081ea44dacf0d8b5d59acc668bf82f">input_type::logical_layout_pointer</a></td></tr>
<tr class="memdesc:a40d43088dce5da7fcaf93e981b273f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the tensor's logical layout. <br /></td></tr>
<tr class="separator:a40d43088dce5da7fcaf93e981b273f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c4e82268f2b91f0e8d6034830cf52a"><td class="memItemLeft" align="right" valign="top"><a id="a39c4e82268f2b91f0e8d6034830cf52a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a39c4e82268f2b91f0e8d6034830cf52a">buffer_reference</a> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a9eda2e42631e21ffac3f45f309e014bc">input_type::buffer_reference</a></td></tr>
<tr class="memdesc:a39c4e82268f2b91f0e8d6034830cf52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a mutable reference to the tensor's buffer. <br /></td></tr>
<tr class="separator:a39c4e82268f2b91f0e8d6034830cf52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3837f8a61174ecf23a5be4917269a50c"><td class="memItemLeft" align="right" valign="top"><a id="a3837f8a61174ecf23a5be4917269a50c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a3837f8a61174ecf23a5be4917269a50c">const_buffer_reference</a> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a6f1195780127ca59beb5ffde9f9796d1">input_type::const_buffer_reference</a></td></tr>
<tr class="memdesc:a3837f8a61174ecf23a5be4917269a50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to the tensor's buffer. <br /></td></tr>
<tr class="separator:a3837f8a61174ecf23a5be4917269a50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb33f6b728ebcefdeb05c9da8aab71f"><td class="memItemLeft" align="right" valign="top"><a id="a8bb33f6b728ebcefdeb05c9da8aab71f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a8bb33f6b728ebcefdeb05c9da8aab71f">buffer_pointer</a> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#aaea587da44957ed1348f1f54c534a27c">input_type::buffer_pointer</a></td></tr>
<tr class="memdesc:a8bb33f6b728ebcefdeb05c9da8aab71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the tensor's buffer. <br /></td></tr>
<tr class="separator:a8bb33f6b728ebcefdeb05c9da8aab71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c9c4f79c37305d246e52cd5e43dda9"><td class="memItemLeft" align="right" valign="top"><a id="a18c9c4f79c37305d246e52cd5e43dda9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a18c9c4f79c37305d246e52cd5e43dda9">const_buffer_pointer</a> = <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html#a5a79f1c9c540e48097c66e1b8265fb0e">input_type::const_buffer_pointer</a></td></tr>
<tr class="memdesc:a18c9c4f79c37305d246e52cd5e43dda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to a read-only buffer. <br /></td></tr>
<tr class="separator:a18c9c4f79c37305d246e52cd5e43dda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abb01b9a8aa77292e6ac80172f12477"><td class="memItemLeft" align="right" valign="top"><a id="a3abb01b9a8aa77292e6ac80172f12477"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a3abb01b9a8aa77292e6ac80172f12477">rank_type</a> = typename <a class="el" href="classtensorwrapper_1_1layout_1_1Logical.html#a9e4e0d859918af487ae9e20cea6865c4">logical_layout_type::size_type</a></td></tr>
<tr class="memdesc:a3abb01b9a8aa77292e6ac80172f12477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to convey rank. <br /></td></tr>
<tr class="separator:a3abb01b9a8aa77292e6ac80172f12477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85929ca1bb93159d162dbc8ab8104d77"><td class="memItemLeft" align="right" valign="top"><a id="a85929ca1bb93159d162dbc8ab8104d77"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a85929ca1bb93159d162dbc8ab8104d77">scalar_il_type</a> = double</td></tr>
<tr class="memdesc:a85929ca1bb93159d162dbc8ab8104d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if *this is a scalar. <br /></td></tr>
<tr class="separator:a85929ca1bb93159d162dbc8ab8104d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49549e657f4e223cfe7622f1b633e294"><td class="memItemLeft" align="right" valign="top"><a id="a49549e657f4e223cfe7622f1b633e294"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a49549e657f4e223cfe7622f1b633e294">vector_il_type</a> = std::initializer_list&lt; <a class="el" href="classtensorwrapper_1_1Tensor.html#a85929ca1bb93159d162dbc8ab8104d77">scalar_il_type</a> &gt;</td></tr>
<tr class="memdesc:a49549e657f4e223cfe7622f1b633e294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if *this is a vector. <br /></td></tr>
<tr class="separator:a49549e657f4e223cfe7622f1b633e294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0b6193c6ac4a8620bd0e477afc3c58"><td class="memItemLeft" align="right" valign="top"><a id="acf0b6193c6ac4a8620bd0e477afc3c58"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#acf0b6193c6ac4a8620bd0e477afc3c58">matrix_il_type</a> = std::initializer_list&lt; <a class="el" href="classtensorwrapper_1_1Tensor.html#a49549e657f4e223cfe7622f1b633e294">vector_il_type</a> &gt;</td></tr>
<tr class="memdesc:acf0b6193c6ac4a8620bd0e477afc3c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if *this is a matrix. <br /></td></tr>
<tr class="separator:acf0b6193c6ac4a8620bd0e477afc3c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea66c7afb686eeab03b13f1791d4848"><td class="memItemLeft" align="right" valign="top"><a id="a2ea66c7afb686eeab03b13f1791d4848"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a2ea66c7afb686eeab03b13f1791d4848">tensor3_il_type</a> = std::initializer_list&lt; <a class="el" href="classtensorwrapper_1_1Tensor.html#acf0b6193c6ac4a8620bd0e477afc3c58">matrix_il_type</a> &gt;</td></tr>
<tr class="memdesc:a2ea66c7afb686eeab03b13f1791d4848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if *this is a rank 3 tensor. <br /></td></tr>
<tr class="separator:a2ea66c7afb686eeab03b13f1791d4848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec53b217d9b03c0a4dafe6147dede129"><td class="memItemLeft" align="right" valign="top"><a id="aec53b217d9b03c0a4dafe6147dede129"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#aec53b217d9b03c0a4dafe6147dede129">tensor4_il_type</a> = std::initializer_list&lt; <a class="el" href="classtensorwrapper_1_1Tensor.html#a2ea66c7afb686eeab03b13f1791d4848">tensor3_il_type</a> &gt;</td></tr>
<tr class="memdesc:aec53b217d9b03c0a4dafe6147dede129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an initializer list if *this is a rank 4 tensor. <br /></td></tr>
<tr class="separator:aec53b217d9b03c0a4dafe6147dede129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtensorwrapper_1_1detail___1_1DSLBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html">tensorwrapper::detail_::DSLBase&lt; Tensor &gt;</a></td></tr>
<tr class="memitem:ae4cf93785043718e77bb36638cd7a8b9 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="ae4cf93785043718e77bb36638cd7a8b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ae4cf93785043718e77bb36638cd7a8b9">dsl_value_type</a> = <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:ae4cf93785043718e77bb36638cd7a8b9 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the derived class. <br /></td></tr>
<tr class="separator:ae4cf93785043718e77bb36638cd7a8b9 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe3c128cd26826333aa494b96a7281b inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="affe3c128cd26826333aa494b96a7281b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#affe3c128cd26826333aa494b96a7281b">dsl_const_value_type</a> = const <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ae4cf93785043718e77bb36638cd7a8b9">dsl_value_type</a></td></tr>
<tr class="memdesc:affe3c128cd26826333aa494b96a7281b inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only object of type dsl_value_type. <br /></td></tr>
<tr class="separator:affe3c128cd26826333aa494b96a7281b inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdad86554aa99fe9b5111737f6bd8571 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="abdad86554aa99fe9b5111737f6bd8571"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a> = <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ae4cf93785043718e77bb36638cd7a8b9">dsl_value_type</a> &amp;</td></tr>
<tr class="memdesc:abdad86554aa99fe9b5111737f6bd8571 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a reference to an object of type dsl_value_type. <br /></td></tr>
<tr class="separator:abdad86554aa99fe9b5111737f6bd8571 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a723bc12e6e338836c14bb47ea2555 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="af4a723bc12e6e338836c14bb47ea2555"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af4a723bc12e6e338836c14bb47ea2555">dsl_const_reference</a> = const <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ae4cf93785043718e77bb36638cd7a8b9">dsl_value_type</a> &amp;</td></tr>
<tr class="memdesc:af4a723bc12e6e338836c14bb47ea2555 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to an object of type dsl_value_type. <br /></td></tr>
<tr class="separator:af4a723bc12e6e338836c14bb47ea2555 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fb09448b438208f57cf081abeb6e6a inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="a09fb09448b438208f57cf081abeb6e6a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a09fb09448b438208f57cf081abeb6e6a">dsl_pointer</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ae4cf93785043718e77bb36638cd7a8b9">dsl_value_type</a> &gt;</td></tr>
<tr class="memdesc:a09fb09448b438208f57cf081abeb6e6a inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to an object of type dsl_value_type. <br /></td></tr>
<tr class="separator:a09fb09448b438208f57cf081abeb6e6a inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72659a6f55ee9bae43e1087aa1b086b inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="ad72659a6f55ee9bae43e1087aa1b086b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ad72659a6f55ee9bae43e1087aa1b086b">string_type</a> = std::string</td></tr>
<tr class="memdesc:ad72659a6f55ee9bae43e1087aa1b086b inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for representing the dummy indices as a string. <br /></td></tr>
<tr class="separator:ad72659a6f55ee9bae43e1087aa1b086b inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0161d627582c002dbd77d97c076976fb inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="a0161d627582c002dbd77d97c076976fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a0161d627582c002dbd77d97c076976fb">labeled_type</a> = <a class="el" href="classtensorwrapper_1_1dsl_1_1Labeled.html">dsl::Labeled</a>&lt; <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ae4cf93785043718e77bb36638cd7a8b9">dsl_value_type</a>, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ad72659a6f55ee9bae43e1087aa1b086b">string_type</a> &gt;</td></tr>
<tr class="memdesc:a0161d627582c002dbd77d97c076976fb inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a labeled object. <br /></td></tr>
<tr class="separator:a0161d627582c002dbd77d97c076976fb inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5273f3007852fd59832c5c916d812819 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="a5273f3007852fd59832c5c916d812819"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a5273f3007852fd59832c5c916d812819">labeled_const_type</a> = <a class="el" href="classtensorwrapper_1_1dsl_1_1Labeled.html">dsl::Labeled</a>&lt; <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#affe3c128cd26826333aa494b96a7281b">dsl_const_value_type</a>, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ad72659a6f55ee9bae43e1087aa1b086b">string_type</a> &gt;</td></tr>
<tr class="memdesc:a5273f3007852fd59832c5c916d812819 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a labeled read-only object (n.b. labels are mutable) <br /></td></tr>
<tr class="separator:a5273f3007852fd59832c5c916d812819 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ae4d4cac26930cf8338c1a24b004c4 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="aa0ae4d4cac26930cf8338c1a24b004c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> = typename <a class="el" href="classtensorwrapper_1_1dsl_1_1Labeled.html#a24a571ab75613584b5c4ccc1fc3a92fa">labeled_type::label_type</a></td></tr>
<tr class="memdesc:aa0ae4d4cac26930cf8338c1a24b004c4 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of parsed labels. <br /></td></tr>
<tr class="separator:aa0ae4d4cac26930cf8338c1a24b004c4 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177e1e11d1adce6f1c6d3b2515eee56c inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="a177e1e11d1adce6f1c6d3b2515eee56c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a177e1e11d1adce6f1c6d3b2515eee56c">labeled_reference</a> = <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a0161d627582c002dbd77d97c076976fb">labeled_type</a> &amp;</td></tr>
<tr class="memdesc:a177e1e11d1adce6f1c6d3b2515eee56c inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a mutable reference to a labeled_type object. <br /></td></tr>
<tr class="separator:a177e1e11d1adce6f1c6d3b2515eee56c inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81286387b2df29588b36bf10a073048 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="af81286387b2df29588b36bf10a073048"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> = const <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a5273f3007852fd59832c5c916d812819">labeled_const_type</a> &amp;</td></tr>
<tr class="memdesc:af81286387b2df29588b36bf10a073048 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to a labeled_type object. <br /></td></tr>
<tr class="separator:af81286387b2df29588b36bf10a073048 inherit pub_types_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html">tensorwrapper::detail_::PolymorphicBase&lt; Tensor &gt;</a></td></tr>
<tr class="memitem:a7e74500695d4b9ef7768743fe6c1e29b inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a id="a7e74500695d4b9ef7768743fe6c1e29b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a7e74500695d4b9ef7768743fe6c1e29b">base_type</a> = <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:a7e74500695d4b9ef7768743fe6c1e29b inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type *this is implementing. <br /></td></tr>
<tr class="separator:a7e74500695d4b9ef7768743fe6c1e29b inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4cdbec8c20631c3bf9caf684f0fe1c inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a id="a4d4cdbec8c20631c3bf9caf684f0fe1c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a4d4cdbec8c20631c3bf9caf684f0fe1c">base_reference</a> = <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a7e74500695d4b9ef7768743fe6c1e29b">base_type</a> &amp;</td></tr>
<tr class="memdesc:a4d4cdbec8c20631c3bf9caf684f0fe1c inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable reference to an object of type base_type. <br /></td></tr>
<tr class="separator:a4d4cdbec8c20631c3bf9caf684f0fe1c inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3ea0c25ad674f9796b74e2fe62a818 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a id="a4d3ea0c25ad674f9796b74e2fe62a818"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a4d3ea0c25ad674f9796b74e2fe62a818">const_base_reference</a> = const <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a7e74500695d4b9ef7768743fe6c1e29b">base_type</a> &amp;</td></tr>
<tr class="memdesc:a4d3ea0c25ad674f9796b74e2fe62a818 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only reference to an object of type base_type. <br /></td></tr>
<tr class="separator:a4d3ea0c25ad674f9796b74e2fe62a818 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808afdcccc21b8ad1a6e4a8ee2296ae1 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a id="a808afdcccc21b8ad1a6e4a8ee2296ae1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a808afdcccc21b8ad1a6e4a8ee2296ae1">base_rvalue</a> = <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a7e74500695d4b9ef7768743fe6c1e29b">base_type</a> &amp;&amp;</td></tr>
<tr class="memdesc:a808afdcccc21b8ad1a6e4a8ee2296ae1 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable rvalue reference to an object of type base_type. <br /></td></tr>
<tr class="separator:a808afdcccc21b8ad1a6e4a8ee2296ae1 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5623524f9de386896bc7600f78d0250e inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a id="a5623524f9de386896bc7600f78d0250e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a5623524f9de386896bc7600f78d0250e">base_pointer</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a7e74500695d4b9ef7768743fe6c1e29b">base_type</a> &gt;</td></tr>
<tr class="memdesc:a5623524f9de386896bc7600f78d0250e inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to an object of type base_type. <br /></td></tr>
<tr class="separator:a5623524f9de386896bc7600f78d0250e inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c3855ca63ff779fd2ed214510057c8 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a id="a49c3855ca63ff779fd2ed214510057c8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a49c3855ca63ff779fd2ed214510057c8">const_base_pointer</a> = std::unique_ptr&lt; const <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a7e74500695d4b9ef7768743fe6c1e29b">base_type</a> &gt;</td></tr>
<tr class="memdesc:a49c3855ca63ff779fd2ed214510057c8 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a read-only object of type base_type. <br /></td></tr>
<tr class="separator:a49c3855ca63ff779fd2ed214510057c8 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9531ddf5e054a4c914b5f54dc981238 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a id="ad9531ddf5e054a4c914b5f54dc981238"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#ad9531ddf5e054a4c914b5f54dc981238">string_type</a> = std::string</td></tr>
<tr class="memdesc:ad9531ddf5e054a4c914b5f54dc981238 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for representing *this as a string. <br /></td></tr>
<tr class="separator:ad9531ddf5e054a4c914b5f54dc981238 inherit pub_types_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad1e68d6937d1df0a3dc868096184d8bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#ad1e68d6937d1df0a3dc868096184d8bc">Tensor</a> (<a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html">input_type</a> input)</td></tr>
<tr class="memdesc:ad1e68d6937d1df0a3dc868096184d8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes *this by processing the input provided in <code>input</code>.  <a href="classtensorwrapper_1_1Tensor.html#ad1e68d6937d1df0a3dc868096184d8bc">More...</a><br /></td></tr>
<tr class="separator:ad1e68d6937d1df0a3dc868096184d8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45966a20a0c7dd0b0ef96314ad1ab42d"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = enable_if_no_tensors_t&lt;std::decay_t&lt;Args&gt;...&gt;&gt; </td></tr>
<tr class="memitem:a45966a20a0c7dd0b0ef96314ad1ab42d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a45966a20a0c7dd0b0ef96314ad1ab42d">Tensor</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a45966a20a0c7dd0b0ef96314ad1ab42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic value ctor.  <a href="classtensorwrapper_1_1Tensor.html#a45966a20a0c7dd0b0ef96314ad1ab42d">More...</a><br /></td></tr>
<tr class="separator:a45966a20a0c7dd0b0ef96314ad1ab42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb700692f2fa743a68734c440be08f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a8fb700692f2fa743a68734c440be08f9">Tensor</a> (const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;other)</td></tr>
<tr class="memdesc:a8fb700692f2fa743a68734c440be08f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes *this with a deep copy of <code>other</code>.  <a href="classtensorwrapper_1_1Tensor.html#a8fb700692f2fa743a68734c440be08f9">More...</a><br /></td></tr>
<tr class="separator:a8fb700692f2fa743a68734c440be08f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278149eaa7b86551d4b3a81ef2c5876b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a278149eaa7b86551d4b3a81ef2c5876b">Tensor</a> (<a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a278149eaa7b86551d4b3a81ef2c5876b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes *this with the state in <code>other</code>.  <a href="classtensorwrapper_1_1Tensor.html#a278149eaa7b86551d4b3a81ef2c5876b">More...</a><br /></td></tr>
<tr class="separator:a278149eaa7b86551d4b3a81ef2c5876b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4325a67ec34573a748491c32be7327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#aef4325a67ec34573a748491c32be7327">operator=</a> (const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;rhs)</td></tr>
<tr class="memdesc:aef4325a67ec34573a748491c32be7327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the state of *this with a deep copy of <code>rhs</code>.  <a href="classtensorwrapper_1_1Tensor.html#aef4325a67ec34573a748491c32be7327">More...</a><br /></td></tr>
<tr class="separator:aef4325a67ec34573a748491c32be7327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9cde4c7f75f1ef28728341c580f84c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#aea9cde4c7f75f1ef28728341c580f84c">operator=</a> (<a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:aea9cde4c7f75f1ef28728341c580f84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the state of *this with the state of <code>rhs</code>.  <a href="classtensorwrapper_1_1Tensor.html#aea9cde4c7f75f1ef28728341c580f84c">More...</a><br /></td></tr>
<tr class="separator:aea9cde4c7f75f1ef28728341c580f84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a73c265b181e4030f01b575335a3855"><td class="memItemLeft" align="right" valign="top"><a id="a6a73c265b181e4030f01b575335a3855"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a6a73c265b181e4030f01b575335a3855">~Tensor</a> () noexcept</td></tr>
<tr class="memdesc:a6a73c265b181e4030f01b575335a3855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted no-throw dtor. <br /></td></tr>
<tr class="separator:a6a73c265b181e4030f01b575335a3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93eb1f54cba7139b2b22b66f7c60459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1Tensor.html#ab9f0826cf3a1b0b2241c728ecdf0ae84">const_logical_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#aa93eb1f54cba7139b2b22b66f7c60459">logical_layout</a> () const</td></tr>
<tr class="memdesc:aa93eb1f54cba7139b2b22b66f7c60459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the tensor's logical layout.  <a href="classtensorwrapper_1_1Tensor.html#aa93eb1f54cba7139b2b22b66f7c60459">More...</a><br /></td></tr>
<tr class="separator:aa93eb1f54cba7139b2b22b66f7c60459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399184a167a00c7b2a6a8c84d8286135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1Tensor.html#a39c4e82268f2b91f0e8d6034830cf52a">buffer_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a399184a167a00c7b2a6a8c84d8286135">buffer</a> ()</td></tr>
<tr class="memdesc:a399184a167a00c7b2a6a8c84d8286135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable access to the tensor's buffer.  <a href="classtensorwrapper_1_1Tensor.html#a399184a167a00c7b2a6a8c84d8286135">More...</a><br /></td></tr>
<tr class="separator:a399184a167a00c7b2a6a8c84d8286135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bebb4bd3a8937abfdec46320f5bbdf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1Tensor.html#a3837f8a61174ecf23a5be4917269a50c">const_buffer_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a4bebb4bd3a8937abfdec46320f5bbdf8">buffer</a> () const</td></tr>
<tr class="memdesc:a4bebb4bd3a8937abfdec46320f5bbdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the tensor's buffer.  <a href="classtensorwrapper_1_1Tensor.html#a4bebb4bd3a8937abfdec46320f5bbdf8">More...</a><br /></td></tr>
<tr class="separator:a4bebb4bd3a8937abfdec46320f5bbdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c48548fc4b1209da578c00b17be45f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1Tensor.html#a3abb01b9a8aa77292e6ac80172f12477">rank_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a9c48548fc4b1209da578c00b17be45f8">rank</a> () const</td></tr>
<tr class="memdesc:a9c48548fc4b1209da578c00b17be45f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical rank of the tensor.  <a href="classtensorwrapper_1_1Tensor.html#a9c48548fc4b1209da578c00b17be45f8">More...</a><br /></td></tr>
<tr class="separator:a9c48548fc4b1209da578c00b17be45f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f9907fce0daa1f797f275701f65236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a47f9907fce0daa1f797f275701f65236">swap</a> (<a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a47f9907fce0daa1f797f275701f65236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the state of *this with the state of <code>other</code>.  <a href="classtensorwrapper_1_1Tensor.html#a47f9907fce0daa1f797f275701f65236">More...</a><br /></td></tr>
<tr class="separator:a47f9907fce0daa1f797f275701f65236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad163ce8eb5efbc96fba54a8a557d53cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#ad163ce8eb5efbc96fba54a8a557d53cc">operator==</a> (const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ad163ce8eb5efbc96fba54a8a557d53cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is *this value equal to <code>rhs</code>?  <a href="classtensorwrapper_1_1Tensor.html#ad163ce8eb5efbc96fba54a8a557d53cc">More...</a><br /></td></tr>
<tr class="separator:ad163ce8eb5efbc96fba54a8a557d53cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab063233acba20c6e07f46fb7222e9be3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#ab063233acba20c6e07f46fb7222e9be3">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ab063233acba20c6e07f46fb7222e9be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this different from <code>rhs</code>?  <a href="classtensorwrapper_1_1Tensor.html#ab063233acba20c6e07f46fb7222e9be3">More...</a><br /></td></tr>
<tr class="separator:ab063233acba20c6e07f46fb7222e9be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abce1ee61e8a582fca8d457999a493eb9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#abce1ee61e8a582fca8d457999a493eb9">Tensor</a> (<a class="el" href="classtensorwrapper_1_1Tensor.html#a85929ca1bb93159d162dbc8ab8104d77">scalar_il_type</a> il)</td></tr>
<tr class="memdesc:abce1ee61e8a582fca8d457999a493eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor from a (possibly) nested initializer list.  <a href="classtensorwrapper_1_1Tensor.html#abce1ee61e8a582fca8d457999a493eb9">More...</a><br /></td></tr>
<tr class="separator:abce1ee61e8a582fca8d457999a493eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade80d71ba9b98e3843dd73457902f6d0"><td class="memItemLeft" align="right" valign="top"><a id="ade80d71ba9b98e3843dd73457902f6d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Tensor</b> (<a class="el" href="classtensorwrapper_1_1Tensor.html#a49549e657f4e223cfe7622f1b633e294">vector_il_type</a> il)</td></tr>
<tr class="separator:ade80d71ba9b98e3843dd73457902f6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a120ab56ab40cab2ff4312429e987de"><td class="memItemLeft" align="right" valign="top"><a id="a9a120ab56ab40cab2ff4312429e987de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Tensor</b> (<a class="el" href="classtensorwrapper_1_1Tensor.html#acf0b6193c6ac4a8620bd0e477afc3c58">matrix_il_type</a> il)</td></tr>
<tr class="separator:a9a120ab56ab40cab2ff4312429e987de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20854559fca1dcb490e05613933c746"><td class="memItemLeft" align="right" valign="top"><a id="ab20854559fca1dcb490e05613933c746"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Tensor</b> (<a class="el" href="classtensorwrapper_1_1Tensor.html#a2ea66c7afb686eeab03b13f1791d4848">tensor3_il_type</a> il)</td></tr>
<tr class="separator:ab20854559fca1dcb490e05613933c746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621a5f5143e7d278c50c0cc0a91e6a72"><td class="memItemLeft" align="right" valign="top"><a id="a621a5f5143e7d278c50c0cc0a91e6a72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Tensor</b> (<a class="el" href="classtensorwrapper_1_1Tensor.html#aec53b217d9b03c0a4dafe6147dede129">tensor4_il_type</a> il)</td></tr>
<tr class="separator:a621a5f5143e7d278c50c0cc0a91e6a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtensorwrapper_1_1detail___1_1DSLBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html">tensorwrapper::detail_::DSLBase&lt; Tensor &gt;</a></td></tr>
<tr class="memitem:a13304dcd5e5f4e71ef85c53c92218fdf inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="a13304dcd5e5f4e71ef85c53c92218fdf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a13304dcd5e5f4e71ef85c53c92218fdf">~DSLBase</a> () noexcept=default</td></tr>
<tr class="memdesc:a13304dcd5e5f4e71ef85c53c92218fdf inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic no-throw defaulted dtor. <br /></td></tr>
<tr class="separator:a13304dcd5e5f4e71ef85c53c92218fdf inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eb6c7fa85642a8d9458f360c646ba3 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a0161d627582c002dbd77d97c076976fb">labeled_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ab6eb6c7fa85642a8d9458f360c646ba3">operator()</a> (LabelType &amp;&amp;labels)</td></tr>
<tr class="memdesc:ab6eb6c7fa85642a8d9458f360c646ba3 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates labels with the modes of *this.  <a href="classtensorwrapper_1_1detail___1_1DSLBase.html#ab6eb6c7fa85642a8d9458f360c646ba3">More...</a><br /></td></tr>
<tr class="separator:ab6eb6c7fa85642a8d9458f360c646ba3 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869ed602bc058cf88a1f17b8e9edaa7b inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a5273f3007852fd59832c5c916d812819">labeled_const_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a869ed602bc058cf88a1f17b8e9edaa7b">operator()</a> (LabelType &amp;&amp;labels) const</td></tr>
<tr class="memdesc:a869ed602bc058cf88a1f17b8e9edaa7b inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates labels with the modes of *this.  <a href="classtensorwrapper_1_1detail___1_1DSLBase.html#a869ed602bc058cf88a1f17b8e9edaa7b">More...</a><br /></td></tr>
<tr class="separator:a869ed602bc058cf88a1f17b8e9edaa7b inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb754acebdb8d12c93687a5a3eccfc1 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aacb754acebdb8d12c93687a5a3eccfc1">addition_assignment</a> (LabelType &amp;&amp;this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> lhs, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:aacb754acebdb8d12c93687a5a3eccfc1 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this to the result of <code>lhs</code> + <code>rhs</code>.  <a href="classtensorwrapper_1_1detail___1_1DSLBase.html#aacb754acebdb8d12c93687a5a3eccfc1">More...</a><br /></td></tr>
<tr class="separator:aacb754acebdb8d12c93687a5a3eccfc1 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8428c120176049e398ac8ba60034b3fd inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a8428c120176049e398ac8ba60034b3fd">subtraction_assignment</a> (LabelType &amp;&amp;this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> lhs, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:a8428c120176049e398ac8ba60034b3fd inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this to the result of <code>lhs</code> - <code>rhs</code>.  <a href="classtensorwrapper_1_1detail___1_1DSLBase.html#a8428c120176049e398ac8ba60034b3fd">More...</a><br /></td></tr>
<tr class="separator:a8428c120176049e398ac8ba60034b3fd inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd76bb7b627b14a67f64b3df9e907b7 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdd76bb7b627b14a67f64b3df9e907b7">multiplication_assignment</a> (LabelType &amp;&amp;this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> lhs, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:abdd76bb7b627b14a67f64b3df9e907b7 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this to the result of <code>lhs</code> * <code>rhs</code>.  <a href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdd76bb7b627b14a67f64b3df9e907b7">More...</a><br /></td></tr>
<tr class="separator:abdd76bb7b627b14a67f64b3df9e907b7 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa547edda9c9e2a1fc49b6f605ad4e523 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa547edda9c9e2a1fc49b6f605ad4e523">permute_assignment</a> (LabelType &amp;&amp;this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:aa547edda9c9e2a1fc49b6f605ad4e523 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets *this to a permutation of <code>rhs</code>.  <a href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa547edda9c9e2a1fc49b6f605ad4e523">More...</a><br /></td></tr>
<tr class="separator:aa547edda9c9e2a1fc49b6f605ad4e523 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0052a85a61b87d29d8f1cd0db0d0c43 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#ae0052a85a61b87d29d8f1cd0db0d0c43">scalar_multiplication</a> (LabelType &amp;&amp;this_labels, ScalarType &amp;&amp;scalar, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:ae0052a85a61b87d29d8f1cd0db0d0c43 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales *this by <code>scalar</code>.  <a href="classtensorwrapper_1_1detail___1_1DSLBase.html#ae0052a85a61b87d29d8f1cd0db0d0c43">More...</a><br /></td></tr>
<tr class="separator:ae0052a85a61b87d29d8f1cd0db0d0c43 inherit pub_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html">tensorwrapper::detail_::PolymorphicBase&lt; Tensor &gt;</a></td></tr>
<tr class="memitem:a024e62fa649f93a0cd1039a136381b47 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a id="a024e62fa649f93a0cd1039a136381b47"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a024e62fa649f93a0cd1039a136381b47">~PolymorphicBase</a> () noexcept=default</td></tr>
<tr class="memdesc:a024e62fa649f93a0cd1039a136381b47 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted no-throw polymorphic dtor. <br /></td></tr>
<tr class="separator:a024e62fa649f93a0cd1039a136381b47 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b29b65a2f44ca721ce151a312a98521 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a5623524f9de386896bc7600f78d0250e">base_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a3b29b65a2f44ca721ce151a312a98521">clone</a> () const</td></tr>
<tr class="memdesc:a3b29b65a2f44ca721ce151a312a98521 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep polymorphic copy of *this via the base class.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a3b29b65a2f44ca721ce151a312a98521">More...</a><br /></td></tr>
<tr class="separator:a3b29b65a2f44ca721ce151a312a98521 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cdc663a4e292257ec6a63815c17cbe inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#ad4cdc663a4e292257ec6a63815c17cbe">clone_as</a> () const</td></tr>
<tr class="memdesc:ad4cdc663a4e292257ec6a63815c17cbe inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep polymorphic copy, but returns the pointer as a class other than base_type.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#ad4cdc663a4e292257ec6a63815c17cbe">More...</a><br /></td></tr>
<tr class="separator:ad4cdc663a4e292257ec6a63815c17cbe inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6aec83f64355cc5d6b5cac49fc4308 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#aca6aec83f64355cc5d6b5cac49fc4308">are_equal</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a4d3ea0c25ad674f9796b74e2fe62a818">const_base_reference</a> rhs) const noexcept</td></tr>
<tr class="memdesc:aca6aec83f64355cc5d6b5cac49fc4308 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this and <code>rhs</code> are polymorphically equal.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#aca6aec83f64355cc5d6b5cac49fc4308">More...</a><br /></td></tr>
<tr class="separator:aca6aec83f64355cc5d6b5cac49fc4308 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fce0bfd83f932ec181aaeb0367ba712 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a0fce0bfd83f932ec181aaeb0367ba712">are_different</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a4d3ea0c25ad674f9796b74e2fe62a818">const_base_reference</a> rhs) const noexcept</td></tr>
<tr class="memdesc:a0fce0bfd83f932ec181aaeb0367ba712 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this and <code>rhs</code> are polymorphically different.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a0fce0bfd83f932ec181aaeb0367ba712">More...</a><br /></td></tr>
<tr class="separator:a0fce0bfd83f932ec181aaeb0367ba712 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299d66e878f901448a77207902096c85 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a299d66e878f901448a77207902096c85">to_string</a> () const</td></tr>
<tr class="memdesc:a299d66e878f901448a77207902096c85 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of *this.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a299d66e878f901448a77207902096c85">More...</a><br /></td></tr>
<tr class="separator:a299d66e878f901448a77207902096c85 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff9ec001f97f2275423b7ff2c8bc663 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a5ff9ec001f97f2275423b7ff2c8bc663">add_to_stream</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a5ff9ec001f97f2275423b7ff2c8bc663 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a string representation of *this to the stream.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a5ff9ec001f97f2275423b7ff2c8bc663">More...</a><br /></td></tr>
<tr class="separator:a5ff9ec001f97f2275423b7ff2c8bc663 inherit pub_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab2ce2b51c72c90122b4a8541e49b9a00"><td class="memItemLeft" align="right" valign="top"><a id="ab2ce2b51c72c90122b4a8541e49b9a00"></a>
<a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a5623524f9de386896bc7600f78d0250e">polymorphic_base::base_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#ab2ce2b51c72c90122b4a8541e49b9a00">clone_</a> () const override</td></tr>
<tr class="memdesc:ab2ce2b51c72c90122b4a8541e49b9a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements clone by calling copy ctor. <br /></td></tr>
<tr class="separator:ab2ce2b51c72c90122b4a8541e49b9a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cad0e946ec27dfff4633a772912926"><td class="memItemLeft" align="right" valign="top"><a id="a93cad0e946ec27dfff4633a772912926"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a93cad0e946ec27dfff4633a772912926">are_equal_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a4d3ea0c25ad674f9796b74e2fe62a818">const_base_reference</a> rhs) const noexcept override</td></tr>
<tr class="memdesc:a93cad0e946ec27dfff4633a772912926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements are_equal by calling are_equal_impl_. <br /></td></tr>
<tr class="separator:a93cad0e946ec27dfff4633a772912926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bff89ea84e11a9c62e26fcf13e448d8"><td class="memItemLeft" align="right" valign="top"><a id="a1bff89ea84e11a9c62e26fcf13e448d8"></a>
<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a1bff89ea84e11a9c62e26fcf13e448d8">addition_assignment_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> lhs, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs) override</td></tr>
<tr class="memdesc:a1bff89ea84e11a9c62e26fcf13e448d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements addition_assignment by calling addition_assignment on state. <br /></td></tr>
<tr class="separator:a1bff89ea84e11a9c62e26fcf13e448d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bf0b0273dc9cb846d3d43f7ec490ce"><td class="memItemLeft" align="right" valign="top"><a id="ab0bf0b0273dc9cb846d3d43f7ec490ce"></a>
<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#ab0bf0b0273dc9cb846d3d43f7ec490ce">subtraction_assignment_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> lhs, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs) override</td></tr>
<tr class="memdesc:ab0bf0b0273dc9cb846d3d43f7ec490ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls subtraction_assignment on each member. <br /></td></tr>
<tr class="separator:ab0bf0b0273dc9cb846d3d43f7ec490ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7c85ade2abc97cc75537c0a335e480"><td class="memItemLeft" align="right" valign="top"><a id="a0b7c85ade2abc97cc75537c0a335e480"></a>
<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a0b7c85ade2abc97cc75537c0a335e480">multiplication_assignment_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> lhs, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs) override</td></tr>
<tr class="memdesc:a0b7c85ade2abc97cc75537c0a335e480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls multiplication_assignment on each member. <br /></td></tr>
<tr class="separator:a0b7c85ade2abc97cc75537c0a335e480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32afbc83f70437e0fccfad74e864122a"><td class="memItemLeft" align="right" valign="top"><a id="a32afbc83f70437e0fccfad74e864122a"></a>
<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a32afbc83f70437e0fccfad74e864122a">scalar_multiplication_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, double scalar, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs) override</td></tr>
<tr class="memdesc:a32afbc83f70437e0fccfad74e864122a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls scalar_multiplication on each member. <br /></td></tr>
<tr class="separator:a32afbc83f70437e0fccfad74e864122a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac526039f86bd47f2508910e63e9cac"><td class="memItemLeft" align="right" valign="top"><a id="a0ac526039f86bd47f2508910e63e9cac"></a>
<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a0ac526039f86bd47f2508910e63e9cac">permute_assignment_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs) override</td></tr>
<tr class="memdesc:a0ac526039f86bd47f2508910e63e9cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls permute_assignment on each member. <br /></td></tr>
<tr class="separator:a0ac526039f86bd47f2508910e63e9cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57595ffa6cf6a16544b4cefb3a17de2a"><td class="memItemLeft" align="right" valign="top"><a id="a57595ffa6cf6a16544b4cefb3a17de2a"></a>
<a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#ad9531ddf5e054a4c914b5f54dc981238">polymorphic_base::string_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1Tensor.html#a57595ffa6cf6a16544b4cefb3a17de2a">to_string_</a> () const override</td></tr>
<tr class="memdesc:a57595ffa6cf6a16544b4cefb3a17de2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements to_string. <br /></td></tr>
<tr class="separator:a57595ffa6cf6a16544b4cefb3a17de2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classtensorwrapper_1_1detail___1_1DSLBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html">tensorwrapper::detail_::DSLBase&lt; Tensor &gt;</a></td></tr>
<tr class="memitem:a1261d0e2f3cc156aadb55aff0c848033 inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="a1261d0e2f3cc156aadb55aff0c848033"></a>
virtual <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a1261d0e2f3cc156aadb55aff0c848033">addition_assignment_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> lhs, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:a1261d0e2f3cc156aadb55aff0c848033 inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class should overwrite to implement addition_assignment. <br /></td></tr>
<tr class="separator:a1261d0e2f3cc156aadb55aff0c848033 inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcbb63e5d75306c054ae774f831049c inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="a9bcbb63e5d75306c054ae774f831049c"></a>
virtual <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a9bcbb63e5d75306c054ae774f831049c">subtraction_assignment_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> lhs, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:a9bcbb63e5d75306c054ae774f831049c inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class should overwrite to implement subtraction_assignment. <br /></td></tr>
<tr class="separator:a9bcbb63e5d75306c054ae774f831049c inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7d84d148e0bb06f2d5511828051b5b inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="a6b7d84d148e0bb06f2d5511828051b5b"></a>
virtual <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a6b7d84d148e0bb06f2d5511828051b5b">multiplication_assignment_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> lhs, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:a6b7d84d148e0bb06f2d5511828051b5b inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class should overwrite to implement multiplication_assignment. <br /></td></tr>
<tr class="separator:a6b7d84d148e0bb06f2d5511828051b5b inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008c5821003bdbf9019a88a3281dccfb inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="a008c5821003bdbf9019a88a3281dccfb"></a>
virtual <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#a008c5821003bdbf9019a88a3281dccfb">permute_assignment_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:a008c5821003bdbf9019a88a3281dccfb inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class should overwrite to implement permute_assignment. <br /></td></tr>
<tr class="separator:a008c5821003bdbf9019a88a3281dccfb inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7eb90ab162a003b30e1ca313620200 inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memItemLeft" align="right" valign="top"><a id="adf7eb90ab162a003b30e1ca313620200"></a>
virtual <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#abdad86554aa99fe9b5111737f6bd8571">dsl_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#adf7eb90ab162a003b30e1ca313620200">scalar_multiplication_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#aa0ae4d4cac26930cf8338c1a24b004c4">label_type</a> this_labels, double scalar, <a class="el" href="classtensorwrapper_1_1detail___1_1DSLBase.html#af81286387b2df29588b36bf10a073048">const_labeled_reference</a> rhs)</td></tr>
<tr class="memdesc:adf7eb90ab162a003b30e1ca313620200 inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class should overwrite to implement scalar_multiplication. <br /></td></tr>
<tr class="separator:adf7eb90ab162a003b30e1ca313620200 inherit pro_methods_classtensorwrapper_1_1detail___1_1DSLBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html">tensorwrapper::detail_::PolymorphicBase&lt; Tensor &gt;</a></td></tr>
<tr class="memitem:ab2ed41e0c812d0c07d7a59ef88beacb8 inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#ab2ed41e0c812d0c07d7a59ef88beacb8">PolymorphicBase</a> () noexcept=default</td></tr>
<tr class="memdesc:ab2ed41e0c812d0c07d7a59ef88beacb8 inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op default ctor.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#ab2ed41e0c812d0c07d7a59ef88beacb8">More...</a><br /></td></tr>
<tr class="separator:ab2ed41e0c812d0c07d7a59ef88beacb8 inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba66e5906f003079dd4ebe04ed18588 inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a6ba66e5906f003079dd4ebe04ed18588">PolymorphicBase</a> (const <a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html">PolymorphicBase</a> &amp;other)=default</td></tr>
<tr class="memdesc:a6ba66e5906f003079dd4ebe04ed18588 inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy ctor.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a6ba66e5906f003079dd4ebe04ed18588">More...</a><br /></td></tr>
<tr class="separator:a6ba66e5906f003079dd4ebe04ed18588 inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2223944f002e239a36207f6e5203b44b inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a2223944f002e239a36207f6e5203b44b">are_equal_impl_</a> (<a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a4d3ea0c25ad674f9796b74e2fe62a818">const_base_reference</a> rhs) const noexcept</td></tr>
<tr class="memdesc:a2223944f002e239a36207f6e5203b44b inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements are_equal_ assuming the derived class implements operator==.  <a href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a2223944f002e239a36207f6e5203b44b">More...</a><br /></td></tr>
<tr class="separator:a2223944f002e239a36207f6e5203b44b inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1769930a7d3e42d16cbfaaeec602de55 inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memItemLeft" align="right" valign="top"><a id="a1769930a7d3e42d16cbfaaeec602de55"></a>
virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1detail___1_1PolymorphicBase.html#a1769930a7d3e42d16cbfaaeec602de55">add_to_stream_</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a1769930a7d3e42d16cbfaaeec602de55 inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should be overridden by the derived class to provide logging details. <br /></td></tr>
<tr class="separator:a1769930a7d3e42d16cbfaaeec602de55 inherit pro_methods_classtensorwrapper_1_1detail___1_1PolymorphicBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a multi-dimensional array of values. </p>
<p>The <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> class is envisioned as being the most user-facing class of TensorWrapper and forms the entry point into TensorWrapper's DSL. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad1e68d6937d1df0a3dc868096184d8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e68d6937d1df0a3dc868096184d8bc">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html">input_type</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes *this by processing the input provided in <code>input</code>. </p>
<p>This ctor is only public to facilitate unit testing of the library. Users should ignore this ctor and focus on the variadic value ctor instead (which dispatches to this ctor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An implementation-defined object containing the inputs provided by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the inputs in <code>input</code> are not valid. Strong throw guarantee.</td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the state for *this. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45966a20a0c7dd0b0ef96314ad1ab42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45966a20a0c7dd0b0ef96314ad1ab42d">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, typename  = enable_if_no_tensors_t&lt;std::decay_t&lt;Args&gt;...&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variadic value ctor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>The types of the arguments. </td></tr>
    <tr><td class="paramname">&lt;Anonymous&gt;</td><td>Template parameter to disable this overload via SFINAE if any of the provided arguments are <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The intent is to create a tutorial showcasing how to initialize the <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> object under different conditions and NOT for the user to have to reverse engineer the options. For now, <a class="el" href="structtensorwrapper_1_1detail___1_1TensorInput.html" title="Type capable of holding all valid inputs to a Tensor&#39;s ctor.">detail_::TensorInput</a> is the authority on what inputs are allowed and <a class="el" href="classtensorwrapper_1_1detail___1_1TensorFactory.html" title="Object which helps create tensor objects.">detail_::TensorFactory</a> is the authority on what combinations and values are allowed.</dd></dl>
<p>This ctor is the default ctor (when <code>Args</code> is an empty parameter pack) and also the value ctor. Ultimately there are a lot of different ways to initialize a <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> object. To simplify the API of the <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> class we have defined a single ctor which works with all of them. Arguments to this ctor may be provided in any order and will be parsed by the backend. The backend is also responsible for determining appropriate defaults for the information given. While there are many valid input combinations, we anticipate users being most interested in the following use cases (for each use case the first phrase describes the inputs the ctor is invoked with and the remainder describes how *this will be initialized):</p>
<ul>
<li>No arguments. Creates an empty tensor. An empty tensor has no rank, and no elements. It is NOT a scalar. The resulting tensor primarily serves as a placeholder until it is initialized.</li>
<li>Logical layout. This use case includes providing a class from the <a class="el" href="classtensorwrapper_1_1layout_1_1Logical.html" title="Specializes a LayoutBase for a layout describing how a user wants to view the tensor.">layout::Logical</a> family or the inputs necessary to build one (minimally a shape, but also optionally the symmetry and sparsity). This is the ctor we want users to eventually target. At present the mapping from the logical layout to the physical layout is naive and unlikely to result in good performance.</li>
<li>Logical and physical layouts. We'll call this expert initialization. At present this is the use case to target if you are concerned with performance. Given both the logical and physical layouts the backend will dispatch to the tensor library designed for your use case.</li>
<li>(NYI) A container of elements. Envisioned to be used primarily for testing, this use case allows you to provide the literal elements of the tensor and the backend will fill in the rest.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Zero or more inputs to use to initialize *this. A compiler error will arise if a provided argument is not a valid input type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if at least one input is provided, but the provided input(s) are insufficient to initialize *this. Also raised if the provided inputs are inconsistent. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the state for *this. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abce1ee61e8a582fca8d457999a493eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce1ee61e8a582fca8d457999a493eb9">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1Tensor.html#a85929ca1bb93159d162dbc8ab8104d77">scalar_il_type</a>&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor from a (possibly) nested initializer list. </p>
<p>By nesting initializer lists it is possible to specify the initial values for a tensor and the logical layout. For example providing a single floating-point value indicates that the tensor is a scalar. Providing an initializer list of floating-point values indicates the tensor is a vector. Providing an initializer list of initializer lists of floating-point values creates a matrix, or in general <img class="formulaInl" alt="$r$" src="form_3.png"/> nested initializer lists create a rank <img class="formulaInl" alt="$r$" src="form_3.png"/> tensor.</p>
<dl class="section warning"><dt>Warning</dt><dd>At present these methods do NOT support jagged tensors. It is possible to extend these methods to jagged tensors, but it is not yet implemented.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Because of how C++ resolves initializer lists we need to have the public API overloaded for every rank tensor we want to support or require the user to work out the il type themselves. All of these dispatch to the same backend.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>A (possibly) nested initializer list containing the initial values for the tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>il</code> does not describe a smooth tensor. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fb700692f2fa743a68734c440be08f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb700692f2fa743a68734c440be08f9">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes *this with a deep copy of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The tensor to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem copying <code>other</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a278149eaa7b86551d4b3a81ef2c5876b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278149eaa7b86551d4b3a81ef2c5876b">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tensorwrapper::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes *this with the state in <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The tensor to take the state from. After the call <code>other</code> will be an empty tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a399184a167a00c7b2a6a8c84d8286135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399184a167a00c7b2a6a8c84d8286135">&#9670;&nbsp;</a></span>buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1Tensor.html#a39c4e82268f2b91f0e8d6034830cf52a">buffer_reference</a> tensorwrapper::Tensor::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutable access to the tensor's buffer. </p>
<p>The buffer of a tensor contains the actual elements. Generally speaking, users should not have to interact with the buffer. The primary exception to this is if the user wants to interface TensorWrapper with another tensor solution.</p>
<dl class="section return"><dt>Returns</dt><dd>A mutable reference to the buffer of the tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this is an empty tensor. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bebb4bd3a8937abfdec46320f5bbdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bebb4bd3a8937abfdec46320f5bbdf8">&#9670;&nbsp;</a></span>buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1Tensor.html#a3837f8a61174ecf23a5be4917269a50c">const_buffer_reference</a> tensorwrapper::Tensor::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only access to the tensor's buffer. </p>
<p>This method is the same as the non-const version except that resulting reference is read-only.</p>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the buffer of the tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this is an empty tensor. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa93eb1f54cba7139b2b22b66f7c60459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93eb1f54cba7139b2b22b66f7c60459">&#9670;&nbsp;</a></span>logical_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1Tensor.html#ab9f0826cf3a1b0b2241c728ecdf0ae84">const_logical_reference</a> tensorwrapper::Tensor::logical_layout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only access to the tensor's logical layout. </p>
<p>The logical layout of a tensor is how the user is thinking about it. This is usually different from how the tensor is actually stored by the backend. When interacting with the <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a> class it is always done assuming the tensor has the logical layout (to interact with the tensor in the way it is actually laid out go through the buffer).</p>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the logical layout of the tensor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this is an empty tensor. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab063233acba20c6e07f46fb7222e9be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab063233acba20c6e07f46fb7222e9be3">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tensorwrapper::Tensor::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this different from <code>rhs</code>? </p>
<p>Two tensors are defined to be different if they are not value equal. See operator== for the definition of value==.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The tensor to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if *this is value equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef4325a67ec34573a748491c32be7327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4325a67ec34573a748491c32be7327">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp; tensorwrapper::Tensor::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites the state of *this with a deep copy of <code>rhs</code>. </p>
<p>This method will release the state currently owned by *this and overwrite it with a deep copy of <code>rhs</code>. The copy will occur through <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a>'s copy ctor, so see that method for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The tensor to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this after replacing its state with a deep copy of <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the copy. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea9cde4c7f75f1ef28728341c580f84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9cde4c7f75f1ef28728341c580f84c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp; tensorwrapper::Tensor::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrites the state of *this with the state of <code>rhs</code>. </p>
<p>This method will release the state currently owned by *this and overwrite it with the state of <code>rhs</code>. The move will occur through <a class="el" href="classtensorwrapper_1_1Tensor.html" title="Represents a multi-dimensional array of values.">Tensor</a>'s move ctor, so see that method for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The tensor to take the state from. After this call <code>rhs</code> will be an empty tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this after replacing its state with the state in <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad163ce8eb5efbc96fba54a8a557d53cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad163ce8eb5efbc96fba54a8a557d53cc">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tensorwrapper::Tensor::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is *this value equal to <code>rhs</code>? </p>
<p>Two tensor objects are value equal if they are both empty tensors or if their respective logical layouts and buffers are polymorphically value equal. Of note this means that the floating point representation of the tensors' elements are compared for value equality and they must be exactly equal. It also means that even if two tensors have the same physical layout, if the user wants to think about them differently they will compare as not value equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The tensor to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this is value equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c48548fc4b1209da578c00b17be45f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c48548fc4b1209da578c00b17be45f8">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1Tensor.html#a3abb01b9a8aa77292e6ac80172f12477">Tensor::rank_type</a> tensorwrapper::Tensor::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the logical rank of the tensor. </p>
<p>Most users interacting with a tensor will be thinking of it in terms of its logical rank. This function is a convenience function for calling <code><a class="el" href="classtensorwrapper_1_1Tensor.html#a9c48548fc4b1209da578c00b17be45f8" title="Returns the logical rank of the tensor.">rank()</a></code> on the logical layout.</p>
<dl class="section return"><dt>Returns</dt><dd>The rank of the tensor, logically.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if *this does not have a logical layout. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47f9907fce0daa1f797f275701f65236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f9907fce0daa1f797f275701f65236">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tensorwrapper::Tensor::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the state of *this with the state of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The tensor to take the state from. After this call <code>other</code> will contain the state which was previously in *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/tensorwrapper/tensor/<a class="el" href="tensor__class_8hpp_source.html">tensor_class.hpp</a></li>
<li>src/tensorwrapper/tensor/tensor_class.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
