<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tensorwrapper: tensorwrapper::tensor::buffer::Buffer&lt; FieldType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tensorwrapper
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorwrapper</b></li><li class="navelem"><b>tensor</b></li><li class="navelem"><b>buffer</b></li><li class="navelem"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorwrapper::tensor::buffer::Buffer&lt; FieldType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wraps a tensor backend.  
 <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a25d650f8eb99fa174e6ecbf9017df8f3"><td class="memItemLeft" align="right" valign="top"><a id="a25d650f8eb99fa174e6ecbf9017df8f3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a25d650f8eb99fa174e6ecbf9017df8f3">annotation_type</a> = std::string</td></tr>
<tr class="memdesc:a25d650f8eb99fa174e6ecbf9017df8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indices in einstein/index-based operations. <br /></td></tr>
<tr class="separator:a25d650f8eb99fa174e6ecbf9017df8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51e3cfe51bca5e7201b4f644c865fd5"><td class="memItemLeft" align="right" valign="top"><a id="ae51e3cfe51bca5e7201b4f644c865fd5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> = const std::string &amp;</td></tr>
<tr class="memdesc:ae51e3cfe51bca5e7201b4f644c865fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to an annotation. <br /></td></tr>
<tr class="separator:ae51e3cfe51bca5e7201b4f644c865fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c2b895526792a8974a30445f1b67c6"><td class="memItemLeft" align="right" valign="top"><a id="a20c2b895526792a8974a30445f1b67c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a20c2b895526792a8974a30445f1b67c6">pimpl_pointer</a> = std::unique_ptr&lt; <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1detail___1_1BufferPIMPL.html">pimpl_type</a> &gt;</td></tr>
<tr class="memdesc:a20c2b895526792a8974a30445f1b67c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the PIMPL. <br /></td></tr>
<tr class="separator:a20c2b895526792a8974a30445f1b67c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f43fc46adeebc50503f0cd252396ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ad6f43fc46adeebc50503f0cd252396ee">hasher_type</a> = tensorwrapper::detail_::Hasher</td></tr>
<tr class="memdesc:ad6f43fc46adeebc50503f0cd252396ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to model the shape.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ad6f43fc46adeebc50503f0cd252396ee">More...</a><br /></td></tr>
<tr class="separator:ad6f43fc46adeebc50503f0cd252396ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7b52fe97e129da6ab4a3134059df4d"><td class="memItemLeft" align="right" valign="top"><a id="afa7b52fe97e129da6ab4a3134059df4d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#afa7b52fe97e129da6ab4a3134059df4d">hasher_reference</a> = <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ad6f43fc46adeebc50503f0cd252396ee">hasher_type</a> &amp;</td></tr>
<tr class="memdesc:afa7b52fe97e129da6ab4a3134059df4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable reference to a hasher. <br /></td></tr>
<tr class="separator:afa7b52fe97e129da6ab4a3134059df4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a172d0b07949feb986e70368d46bed8d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a172d0b07949feb986e70368d46bed8d0">Buffer</a> () noexcept</td></tr>
<tr class="memdesc:a172d0b07949feb986e70368d46bed8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted default ctor.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a172d0b07949feb986e70368d46bed8d0">More...</a><br /></td></tr>
<tr class="separator:a172d0b07949feb986e70368d46bed8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3106445a4972c6341019ba3ad31997b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a3106445a4972c6341019ba3ad31997b7">Buffer</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a20c2b895526792a8974a30445f1b67c6">pimpl_pointer</a> pimpl) noexcept</td></tr>
<tr class="memdesc:a3106445a4972c6341019ba3ad31997b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">PIMPL Ctor.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a3106445a4972c6341019ba3ad31997b7">More...</a><br /></td></tr>
<tr class="separator:a3106445a4972c6341019ba3ad31997b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3b5911e9ca4ecb1877feb11af97a00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#afa3b5911e9ca4ecb1877feb11af97a00">Buffer</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> &amp;other)</td></tr>
<tr class="memdesc:afa3b5911e9ca4ecb1877feb11af97a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> with a deep copy of another <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a>.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#afa3b5911e9ca4ecb1877feb11af97a00">More...</a><br /></td></tr>
<tr class="separator:afa3b5911e9ca4ecb1877feb11af97a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3b17a0a37d08a555a0a55cd16d04f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a6b3b17a0a37d08a555a0a55cd16d04f3">Buffer</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a6b3b17a0a37d08a555a0a55cd16d04f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> by taking ownership of another <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a>'s state.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a6b3b17a0a37d08a555a0a55cd16d04f3">More...</a><br /></td></tr>
<tr class="separator:a6b3b17a0a37d08a555a0a55cd16d04f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2354597e572890f326542dd39cf224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a1b2354597e572890f326542dd39cf224">operator=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> &amp;rhs)</td></tr>
<tr class="memdesc:a1b2354597e572890f326542dd39cf224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a deep-copy of <code>rhs</code> to this <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a>.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a1b2354597e572890f326542dd39cf224">More...</a><br /></td></tr>
<tr class="separator:a1b2354597e572890f326542dd39cf224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2ca3183c89337a8d0100c92ed3b8bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a8e2ca3183c89337a8d0100c92ed3b8bb">operator=</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8e2ca3183c89337a8d0100c92ed3b8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces this instance's state with that of <code>rhs</code>.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a8e2ca3183c89337a8d0100c92ed3b8bb">More...</a><br /></td></tr>
<tr class="separator:a8e2ca3183c89337a8d0100c92ed3b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c890d1d725b2a617b330fb2f4c12765"><td class="memItemLeft" align="right" valign="top"><a id="a3c890d1d725b2a617b330fb2f4c12765"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a3c890d1d725b2a617b330fb2f4c12765">~Buffer</a> () noexcept</td></tr>
<tr class="memdesc:a3c890d1d725b2a617b330fb2f4c12765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted destructor. <br /></td></tr>
<tr class="separator:a3c890d1d725b2a617b330fb2f4c12765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa249bcc37e3bd54592d6082e54186793"><td class="memItemLeft" align="right" valign="top"><a id="aa249bcc37e3bd54592d6082e54186793"></a>
<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1detail___1_1BufferPIMPL.html">pimpl_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pimpl</b> () noexcept</td></tr>
<tr class="separator:aa249bcc37e3bd54592d6082e54186793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ff7c675b21a22726b2bf7660c09ad3"><td class="memItemLeft" align="right" valign="top"><a id="ae2ff7c675b21a22726b2bf7660c09ad3"></a>
const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1detail___1_1BufferPIMPL.html">pimpl_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pimpl</b> () const noexcept</td></tr>
<tr class="separator:ae2ff7c675b21a22726b2bf7660c09ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302386157fc1044114f301fac8088966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a302386157fc1044114f301fac8088966">swap</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a302386157fc1044114f301fac8088966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the state of this <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> with that of <code>other</code>.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a302386157fc1044114f301fac8088966">More...</a><br /></td></tr>
<tr class="separator:a302386157fc1044114f301fac8088966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453196e577b87389ea1a5da9bbe24a98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a453196e577b87389ea1a5da9bbe24a98">is_initialized</a> () const noexcept</td></tr>
<tr class="memdesc:a453196e577b87389ea1a5da9bbe24a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if the <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> wraps an actual tensor or not.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a453196e577b87389ea1a5da9bbe24a98">More...</a><br /></td></tr>
<tr class="separator:a453196e577b87389ea1a5da9bbe24a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361552be0a5c2b3ac2ccbd7a0b430ebb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a361552be0a5c2b3ac2ccbd7a0b430ebb">scale</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> my_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> out_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;out, double rhs) const</td></tr>
<tr class="memdesc:a361552be0a5c2b3ac2ccbd7a0b430ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales (and optionally permutes) a tensor.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a361552be0a5c2b3ac2ccbd7a0b430ebb">More...</a><br /></td></tr>
<tr class="separator:a361552be0a5c2b3ac2ccbd7a0b430ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eab3e0a3e036a03bdae116cb3219d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#aa9eab3e0a3e036a03bdae116cb3219d5">add</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> my_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> out_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;out, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> rhs_idx, const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aa9eab3e0a3e036a03bdae116cb3219d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds (and optionally permutes) two tensors.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#aa9eab3e0a3e036a03bdae116cb3219d5">More...</a><br /></td></tr>
<tr class="separator:aa9eab3e0a3e036a03bdae116cb3219d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa190903c2f7c9e7129d3455c09845948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#aa190903c2f7c9e7129d3455c09845948">inplace_add</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> my_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> rhs_idx, const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:aa190903c2f7c9e7129d3455c09845948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums another tensor into this tensor.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#aa190903c2f7c9e7129d3455c09845948">More...</a><br /></td></tr>
<tr class="separator:aa190903c2f7c9e7129d3455c09845948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6e726505de3173a1d93f9bdab149cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#aba6e726505de3173a1d93f9bdab149cc">subtract</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> my_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> out_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;out, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> rhs_idx, const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aba6e726505de3173a1d93f9bdab149cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts (and optionally permutes) two tensors.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#aba6e726505de3173a1d93f9bdab149cc">More...</a><br /></td></tr>
<tr class="separator:aba6e726505de3173a1d93f9bdab149cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6de992408a085d1ca7a9b1ccf5b956"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a7f6de992408a085d1ca7a9b1ccf5b956">inplace_subtract</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> my_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> rhs_idx, const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:a7f6de992408a085d1ca7a9b1ccf5b956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts another tensor from this tensor.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a7f6de992408a085d1ca7a9b1ccf5b956">More...</a><br /></td></tr>
<tr class="separator:a7f6de992408a085d1ca7a9b1ccf5b956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf835ebce043cfd158fa702ce70dbf52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#adf835ebce043cfd158fa702ce70dbf52">times</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> my_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> out_idx, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;out, <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a> rhs_idx, const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;rhs) const</td></tr>
<tr class="memdesc:adf835ebce043cfd158fa702ce70dbf52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies (and optionally permutes) two tensors.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#adf835ebce043cfd158fa702ce70dbf52">More...</a><br /></td></tr>
<tr class="separator:adf835ebce043cfd158fa702ce70dbf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc67ec57f0a3c807a68bd524724f2dee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#acc67ec57f0a3c807a68bd524724f2dee">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:acc67ec57f0a3c807a68bd524724f2dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two Buffers for value equality.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#acc67ec57f0a3c807a68bd524724f2dee">More...</a><br /></td></tr>
<tr class="separator:acc67ec57f0a3c807a68bd524724f2dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef6e778e651ec2ad6cd88c648bb3404"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = enable_if_diff_field_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a9ef6e778e651ec2ad6cd88c648bb3404"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a9ef6e778e651ec2ad6cd88c648bb3404">operator==</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; T &gt; &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a9ef6e778e651ec2ad6cd88c648bb3404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two buffers with different fields.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a9ef6e778e651ec2ad6cd88c648bb3404">More...</a><br /></td></tr>
<tr class="separator:a9ef6e778e651ec2ad6cd88c648bb3404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a477f922b228e73393cb1942d62034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a26a477f922b228e73393cb1942d62034">hash</a> (<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#afa7b52fe97e129da6ab4a3134059df4d">hasher_reference</a> h) const</td></tr>
<tr class="memdesc:a26a477f922b228e73393cb1942d62034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the present buffer.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a26a477f922b228e73393cb1942d62034">More...</a><br /></td></tr>
<tr class="separator:a26a477f922b228e73393cb1942d62034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e081fb8d8ba6e7bdcc7a2bce74eb02"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a63e081fb8d8ba6e7bdcc7a2bce74eb02">print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a63e081fb8d8ba6e7bdcc7a2bce74eb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a buffer to the provided ostream.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a63e081fb8d8ba6e7bdcc7a2bce74eb02">More...</a><br /></td></tr>
<tr class="separator:a63e081fb8d8ba6e7bdcc7a2bce74eb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac7d7e6949b0a67e303fcdb093fddcc07"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac7d7e6949b0a67e303fcdb093fddcc07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ac7d7e6949b0a67e303fcdb093fddcc07">operator!=</a> (const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac7d7e6949b0a67e303fcdb093fddcc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two buffers are different.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ac7d7e6949b0a67e303fcdb093fddcc07">More...</a><br /></td></tr>
<tr class="separator:ac7d7e6949b0a67e303fcdb093fddcc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0df23ab5197ececb4c2e2897b3fb79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e0df23ab5197ececb4c2e2897b3fb79"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a8e0df23ab5197ececb4c2e2897b3fb79">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8e0df23ab5197ececb4c2e2897b3fb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a buffer to the provided ostream.  <a href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a8e0df23ab5197ececb4c2e2897b3fb79">More...</a><br /></td></tr>
<tr class="separator:a8e0df23ab5197ececb4c2e2897b3fb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename FieldType&gt;<br />
class tensorwrapper::tensor::buffer::Buffer&lt; FieldType &gt;</h3>

<p>Wraps a tensor backend. </p>
<p>The <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> class provides a uniform API for accessing the underlying tensor library, depending only on whether the underlying tensor has scalar elements or tensor elements.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldType</td><td>The type of the field the tensor is over. Expected to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad6f43fc46adeebc50503f0cd252396ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f43fc46adeebc50503f0cd252396ee">&#9670;&nbsp;</a></span>hasher_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ad6f43fc46adeebc50503f0cd252396ee">hasher_type</a> =  tensorwrapper::detail_::Hasher</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to model the shape. </p>
<p>Type of a read-only reference to the shape Type of the object used for hashing </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a172d0b07949feb986e70368d46bed8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172d0b07949feb986e70368d46bed8d0">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defaulted default ctor. </p>
<p>This ctor creates an uninitialized <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instance. The resulting instance has no PIMPL and can only be used after assigning an initialized <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instance to it.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3106445a4972c6341019ba3ad31997b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3106445a4972c6341019ba3ad31997b7">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#a20c2b895526792a8974a30445f1b67c6">pimpl_pointer</a>&#160;</td>
          <td class="paramname"><em>pimpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PIMPL Ctor. </p>
<p>Generally speaking <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instances are created by <a class="el" href="classtensorwrapper_1_1tensor_1_1Allocator.html" title="Abstracts away the details of how the TensorWrapper&#39;s internal tensor is formed.">Allocator</a> instances. The allocator instances are implemented in the source and have access to the backend specific PIMPLs (e.g. TABufferPIMPL). Thus what will usually happen is that the allocator makes a backend specific PIMPL and then uses that PIMPL to initialize a <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instance via this ctor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pimpl</td><td>An initialized backend specific PIMPL, passed via the base class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa3b5911e9ca4ecb1877feb11af97a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3b5911e9ca4ecb1877feb11af97a00">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> with a deep copy of another <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a>. </p>
<p>This ctor will initialize the present <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> to:</p>
<ul>
<li>an uninitiailzed state if <code>other.is_initialized() == false</code>, or</li>
<li>a deep copy of <code>other</code> otherwise.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The buffer being copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem initializing the <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b3b17a0a37d08a555a0a55cd16d04f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3b17a0a37d08a555a0a55cd16d04f3">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::<a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; FieldType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes this <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> by taking ownership of another <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a>'s state. </p>
<p>This function creates a new <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instance by taking ownership of the PIMPL pointer in <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> providing the state to this instance. After this call <code>other</code> will be in an uninitialized state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa9eab3e0a3e036a03bdae116cb3219d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eab3e0a3e036a03bdae116cb3219d5">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>my_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>out_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>rhs_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds (and optionally permutes) two tensors. </p>
<p>This function adds two tensors together, obtaining a third tensor. The addition is specified using einstein notation, which also allows one to permute the modes of the tensor as part of the operation.</p>
<div class="fragment"><div class="line"><span class="comment">// To run C(&quot;i,j&quot;) = A(&quot;j,i&quot;) + B(&quot;i,j&quot;) run:</span></div>
<div class="line">A.add(<span class="stringliteral">&quot;j,i&quot;</span>, <span class="stringliteral">&quot;i,j&quot;</span>, C, <span class="stringliteral">&quot;i,j&quot;</span>, B);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">my_idx</td><td>The einstein indices for the current buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_idx</td><td>The einstein indices for the output buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>The buffer to put the answer in. If <code>out</code> is default initialized, this function will default initialize an instance of this buffer's PIMPL before assigning to <code>out</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs_idx</td><td>The einstein indices for the buffer being added to this buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The buffer being added to this buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the present buffer is not initialized. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> is not initialize. Strong throw gurantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26a477f922b228e73393cb1942d62034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a477f922b228e73393cb1942d62034">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#afa7b52fe97e129da6ab4a3134059df4d">hasher_reference</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes the present buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>The object to use for hashing this instance. After this call the internal state of <code>h</code> will be updated to include a hash of this <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a>'s state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa190903c2f7c9e7129d3455c09845948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa190903c2f7c9e7129d3455c09845948">&#9670;&nbsp;</a></span>inplace_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::inplace_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>my_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>rhs_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums another tensor into this tensor. </p>
<p>This function will sum the tensor wrapped inside <code>rhs</code> into the tensor wrapped in the present instance. The present instance's state will be overriden with the result. The operation is expressed using einstein notation which allows a permutation to optionally happen as part of the operation.</p>
<div class="fragment"><div class="line"><span class="comment">// To run A(&quot;i,j&quot;) += B(&quot;j,i&quot;) run:</span></div>
<div class="line">A.inplace_add(<span class="stringliteral">&quot;i,j&quot;</span>, <span class="stringliteral">&quot;j,i&quot;</span>, B);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">my_idx</td><td>The einstein indices for the current buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs_idx</td><td>The einstein indices for the buffer being summed into the present buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The buffer being summed into this buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the present buffer is not initialized. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> is not initialized. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f6de992408a085d1ca7a9b1ccf5b956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6de992408a085d1ca7a9b1ccf5b956">&#9670;&nbsp;</a></span>inplace_subtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::inplace_subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>my_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>rhs_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts another tensor from this tensor. </p>
<p>This function will subtract the tensor wrapped inside <code>rhs</code> from the tensor wrapped in the present instance. The present instance's state will be overriden with the result. The operation is expressed using einstein notation which allows a permutation to optionally happen as part of the operation.</p>
<div class="fragment"><div class="line"><span class="comment">// To run A(&quot;i,j&quot;) -= B(&quot;j,i&quot;) run:</span></div>
<div class="line">A.inplace_subtract(<span class="stringliteral">&quot;i,j&quot;</span>, <span class="stringliteral">&quot;j,i&quot;</span>, B);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">my_idx</td><td>The einstein indices for the current buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs_idx</td><td>The einstein indices for the buffer being subtracted from the present buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The buffer being subtracted from this buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the present buffer is not initialized. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> is not initialized. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a453196e577b87389ea1a5da9bbe24a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453196e577b87389ea1a5da9bbe24a98">&#9670;&nbsp;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::is_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to determine if the <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> wraps an actual tensor or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> is currently wrapping a tensor and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw gurantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e2ca3183c89337a8d0100c92ed3b8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2ca3183c89337a8d0100c92ed3b8bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&amp; <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; FieldType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces this instance's state with that of <code>rhs</code>. </p>
<p>This function overrides the state of the current <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> (and thereby invalidates all references to its previous state) with the state of <code>rhs</code>. The state will be moved, and not copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> whose state is being taken. After this operation <code>rhs</code> will be in an uninitialized state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instance, after taking ownership of the state contained in <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b2354597e572890f326542dd39cf224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2354597e572890f326542dd39cf224">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&amp; <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a deep-copy of <code>rhs</code> to this <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a>. </p>
<p>This function will override the state of the current <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> (and thereby invalidating all references to the previous state) with: a deep copy of another instance (if <code>rhs</code> is initialized), or an uninitialized PIMPL if <code>rhs</code> is also uninitialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> we are assining this instance to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instance, now containing a deep copy of <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc67ec57f0a3c807a68bd524724f2dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc67ec57f0a3c807a68bd524724f2dee">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two Buffers for value equality. </p>
<p>Two Buffers are considered equal if they:</p>
<ul>
<li>are over the same field (i.e., have the same template type parameter),</li>
<li>have the same backend implementation, and</li>
<li>if the backend implementations compare equal by value.</li>
</ul>
<p>N.B. slight differences occurring from floating point arithmetic will result in this function returning inequality. Hence, in practice this function is primarily used in unit testing situations where the state of the <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> is tightly controlled. Algorithms depending on tensor equality typically want to use allclose (TODO: ensure there's a cross link).</p>
<p>This overload is selected when <code>rhs</code> has the same field as the present instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The buffer being compared to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ef6e778e651ec2ad6cd88c648bb3404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef6e778e651ec2ad6cd88c648bb3404">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename  = enable_if_diff_field_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two buffers with different fields. </p>
<p>This overload only participates in overload resolution when <code>T</code> is a different type than <code>FieldType</code>. This oveload always returns false because buffers over different fields are never equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The field for <code>rhs</code>. This function only participates in overload resolution if <code>T</code> is different than FieldType. </td></tr>
    <tr><td class="paramname">&lt;anonymous&gt;</td><td>Template parameter used to disable this function, via SFINAE, when <code>T</code> is the same as FieldType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The buffer to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False buffers are always different if they use different fields.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63e081fb8d8ba6e7bdcc7a2bce74eb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e081fb8d8ba6e7bdcc7a2bce74eb02">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a buffer to the provided ostream. </p>
<p>This function adds a text representation of the current tensor to the provided stream. The exact representation depends on the backend that is implementing the buffer. Generally speaking, the representation is only suitable for debugging purposes and should not be used as a long term means of storing the tensor or for data analysis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we are printing the buffer to. After this call <code>os</code> will contain a text representation of this buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> after adding this buffer to it.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::ios_base::failure</td><td>if adding the current <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instance to to the stream fails. After the throw the <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> will be in the same state, but the stream may be a different (albeit valid) state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a361552be0a5c2b3ac2ccbd7a0b430ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361552be0a5c2b3ac2ccbd7a0b430ebb">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>my_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>out_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales (and optionally permutes) a tensor. </p>
<p>This function scales a tensor using einstein notation. This means that if the indices on the left side of the equation are not in the same order as those on the right, in addition to scaling the tensor, this function will permute the modes.</p>
<div class="fragment"><div class="line"><span class="comment">// To run B(&quot;i,j&quot;) = 4.2 * A(&quot;j,i&quot;) run:</span></div>
<div class="line">A.scale(<span class="stringliteral">&quot;j,i&quot;</span>, <span class="stringliteral">&quot;i,j&quot;</span>, B, 4.2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">my_idx</td><td>The einstein indices for the current buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_idx</td><td>The einstein indices for the returned buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>The buffer to put the result into. If <code>out</code> was default initialized, this function will default initiailze a PIMPL of the same type as the current instance before assigning to it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The value to scale this tensor by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the present buffer is not initialized. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba6e726505de3173a1d93f9bdab149cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6e726505de3173a1d93f9bdab149cc">&#9670;&nbsp;</a></span>subtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>my_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>out_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>rhs_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts (and optionally permutes) two tensors. </p>
<p>This function subtracts two tensors together, obtaining a third tensor. The subtraction is specified using einstein notation, which also allows one to permute the modes of the tensor as part of the operation.</p>
<div class="fragment"><div class="line"><span class="comment">// To run C(&quot;i,j&quot;) = A(&quot;j,i&quot;) - B(&quot;i,j&quot;) run:</span></div>
<div class="line">A.subtract(<span class="stringliteral">&quot;j,i&quot;</span>, <span class="stringliteral">&quot;i,j&quot;</span>, C, <span class="stringliteral">&quot;i,j&quot;</span>, B);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">my_idx</td><td>The einstein indices for the current buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_idx</td><td>The einstein indices for the output buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>The buffer to put the answer in. If <code>out</code> is default initialized, this function will default initialize an instance of this buffer's PIMPL before assigning to <code>out</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs_idx</td><td>The einstein indices for the buffer being added to this buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The buffer being added to this buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the present buffer is not initialized. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> is not initialize. Strong throw gurantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a302386157fc1044114f301fac8088966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302386157fc1044114f301fac8088966">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; FieldType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the state of this <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> with that of <code>other</code>. </p>
<p>This function is used to swap the state of the present <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instance with the state of <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> whose state is being swapped with this instance's state. After this call <code>other</code> will contain the current <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a>'s state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf835ebce043cfd158fa702ce70dbf52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf835ebce043cfd158fa702ce70dbf52">&#9670;&nbsp;</a></span>times()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">tensorwrapper::tensor::buffer::Buffer</a>&lt; FieldType &gt;::times </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>my_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>out_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html#ae51e3cfe51bca5e7201b4f644c865fd5">const_annotation_reference</a>&#160;</td>
          <td class="paramname"><em>rhs_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">my_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies (and optionally permutes) two tensors. </p>
<p>This function multiplies two tensors together, obtaining a third tensor. The multiplication is specified using einstein notation, which also allows one to perform contractions and/or permute the modes of the tensor as part of the operation.</p>
<div class="fragment"><div class="line"><span class="comment">// To run C(&quot;i,j&quot;) = A(&quot;j,i&quot;) * B(&quot;i,j&quot;) run:</span></div>
<div class="line">A.times(<span class="stringliteral">&quot;j,i&quot;</span>, <span class="stringliteral">&quot;i,j&quot;</span>, C, <span class="stringliteral">&quot;i,j&quot;</span>, B);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">my_idx</td><td>The einstein indices for the current buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out_idx</td><td>The einstein indices for the output buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>The buffer to put the answer in. If <code>out</code> is default initialized, this function will default initialize an instance of this buffer's PIMPL before assigning to <code>out</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs_idx</td><td>The einstein indices for the buffer being added to this buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The buffer being added to this buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the present buffer is not initialized. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>rhs</code> is not initialize. Strong throw gurantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac7d7e6949b0a67e303fcdb093fddcc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d7e6949b0a67e303fcdb093fddcc07">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two buffers are different. </p>
<p>This function simply negates operator== and thus relies on its definition of equality.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The field type for the buffer to the left of operator!= </td></tr>
    <tr><td class="paramname">U</td><td>The field type for the buffer to the right of operator!=</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The buffer on the left </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The buffer on the right.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <code>lhs</code> is equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e0df23ab5197ececb4c2e2897b3fb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0df23ab5197ececb4c2e2897b3fb79">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html">Buffer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a buffer to the provided ostream. </p>
<p>This function simply calls the print <code>member</code> of the <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> class and exists so that <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instances can be printed via stream insertion operator (i.e., the usual C++ way).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The field type for the buffer. Expected to be either <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Scalar.html" title="Represents a field containing real or complex numbers.">field::Scalar</a> or <a class="el" href="structtensorwrapper_1_1tensor_1_1field_1_1Tensor.html" title="Represents a field containing tensors.">field::Tensor</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we are printing the buffer to. After this call <code>os</code> will contain a text representation of <code>rhs</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The buffer we are printing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> after adding <code>rhs</code> to it.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::ios_base::failure</td><td>if adding the current <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> instance to to the stream fails. After the throw the <a class="el" href="classtensorwrapper_1_1tensor_1_1buffer_1_1Buffer.html" title="Wraps a tensor backend.">Buffer</a> will be in the same state, but the stream may be a different (albeit valid) state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tensorwrapper/tensor/buffer/<a class="el" href="buffer_8hpp_source.html">buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
